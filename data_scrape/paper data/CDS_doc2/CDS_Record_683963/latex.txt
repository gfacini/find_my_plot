A Policy for ATLAS Software Quality Control

**Authors : Atlas Quality Control Group**

M. Asai, D. Barberis (chairman), M. Bosman, R. Jones, J.-F. Laporte, M. Stavrianakou

_Abstract_

_This document presents a proposed general policy for ATLAS software quality control and the global requirements on the quality control process. It defines the scope of the software concerned and the software quality criteria which are considered the most relevant to ATLAS._

Version : 4.2

Date : 17/11/99

Status : Released

**1 Introduction**

The purpose of this document is to define the general policy for the ATLAS software Quality Control and the global requirements to the Quality Control (QC) process. The organisation and mechanisms needed to implement the QC are outlined. This document is addressed to all members of the ATLAS community with the intention of reaching a broad consensus on the definition and implementation of the QC process.

Software quality has to be assured to achieve the goal of ATLAS to produce correct data using the resources efficiently and maintain it through the lifetime of the experiment. All software projects of such size and complexity, in high energy physics (HEP), other research fields and industry, have acknowledged the importance and benefits of implementing a QC process from an early stage. It is not only beneficial for the quality of the software but also for improving the skills of the developers.

This document is produced by the QC Group that has been created as part of the ATLAS Computing Action Plan [1] put forward by the ATLAS management following the computing review of ATLAS [2]. The QC Group should define the policy and basis of the procedure to ensure its application. This procedure will replace the ATLAS Software Process (ASP) [3].

Ensuring the quality of the software was one of the main goals of the ASP. The aim of the QC Group is to ensure that this goal will be fully endorsed by the community in the current and future software activities. In addition, quality assurance should be an assistance to developers rather than a constraint or additional burden. The group should outline a procedure that evolves as the ATLAS software community gains experience with the software quality model. The group should also help to define the basic development environment incorporating the tools necessary to achieve the desired software quality.

The document is organised as follows. Section 2 gives an overview of the ATLAS software considered in this document and a brief description of the particularities of the ATLAS environment. Section 3 outlines the model proposed for the software quality assurance. Section 4 lists the main criteria that will be used to evaluate the quality of the software. Section 5 outlines the implementation of the software quality model.

**2 ATLAS Software Overview**

The software considered in this quality model is the offline software, i.e. all the software necessary for data processing and analysis offline. It also includes event filtering and physics monitoring on-line as well as the simulation of the LVL1 and LVL2 triggers. The model can be adapted to be applied to external software.

The Architecture Task Force (ATF) [4] is working on providing a global architecture for that software: the architecture will eventually result in a domain decomposition and the assignment of software packages to Working Groups (architecture, detector systems, combined performance, physics performance). The implementation of the software quality model will take place within the Working Groups, with a QC group overseeing and coordinating their work.

The ATLAS experiment is a very large community. Many institutes, widely distributed geographically, contribute to the software. Usually, there are only a few developers in eachgroup. Good communication channels and availability of information have to be assured. In addition, the software is going through a transition phase to OO/C\(++\). Many contributors are newcomers to C\(++\), to OO and also to QC procedures, and will go through a learning phase. The C\(++\) language and Object-Oriented approach introduces new concepts that require more guidance for software developers and the elements of the QC process, such as the Coding Conventions, are intended to be an aid. The chosen strategy for QC must take these facts into account and the policy should distinguish the long term target from the transition phase.

The present policy document, released in October 1999, will be followed by a document proposing Coding Conventions by November 1999. Then the QC process and its implementation should be defined in writing by December. The QC Group will then evolve into a group which coordinates the software QC activity across the software development working groups.

ATLAS aims to organise the software into work packages to which institutions shall commit themselves; these formal commitments will of course include the QC requirements. The software agreements and the Memorandum of Understanding (SMoU) should be prepared during the year 2000.

## 3 Software Quality Model

The long-term target of the software quality policy is to verify that the software is well adapted to its purpose by examining its design and structure through organised inspections and reviews and to ensure the code is correct, robust and performant via testing procedures. The availability of good documentation is considered essential.

A model has been developed to reach the long term goal, at the same time as giving the flexibility to follow the evolution of the software development of ATLAS during the transition period. This software "onion" model consists of the "kernel" software in the centre and outer layers made of domain specific, detector specific then individual physicist's software. In this model, the more widely used and long living software are closer to the core. This software, due to its importance to the experiment as a whole, should satisfy stricter requirements than an individual's private software. Software for personal usage can be freer but the authors should be aware that if they want to promote their software to a higher status (for example from exploratory analysis to a tool of a working group), then they will have to comply with stricter conditions, especially in terms of documentation and coding guidelines.

There are two aspects in the quality of the software that should be distinguished1. The first addresses the technical aspects of the code quality, such as speed of execution, use of memory and portability etc. The second aspect concerns the physics performances of the algorithms such as the efficiency, the resolution of the computed physics quantities and tails in the distributions etc. Both aspects are addressed in this document.

Footnote 1: See the BaBar concept of Coding and Data quality issues [5].

The responsibility for QC should be assigned following the project management structure. That is to say, an individual or a group responsible for a software package or collection of packages should also be responsible for their quality.

## 4 Software Quality Criteria

A list of criteria that define the quality of the software is given below.

### Quality of design

#### 4.1.1 Definition

The code should have a clear design, be modular and be compatible with the global ATLAS software architecture.

#### 4.1.2 Explanation

The aspects that will be considered are not only the internal design of the package but also its integration in the overall ATLAS software environment. Strict criteria will be applied to the quality of the interfaces already during the transition period.

### Documentation

#### 4.2.1 Definition

Each piece of code has to be accompanied by the appropriate documentation. The documentation should consist of:

* a document stating clearly what is the task the code should perform, and which is the method (algorithm) used to achieve this task;
* a software design document;
* a description of input and output interfaces to the piece of code ("users' guide");
* an example of usage and all accessory files to run the example.

The documentation must be kept up-to-date with the software.

#### 4.2.2 Explanation

The task to be accomplished by the piece of software and the algorithm(s) used should be clearly described in full detail.

The design should be documented both in English and (for new software) also in Unified Modelling Language (UML) [6] form: all classes and their interrelations should be described. Existing C++ software should be "reverse engineered" to document the design as far as possible.

Special emphasis should be given to the "users' guide" that should contain a detailed description of all input and output parameters, as well as any other information directly useful for the integration of the given piece of software into the existing environment.

The example of usage should also specify a testing procedure and contain a reference set of results for given input conditions. This should allow the user to check that the package is being used correctly.

After the transition period, complete documentation will be required for all publicly available pieces of software.

**4.3 Coding conventions**

#### 4.3.1 Definition

Coding conventions are meant to help C++ programmers to meet the following requirements on a program:

* be free of common types of errors
* be maintainable by different programmers
* be portable to other operating systems
* be easy to read and understand
* have a consistent style

#### 4.3.2 Explanation

The coding conventions will be adapted from the SPIDER project [7]. They will be classified by importance. The applicability of each convention will be defined as a function of its importance and the centrality of the piece of software concerned. Code examples will be given for each convention. An automatic tool to check at least the most important coding conventions will be provided.

**4.4 Robustness**

#### 4.4.1 Definition

The robustness encompasses all the "technical" qualities that should characterise a piece of the code. It should use the computer's resources efficiently, be stable, and run in the various required environments.

#### 4.4.2 Explanation

The code should be correct and efficient in terms of memory usage and execution. Its execution should not adversely affect other software modules.

Some simple metrics, like code size and code/comments ratio, will be applied to the code. More complex OO metrics will be considered as the complexity of the software increases.

The code should compile and run correctly on all the official platforms. The code should not crash but rather give warnings even in case of incorrect running conditions.

#### 4.5.1 Definition

The maintainability of the code is related to the effort needed to identify, make and validate necessary modifications.

#### 4.5.2 Explanation

The diagnosis of problems and the identification of the part of code to be modified should be achievable with reasonable effort by a person other than the author. To this end, the code should be readable and internal diagnostic (e.g. tracing facilities) must be provided when possible. Changes of environment (e.g. running on another computer platform or in a different context such as offline reconstruction or the event filter) should be possible using the means provided for this purpose by the software. Adapting the testing procedure to the new environment should be reasonably straightforward.

### 4.6 Performance

#### 4.6.1 Definition

The algorithms(s) provided by a piece of code should satisfy the required physics performance criteria.

#### 4.6.2 Explanation

The physics quantities computed in an algorithm should comply with the standard of precision and efficiency required in the context in which it is used. Other factors play a role here, such as the trade-off between efficiency and speed or effect on the precision of the quality of calibration or alignment constants available at the time the calculations are performed. The subsystem and combined performance groups have to define the requirements on the performances and organise the evaluation procedure.

## 5 Implementing the Software Quality Model

There are two elements in the implementation of the software quality model: provide support to the developer to check and improve his own software; set-up a mechanism of validation of software packages by a process of peer reviews.

The support to the developer includes automatic checking tools for coding conventions, skeletons of code for the most common tasks and templates for all the documents that are required.

The validation mechanism will be achieved through a combination of inspections, walk-throughs, reviews and tests organised by the relevant groups.

A testing plan describing the features to be tested and the results of the tests will be part of the validation process.

All code should be shared through the ATLAS software repository. Only the package versions that have passed through the QC validation procedure can be included in the official software releases. The strictness of the validation criteria will evolve during the transition period.

## 6 Summary

Software quality has to be assured to reach the goal of ATLAS to produce correct data using resources efficiently and be able to maintain it throughout the lifetime of the experiment. The general policy for the ATLAS software quality control has been defined and the global requirements on the quality control process have been set in this document. In addition to quality assurance, the aim of the process is to provide a useful aid to the developer.

The software considered in this quality model is the offline software, i.e. all the software necessary for data processing and analysis offline, including event filtering and physics monitoring on-line. It can be adapted to external software.

Both coding quality and physics performance aspects are considered. The list of criteria considered are: clarity and structure of design, documentation, compliance with coding conventions, robustness, maintainability and physics performance. The implementation of the software quality model has been briefly outlined and should be defined in more detail in a future document.

## References

* [1] ATLAS Computing action plan, P.Jenni and T.Akesson. [http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/architecture/action_plan](http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/architecture/action_plan)
* [2] Report of the ATLAS Computing Review Committee (AT-RO-MR-0001) H.A.Neal.
* [3] The ATLAS Software process, ed. by S.M. Fisher [http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/asp/ref/ref.html](http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/asp/ref/ref.html)
* Architecture Task Force [http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/architecture/](http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/architecture/)
* [5] BaBar Quality Assurance: [http://hepunx.rl.ac.uk/BFROOT/www/Computing/Programming/QA/QAHome.html](http://hepunx.rl.ac.uk/BFROOT/www/Computing/Programming/QA/QAHome.html) BaBar Quality Control: [http://hepunx.rl.ac.uk/BFROOT/www/Computing/Programming/QC/QCHome.html](http://hepunx.rl.ac.uk/BFROOT/www/Computing/Programming/QC/QCHome.html)
* [6] Rational Corporation. UML [http://www.rational.com/uml/index.jtmpl](http://www.rational.com/uml/index.jtmpl)