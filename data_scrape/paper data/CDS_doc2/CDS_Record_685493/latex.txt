**Evaluation of the Relational Implementation of the Conditions Database Interface**

\begin{tabular}{l l} \hline
**Author:** & A.Amorim, N.Barros, D.Klose, J.Lima, C.Oliveira, L.Pedro \\
**Date:** & February 2003 \\ \hline \end{tabular}

**Abstract**

The ConditionsDB interface is a C++ class library, built on top of a database management system, to enable storage and retrieval of detector-related information with an associated period of validity.

This document describes a first comparison study between the Oracle v0.4.1.6 and the MySQL v0.2.6b implementations of the ConditionsDB interface. A set of performance tests were executed both running locally in the database server machine and using clients in remote machines.

It also addresses the issues related to the Large Scale Tests performed using the MySQL prototype.

The necessary steps to build and install both implementations are also described.

###### Contents

* Comparison between MySQL and Oracle implementations * 1.1 Introduction * 1.2 Setting up the system * 1.3 Running examples * 1.3.1 Description of the tests * 1.4 Intensive Usage
* Large Scale Tests * 2.1 Introduction * 2.2 System Setup * 2.3 Large Scale Tests Results
* 3 Conclusions
* Installing, setting up and running the MySQL and ORACLE servers, compiling and using the ConditionsDB API on Linux * 4.1 Using MySQL * 4.2 Using ORACLE
* Detailed test results for the MySQL and Oracle implementation of ConditionsDB * 5.1 MySQL * 5.2 Oracle
* Graphical representation of the results for the Large Scale Tests

## List of Figures

* 1 _time_ values for the MySQL implementation of ConditionsDB (local and remote)
* 2 _time_ values for the Oracle implementation of ConditionsDB (local and remote)
* 3 _time_ values for the MySQL implementation of ConditionsDB with intensive usage tests (local and remote)
* 4 _time_ values for the Oracle implementation of ConditionsDB with intensive usage tests (local and remote)
* 5 Short
* 6 objects stored vs. time spent storing for MySQL and Oracle implementations (remote)
* 7 objects stored vs. time spent reading for MySQL and Oracle implementations (local)
* 8 objects stored vs. time spent reading for MySQL and Oracle implementations (remote)
* fixating the number of controllers
* fixating the number of objects stored
* fixating the number of controllers
* fixating the number of objects stored
* fixating the number of controllers
* fixating the number of objects stored
* 15 MySQL implementation: local / remote
* Intensive Usage
* Intensive Usage
* 18 Oracle implementation: local / remote
* Intensive Usage
* Intensive Usage
* fixating the number of controllers
* fixating the number of objects stored
* fixating the number of controllers
* fixating the number of objects stored
* fixating the number of controllers
* fixating the number of objects stored

## 1 Part I - Comparison between MySQL and Oracle implementations

### 1.1 Introduction

The purpose of this work is to evaluate the performance of the Oracle and MySQL implementations of Conditions Database (ConditionsDB) as they are implemented at the present moment and to suggest paths for improvement for both implementations.

The comparison was carried out using both the examples distributed with the Oracle implementation, that were also used, with the appropriate modifications, on the MySQL implementation and implementing new intensive usage examples that were created and applied to both implementations. These new applications, developed to evaluate the intensive usage of the ConditionsDB include not only creating complex foldersets and folder based structures but also storing and retrieving large number of objects.

The time spent running each one of this examples was measured and provided the source for the comparison results.

### 1.2 Setting up the system

Both implementations can be found at standard CERN AFS locations and both bring documentation on how to correctly set up the system in order to achieve compilation without errors.

An Oracle or a MySQL server must be available to support the databases and the client API's libraries must also be installed in order to correctly build the implementations. Both setup procedures are described in detail in Appendix A. Installing the ORACLE version the Oracle 9i, Release 2 on Suse Linux was rather straighforeward once the respective Suse rpm was used. This is not the case for release 1 where several ad hoc operations have to be performed. Information on how to install this previous release is available from the authors.

### 1.3 Running examples

All the tests were performed using a database server in a Linux PC with the following configuration:

* Intel Pentium 4, 1,6GHZ
* 756Mb DDR RAM PC133MHz
* 30 Gb HDD, ATA100, 7200RPM

* Operating System:
* Suse 8.0, linux kernel 2.4.18-64GB-SMP
* Database Servers:
* Oracle: Oracle9i Enterprise Edition Release 9.2.0.1.0 - Production With the Partitioning, OLAP and Oracle Data Mining options JServer Release 9.2.0.1.0 - Production
* MySQL: Distrib 3.23.48

Below is the list of all the examples used on the tests, as well as a brief description of the different steps involved. Some benchmarks were adapted from the examples distributed in the 0.4.1.6 distribution of the Oracle implementation that were also migrated to the MySQL implementation. Due to the abstract interface design of the ConditionsDb interface, the migration to MySQL is easily accomplished with minor changes in the code.

From the common code:

_#include \(<\)ConditionsDB/CondDBXXXXMgrFactory.h\(>\)_

...

_ICondDBMgr* CondDBmgr = CondDBXXXX MgrFactory::createCondDBMgr();_

...

_CondDBmgr-\(>\)init();_

...

_CondDBXXXXMgrFactory::destroyCondDBMgr( CondDBmgr );_

XXXX must be changed for the specific implementation. For MySQL it must be changed to MySQL and for Oracle to OracleDB.

#### Description of the tests

* Connects to the database server. Verifyes if a folder-set/folder structure _(cal/temp)_ exists. Should not exist, creates it.
* Stores an object under a given folder with defined characteristics, such as _time validity, insertionTime, layer_ and _data_. _exampleObject_ creates one object and _storeData_ creates three objects with different time validity.
* Reads an object already stored and prints out all it's properties.
* Extends the functionality of all the procedures (_NOTE_
- this test was not migrated to MySQL).
To measure the time spent by each test, the time Unix function was used by preceeding the command by "time". We have recorded the _real time_, the _user time_ and _system time_. From the manual page of the function comes the definitions: _real time - the elapsed real time between invocation and termination, user time - the user CPU time, system time - the system CPU time_.

The real time for each test is listed bellow. The chosen value includes the time spent on network transport. All tests were done in dedicated machines that were performing only this task. Appendix B contains the detailed test results for real, user and system time.

* **MySQL Results**

* **Oracle Results**

### Intensive Usage

The following tests were implemented in order to test the different implementations in it's functionalities and to see it's behaviour under heavy load, creating the database structures and performing intensive storage and reading procedures. The tests are based on the examples distributed with the Oracle implementation.

### Intensive Usage

Figure 1: _time_ values for the MySQL implementation of ConditionsDB (local and remote)

Figure 2: _time_ values for the Oracle implementation of ConditionsDB (local and remote)

- Connects to a given database in the database server. If none exists, creates a defined structure associated with the three levels of foldersets and a folder.
* Connects to the database server. Verifies the existence of a defined folder. If it does not exist, it is created. The user is prompted for the number of objects to be stored. All objects will be stored using the same _time validity, insertionTime_, and _data_, but each will be in a different _layer_.
* Connects to the database server. Looks into a defined folder and sees if it's not empty. Gets all the objects stored in that folder and iterates over all, showing their values.

For the _storeDatax_ test, diferent quantities of objects were stored in order to study the relation between objects stored vs. time spent storing and between objects stored vs. time spent reading.

### Intensive Usage

Figure 3: _time_ values for the MySQL implementation of ConditionsDB with intensive usage tests (local and remote)

[MISSING_PAGE_EMPTY:8]

### Intensive Usage

Figure 6: objects stored vs. time spent storing for MySQL and Oracle implementations (remote)

Figure 7: objects stored vs. time spent reading for MySQL and Oracle implementations (local)

## 2 Part II - Large Scale Tests

### Introduction

For the Large Scale Tests up to 100 PC's were used as clients for the MySQL server using the MySQL ConditionsDB API. The Online Software infrastructure was used to allow synchronisation of the client processes. Each client runs as a controller for the Online Software that activates a certain process on that client everytime a state transition occurs using RunControl. The type of test and the number of objects to be managed were preconfigured on a database server. On the Load to Configure transition, the test configuration occurs connecting to the database server in order to get its parameters such as the type of test (Store or Read test), database names and number of objects. The configure to Run transition executes the test.

The tests are the same as described in the Intensive Usage chapter. Tests were performed by using different values of objects to be stored and read from the database and different numbers of clients accessing it. Due to implementation limitations, each client stores the objects in one database. At the moment it is not possible for several clients to store the objects on one database at the same time. Although it is possible for all the clients to read the objects from the same database.

Each client gets its start and end time for its test process. The time results presented are the average value of its duration.

### System Setup

* **Client Details:*
* Intel PIII 1GHz dual processor
* Linux 2.4.18-18.7.x.cernsmp

Figure 8: objects stored vs. time spent reading for MySQL and Oracle implementations (remote)

[MISSING_PAGE_FAIL:11]

[MISSING_PAGE_EMPTY:12]

## 3 Conclusions

At the present moment MySQL implementation shows better performance in all tests.

Both implementations show time values that grow linearly with the number of objects stored or retrieved.

On possible factor that will be investigated in the future is the use of more indexed fields in the MySQL implementation. This feature can bring even better results while selecting and reading objects but might have a negative impact on the time spent while storing the data.

Setting up the system for the MySQL implementation seems much simpler and has less hardware requirements. The Oracle DBMS on the other hand has many powerful features and includes many assistants that should help to bring the most benefit from the whole system.

**Large Scale Tests**

The time spent results for the _readDatax_ test with one database per client fixating the number of objects shows a exponential growth in function of the number of clients making it unbearable to support for clients above 100. The clients access should be of more concern on the implementation future development.

For all other combinantions a linear growth is shown.

Appendix A - Installing, setting up and running the MySQL and ORACLE servers, compiling and using the ConditionsDB API on Linux

### Using MySQL

The MySQL source code can be obtained at [http://www.mysql.com](http://www.mysql.com) as well as documentation on how to install and use MySQL. The MySQL_max server should be installed since it includes extended funcionalties. The _mysql_install_db_ script must be invoked in order to create the necessary structure to start MySQL. To protect the MySQL root user with a password, issue the command:

_mysqladmin -u root password \(<\)password\(>\)_

The next step is creating a new user:

_mysql -u root -p mysql Enter password:_

_mysql\(>\)grant all privileges on *.* to \(<\)username\(>\) @ 'localhost' identified by '\(<\)password\(>\)' with grant option;_

_mysql\(>\)grant all privileges on *.* to \(<\)username\(>\) @ "%" identified by '\(<\)password\(>\)' with grant option;_

This will create a very privileged user who can connect to the database server either locally or from remote machines.

To enter in the MySQL command line client environment one can use the following client application:

_mysql -u \(<\)user\(>\) -p \(<\)password\(>\) -h \(<\)hostname\(>\)_

The following command lists all databases inside MySQL:

_mysql\(>\)show databases;_

To use a specific database one can:

_mysql\(>\)use \(<\)database name\(>\);_

To navigate trough the database structure one can use SQL commands like _select * from \(<\)table name\(>\);_

Another usefull command that allows erasing a database:

_mysql\(>\)drop database \(<\)database name\(>\);_

* _Using the ConditionsDB MySQL implementation:_

The abstract interface of the ConditionsDB allows the user code to become almost independent of the implementation. The only modifications are in the init() method that is used to establish a connection to the MySQL server. The input string, in this case, takes the form:

\(condDBmgr->init("<host>:<database\_name>:<user>:<password>")\);

### Using ORACLE

Oracle 9i, Release 2, was used. Due to some dependencies on the specific linux platform, the instalation of Oracle 9i R1 in Suse Linux 8.0 is not trivial. However, once installed, it works correctly together with the ConditionsDB implementation.

The installation problems in Oracle 9i R1 distribution were fixed in R2 release and for this reason this last version was used to perform the tests. The installation under Suse 8.0 follows the standard ORACLE installation procedure but a package released by Suse support on Oracle, _oraru9i.rpm_ had to be installed to set up the correct kernel parameters and several environment variables that are later used by the instalation procedure.

During installation, the following installation options must be made:

* Available Products -\(>\) Oracle 9i Database 9.2.0.1.0
* Installation Type -\(>\) Enterprise Edition
* Database Configuration -\(>\) General Purpose

All this options enable the Partitioning feature that is required for the process of creating the support database structure for ConditionsDB.

To start using a database, the database administrator must perform this some steps. It's necessary to start up and mount the database that will be used. Perform:

\(\mathit{user@machine}>\)_export ORACLE_SID_=\(<\)_database name that will be used\(>\)

\(\mathit{user@machine}>\)_oraenv ORACLE_SID_ = _[database name]? (press Enter or insert database name again)

\(\mathit{user@machine}>\)_sqplus /nolog SQL*Plus\(>\)_connect system as sysdba password: SQL*Plus\(>\)_startup_

For unmounting and shuting down a database, do _shutdown_ instead of _startup_.

In order to use the ConditionsDB implementation with Oracle, a user must be set. This user must have certain privileges. To create a user perform:

\(\mathit{user@machine}>\)_sqplus /nolog SQL*Plus\(>\)_connect system as sysdba SQL*Plus\(>\)_password: SQL*Plus\(>\)_create user \(<\)username\(>\) identified by \(<\)password\(>\); SQL*Plus\(>\)_grant connect to \(<\)username\(>\)_

_SQL*Plus\(>\)_grant ALL PRIVILEGES to \(<\)username\(>\)_

To have access and navigate through all the structure created by ConditionsDB, a SQL*Plus console can be used. Perform:

\(\mathit{user@machine}>\)_sqplus \(<\)user\(>\)/\(<\)password\(>\) @ \(<\)database name\(>\)_

From SQP*Plus console it's possible to navigate through all the tables issuing SQL commands.

Dropping the ConditionsDB is not at the moment a code feature. It must be performed using an external SQL script that uses all the necessary SQL commands to automatically erase all the structure. This script named _dropCondDB.sql_ comes with the Oracle implementation under the path _implementationOracle/sql_. To launch it, perform:

\(\mathit{user@machine}>\)_sqplus \(<\)username\(>\)_/ \(<\)password\(>\)@\(<\)database name\(>\)_

#### SQL*Plus\(>\)start /\(<\)path\(>\)/dropCondDB.sql

The script asks for two values. The first one is the username and the second is the ConditionsDB database name that was passed on the init() method. This operation is irreversible and permanently deletes all the structure and data stored in the ConditionsDB database chosen.

To see the ConditionsDB database names that are already created, perform:

#### SQL*Plus\(>\)select * from condition_dbs;

Another way of dropping the ConditionsDB database is to change the value of the _STATUS_ field for the chosen database from 0 to 1 on the _condition_dbs_ table. This is not the same as erasing the database with the _dropCondDB_ script. Changing this value only makes the implementation rewrite the structure like no one was created. For changing the value, perform:

#### SQL*Plus\(>\)update condition_dbs set status=1 where status=0;

To prepare the server in order to accept connections from clients, it's necessary to start a _listener_. This is a process that runs on the server side and whose function is to listen for incoming client connection requests and manage the traffic to the server. To configure a listener the _Oracle Net Manager_ tool may be used. Launch the tool by issuing _netmgr_. Choose _Oracle Net Configuration -? Local -? Listeners_ and then _Edit -? Create_. Give the _listener_ a name. Press _Add Address_ and in the _Listening Locations_ verify if the default values for _Protocol, Host_ and _Port_ are correct. Under _Database Services_ press _Add Database_ and then modify the values for _Global Database Name, Oracle Home Directory_ and _SID_. Those values will identify the databases available for the remote connections and the _Global Database Name_ must be passed on the SQL*Plus connect command in the client as it was defined. To start the _listener_ perform:

#### oracle@machine\(>\)lsnrctl start

For stopping the _listener_ use _stop_ instead of _start_.

All the actions listed for local server are also valid for the client. Even though it's a client installation, on the _Available Products_ window, the _Oracle 9i Database 9.2.0.1.0_ option must be chosen and not_Oracle 9i Client 9.2.0.1.0_ because this option does not install the all Oracle files that are necessary for the implementation to compile. In _Database Configuration_ window, _Software Only_ option may be chosen since no database is needed on the client. The _listener_ doesn't need to be configured and started since the client don't receive connections for services but a _Net Service Name_ does. This is necessary in order for the client to identify the Oracle service to access on the server. To establish this configuration, the _Oracle Net Configuration Assistant_ tool may be used. Launch the tool by issuing _netca_. On the first window choose _Local Net Service Name Configuration_. Next window choose _Add a Net Service Name_. Next Window choose for which Oracle version it should be. On the next window provide the service name you want to access.

Normally it should be the _Global Database Name_ for the database that will be accessed in the form _database-name.domain_. Next choose the appropriate protocol and finally the hostname of the server and if the standard port 1521 should be used or another. Give the _Net Service Name_ a name and finish the Assistant. This tool writes a _tnsnames.ora_ simple text file under the path stored on _$TNS_ADMIN_ variable (usually _/opt/oracle/product/901/network/admin_ if the default options were used). This file stores all the information given and again can alternatively be modified to our convenience instead of using the _Oracle Net Configuration Assistant_ tool.

The server can then be accessed using SQL*Plus:

_user@machine\(>\)sqplus_\(<\)_username\(>\)/\(<\)password\(>\)@\(<\)Global_ _Database_

_Name\(>\)_

* _Using the ConditionsDB Oracle implementation:_

In the implementation code, the init() method is used in order to establish a connection to the Oracle server. The syntax is the form:

_condDBmgr-\(>\)init("user=\(<\)username\(>\),passwd=\(<\)passwd\(>\),db=\(<\)Oracle_database_name\(>\),con_

The _db_ input string should be the Oracle database name (specified in _$ORACLE_SID_ variable) for the local connection and the _Global Database Name_ for the remote connection. _cond_db_ input string is a general name for the ConditionsDB structure.

[MISSING_PAGE_EMPTY:19]

### 5.1 MySQL

Figure 16: MySQL implementation: local / remote - Intensive Usage - _storeDatax_

### 5.1 MySQL

Figure 17: MySQL implementation: local / remote - Intensive Usage - _readDatax_

[MISSING_PAGE_EMPTY:22]

### 5.2 Oracle

Figure 19: Oracle implementation: local / remote - Intensive Usage - _storeDatax_

### 5.2 Oracle

Figure 20: Oracle implementation: local / remote - Intensive Usage - _readDatax_

## 6 Appendix C - Graphical representation of the results for the Large Scale Tests

## 6 Appendix C - Graphical representation of the results for the 26 Large Scale Tests

Figure 21: Objects stored vs. time spent - fixating the number of controllers

## 6 Appendix C - Graphical representation of the results for the 27 Large Scale Tests

Figure 22: Number of controllers vs. time spent - fixating the number of objects stored

## 6 Appendix C - Graphical representation of the results for the 28 Large Scale Tests

Figure 23: Objects stored vs. time spent - fixating the number of controllers

## 6 Appendix C - Graphical representation of the results for the 29 Large Scale Tests

Figure 24: Number of controllers vs. time spent - fixating the number of objects stored

## 6 Appendix C - Graphical representation of the results for the 30 Large Scale Tests

Figure 25: Objects stored vs. time spent - fixating the number of controllers

## 6 Appendix C - Graphical representation of the results for the 31 Large Scale Tests

Figure 26: Number of controllers vs. time spent - fixating the number of objects stored