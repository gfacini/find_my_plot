ATLAS-SOFT/95-14c

15 January 1996

**DICE-95**

A.Artamonov, A.Dell'Acqua, D.Froidevaux, M.Nessi, P.Nevski, G.Poulard

###### Abstract

A modified DICE framework includes a novel ATLAS geometry description, supported by a preprocessor and a dedicated library. It automates the detector response, simplifies the digitisation coding and provides a data handling mechanism with a build-in documentation and database support.

## 1 Introduction

In 1995, the ATLAS collaboration have to made a number of detector choices on the basis of the detailed detector MC simulation. A fast and reliable way to implement these versions in DICE is to use a dedicated _geant_ parser (Fortran preprocessor) which is supported by a ATLAS-GEANT interface library called _Atlsim_. Maintaining the GEANT specific tables of materials, volumes, hits descriptions, etc and insuring the internal consistency of most of the actual parameters of the GEANT routines, it significantly reduces the amount of information the user should care of and improves the robustness of the program. Here we describe the main rules and features of this program.

## 2 Geometry Description

The geometry of each ATLAS detector in DICE-95 is described in a single module. Modules are written in the _geant_language and translated by the parser into conventional, well commented Fortran subroutines compiled and linked with the rest of DICE. A module consists of the module header, the data definition part and of a number of blocks, each describing one GEANT elementary volume and its content.

### _geant_language

The _geant_language is a Fortran extension oriented to the GEANT application. Apart from standard Fortran statements, it contains a number of _geant_ statements in the form:

\[\mbox{OPERATOR\NAME}\ [\ k\mbox{\it{ keyword}}_{1}\mbox{\it{=value}}\...\ k\mbox{\it{ keyword}}_{n}\mbox{\it{=value}}\ ]\]

where the OPERATOR defines a specific service to be performed by the _Atlsim_ interface. Apart from the declarations and data handling operators, described in sections 2.4 and 2.5, there are 9 GEANT dedicated operators and 3 control operators in the _geant_language. For these operators:

* NAME is the name of a GEANT volume or of a volume shape (4 letters), or a material or medium name (up to 20 letters). A Fortran string variable is generated by the parser by converting the NAME into upper-case letters.
* Keywords (left parts of assignment) are variables used in the GEANT3 manual [1] to describe the parameters of the corresponding GEANT3 routine 1). Footnote 1): Few deviations from this rule where the manual names are ambiguous will be mentioned later
* Their values (right parts of assignment) are any legal Fortran expression. The language is neither case nor position sensitive. A _geant_ statement can be continued on the next line only using a comma or an underscore at the end of a line as a continuation sign. A comma can also be used between keywords to improve the readability. All _geant_ comments mentioned below are mandatory. They should not contain single or double quotas inside. A list of keywords with their values is called below a definition.

### Volume description

#### General structure

Any GEANT volume in a module is described as a block. A block consists of two parts - the description of its own properties and the description of its content - and has the following structure (last column shows the corresponding GEANT3 routine) :

**BLOCK**NAME comment 

BLOCK, ENDBLOCK and CREATE are control operators because they affect the execution order: CREATE is executed as a jump to the requested BLOCK code and the return back when its ENDBLOCK is reached. All other are GEANT dedicated operators and are substituted by a call to one or few GEANT routines via the _Atsim_ interface.

Example 1: Block GAAS is GAArsenid forward tracker Material Air Medium gaas_mother Ifield=1, FieldM=2, TmaxFd=3, Epsilon=0.001, SteMax=0.001 DeMax=0.05 StMin=0.001 Shape TUBE Rmin=10 Rmax=50 dz=200 do idisc = 1,nint(gaag_Idisc) Create GDSi Position GDSi z=gdsi_Zdisc Position GDSi z=gdsi_Zdisc ThetaZ=180 enddo endlock The _Atsim_ interface maintains GEANT tables of materials, mediums, volumes and rotation matrices. After checking that the requested name already exists in the corresponding table or having created a new table entry, the interface provides the entry number to the GEANT routines. The only mandatory operator inside a block is its SHAPE, others can be omitted. In this case the volume properties are inherited from it's mother volume, and position definitions are assumed to be default (x=y=z=0, no rotation). If needed, material, medium and attribute operators should be defined before the SHAPE operator.

#### 2.2.2 More on SHAPE

The name argument of the SHAPE operator contains a name of any of the 16 legal GEANT shapes described in the manual. Keywords in the definition part are the names of parameters, used in the GEANT manual (section GEOM 050) to describe these shapes. The only exception are multiple \(z\), _Rmin_ and _Rmax_ parameters of the PCON and PGON shapes, which should be supplied as vectors named _Zi_, _Rmn_ and _Rmax_, defined in one of the following two forms:

\[\begin{array}{l}vector=\{val_{1},val_{2}...val_{n}\}\\ \text{or}\,vector=\{A(i_{1}:i_{2})\}\end{array}\]

where a _vector_ stands for _Zi_, _Rmn_ or _Rm_, _val_, are any Fortran expressions, and A is a Fortran array. As the parameters are transmitted to the GSVOLU routine via the _Atsim_ interface, they can be provided in any order or be inherited from the mother volume.

Example 2: the PCON specification from the GEANT manual (GEOM 050, figure 23) may look like:

SHAPE PCON phi=180 dphi=279 Nz=4 Zi={-400,-300,300,400}, Rmn={50,50,50,50} Rmx={250,100,100,250} The GEANT divisions are in the _geant_ language particular cases of the SHAPE operator. The actual division mechanism is automatically selected by the _Atsim_ interface dependent on the parameters supplied.

Example 3: this will create divisions of a TUBE in \(\phi\) using GSDVN (GEOM 130):

...

Shape TUBE Rmin=Rj Rmax=Rj+Dr Dz=D/2

Create GDij

...

Block GDij is a sector containing one counter

Shape DIVIsion Iaxis=2 Ndiv=Hdv

Create....

endblock

#### 2.2.3 Inheritance rules

Unless defined explicitly, parameters of the MATERIAL, MIXTURE, MEDIUM, and SHAPE operators in a new block are inherited from the block creating this one. Normally this is also its mother volume2). If no material or medium are defined in a new block at all, the are inherited from the mother block. A MATERIAL or MEDIUM operator without parameters can be used to get parameters of already defined materials (mixtures) or media. If no material or medium are defined in a new block at all, the are inherited from the mother block.

Footnote 2: The exception is done only for the mentioned above vectors \(Zi,Rmn,Rmz\) of the PGON and PCON shapes.

A new GEANT medium, which combines both material and tracking parameters, is introduced not only after a MEDIUM operator re-defines any of the tracking parameters, but also if a material has been changed by a MATERIAL or MIXTURE operators.

A MATERIAL or a MEDIUM operator without parameters can be used to refer to an already defined material (mixture) or medium.

### Volume positioning

Unless defined explicitly, the parameters of a POSITION operators have the default values:

\(z=y=z=0\), KONLY='ONLY, unit rotation matrix.

If the volume being positioned has been defined with all parameters equal to zero, the GSPOSP routine will be called, otherwise the GSPOS is used. In case of the GSPOSP call, the actual parameters of the volume shape supplied in the POSITION operator still follow the inheritance rules for the SHAPE operator.

If a rotation should be defined when positioning a volume, it is possible to define it in two ways:

* Providing up to 6 parameters of the GEANT rotation matrix (GEOM 200). The parameter names
* and their default values defining the unit matrix are
* \(ThetaX=90^{o},PhiX=0^{o},ThetaY=90^{o},PhiY=90^{o},ThetaZ=0^{o},PhiZ=0^{o}\)

Only those parameters which are different from the default unit matrix should be given. Example: ThetaZ=180 in the example 1 in the second POSITION operator makes the second copy of the GDSi volume to be positioned as a mirror reflection of the first one.
* A rotation around one of the \(z,y,z\) axis can be introduced simply by defining one of the following parameters:

\(AlphaX,AlphaY\) or \(AlphaZ\).

Rotation parameters are not inherited from one POSITION operator to another.

### Volume naming mechanism

All volumes in DICE-95 are referenced by their generic names, consisting of 4 upper-case letters4). When the real dimensions of the same generic volume are variable, the supporting _Atisim_ library provides an automatic and transparent mechanism which, for physically different volumes with the same generic name, generates nicknames used by GEANT, by changing last letters of the generic name into numbers or lower-case letters. These volumes with different nicknames are considered as instances of the same generic object. The original generic name is also kept in each instance together with its nickname.

Footnote 4: The ATLAS convention is to have the same first letter for any block within a whole module

The positioning of all volumes is done using their generic names, the latest generated instance of the object been actually used. When positioned in the same mother volume such instances will be made different also by their GEANT _copy numbers_. If a volume instance has been defined with all parameters equal to zero, it will be positioned by the _Atisim_ interface using the GSPOSP routine with the dimensions, defined in the POSITION operator.

This mechanism provides a simple and effective way to automatically generate the unique path to each GEANT volume, needed for the HIT package, without an additional user code.

### Module header

The module header in DICE-95 is used to provide the Fortran declarations as well as the program maintenance information. It consists of the following _geant declarations_ :

\begin{tabular}{|l l|} \hline MODULENAME & comment \\ AUTHOR & author list \\ CREATED & date or version \\ CONTENT & list of GEANT volume used \\ STRUCTURENAME & \{ list of variables \} \\ +CDE,... & list of the KEEPs used. \\ Other Fortran declarations \\ \hline \end{tabular}

Note that:

* The first line should be the MODULE declaration, the order of other statements is irrelevant. The module name consists of a 4-letter ATLAS detector code plus the module type code (GEO, DIG etc). It is also used to identify module input and output data structures (GEANT hits and digits, DETM structure of SLUG etc).
* The format of comment, author list and creation date is arbitrary, but their presence is mandatory.
* The CONTENT declaration should list all blocks used in the module.
* The STRUCTURE declaration groups together real variables or one-dimensional arrays, which are subject to potential change using datacards or should be accessible from external routines, for example at the reconstruction stage. Their usage is described in the next section.

Example:

MODULE GAASGEO is the Geometry of the GAArsenid forward tracker

Author Rene Brun, Pavel Nevski

Created 23 sept 94

Content GAAS, GDSi, GSij, GHij, GDij, GSUB, GASS, GELE, GSUP

Structure GAAG { Version, Idisc, DrCounter, DfCounter, DzCounter,

TCKsubs, TCKsupp, DXele, DYele, Dzele }

Structure GDSi { Disc, RIdisc, R0disc, ZDisc }

Real Zdel,Rj,Zk,Dh

Integer Idisc,j,k,N,ndv

+CDE,A6ECOM,6CONST.

### Data structure handling

A group of logically linked variables, which are declared in a STRUCTURE operator, is defined using the FILL statement:

\begin{tabular}{|l l|} \hline FILL & NAME &! bank comment \\ \(\mathit{variable}_{1}=\mathit{value}_{1}\) &! explanation of variable\({}_{1}\) \\ \(\mathit{\ldots}\) & \(\mathit{variable}_{n}=\mathit{value}_{n}\) &! explanation of variable\({}_{n}\) \\ \hline \end{tabular}

Note that:

* The structure name consists of 4 letters and is used as the ZEBRA bank name and as the prefix of its variables in the Fortran code.
* The order of assignments is irrelevant, but comments and explanations are mandatory.
* Other comment lines cannot interleave with FILL assignements.
* \(\mathit{value}_{i}\) are Fortran expressions in case of a simple _variable_ or a vector in the form \(\{\mathit{val}_{1},\ldots\mathit{val}_{k}\}\) for an array.
* When the FILL statement is executed by the _Adissim_ interface, the data are saved as a bank in the DETM structure [2].
* There may be two levels of data structures (banks) defined and used in a module: the structure name, defined by the first FILL operator, becomes the high level structure name. All structures with other names are considered as lower level structures associated to it.

Each of these structures may be a linear chain of similar banks, created by sequential FILL operators with the same name. They all are considered as instances of the same generic object, so at any moment only one selected copy of each structure is available. A typical usage of the high level structure is to provide different geometry versions of the same detector, the actual version been selected using the datacard input. Instances of the low level structures can be used to provide parameters for different components of the of the same detector.

Example:

 Fill GAAG! geometry description  version = 3! Annecy layout  Idisc = 2! Nr. of discs (on each side)  DrCounter = 5.3! DX (Dr) of a counter  DfCounter = 2.6! DY (Dphi) of a counter  DzCounter =.02! DX (Thickness) of a counter  TCKsubs =.01! Thickness of the substrate  TCKsupp = 0.8! Thickness of the support  Dkele = 3.! DX (Dr) of the electronics board  DTele = 2.! DY (Dphi) of the electronics board  DZele =.06! DX (Thickness) of the electronics board  Fill GDSi! individual disc parameters  Disc = 1! disc number  RIdisc = 20.! inner Radius  RDdisc = 35.! outer Radius  Zdisc = 156.! Position along Z  Fill GDSi! idem for next disc  Disc = 2! second disc  RIdisc = 25.! inner Radius  RDdisc = 40.! outer Radius  ZDisc = 185.5! Position along Z  Example: data structures produced by the previous example:

One can select the actual copy of the structure to be used by the program (an instance of the data structure) with the help of the USE statement :

USE NAME variable = value Any variable from the corresponding structure can be used to select the current instance of the bank. The value may be any Fortran expression. Once the top level bank is selected with the USE operator, the descendent lower level banks are selected only within the same branch. Selected banks are re-linked at the first position of their top level banks, so that they always become default banks for any further selection. Also at that moment their content is changed by the standard datacard input.

Once selected with the USE operator, variables from the data structure can be referenced by the program in the form BankName_Variable. In this way they are easy to recognize among the other program variables (see first example).

This mechanism provides an easy and flexible way of the geometry versioning within each module.

## 3 CREATING GEANT HITS

In DICE-95 user does not need to write a detector specific routine to create GEANT hit structure and to fill it with a useful information. Instead, a _geant_ statements with the HITS operator, called in a block describing a sensitive volume, is used to produce a relevant GEANT hit definitions and to steer their filling at the tracking time. This statement generates all necessary GEANT calls (see GSDET and GSDETH routines, HIT 100) with their parameters as follows:

* The _set name_ is defined by the first 4 letters of the module name;
* The _detector name_ is the name of the _geant_ block ;
* Following the DICE standard, IDTYPE is taken as the ATLAS detector number;
* The _name_ argument of the HITS operator, (hit address) is the name of the volume used to identify the hit, usually the sensitive detector itself. The _Atlsim_ interface finds the path to the selected volume using generic names of all higher level volumes and builds the NAMESV array. It also defines the number of branchings and the number of bits required at all levels (NBITSV array) to uniquely describe the path to each instance of the selected volume;
* For memory allocation defaults values of NHWI, NWDI = 1000 are used. The definition part of the HITS operator contains a list of information quantities, measurements, which should be saved in each GEANT hit, and their packing in one of the form _measurement : \(N_{hit}:(min,max)\)_ or _measurement : bin : \((min,max)\)_ For a _measurement_, \(N_{hit}\) or _bin_ are mandatory and limits are optional. At present the following variables are known as _measurements_ to the _Atlsim_ interface (the track point means here the middle point of the track segment producing the hit):

* local Descartes coordinates of the track point in the sensitive volume;
* local cylindrical (or polar) coordinates of this point;
* local direction cosines of the track segment;
* cosine of the angle between the track segment and the radius pointing to its center;
* closest approach of the track segment to the local z-axis;
* the length of track segment producing the hit;
* the energy lost at this step;
* equivalent energy of the calorimeter response (see PHYS 337);
* time of flight for this hit;
* particle energy in the current point;
* \(log_{10}\) of the particle Lorentz factor;
* pseudorapidity of the track point;
* the hit quantity is calculated in a user function. An integer number, following a _measurement_ variable, is interpreted as \(N_{hit}\)
- the number of bits for packing the variable values. 0 means that the value is a cumulative sum, occupying a full computer word. Due to the GEANT limitation 0 can be used only in last elements of the HITS statement.

If _measurement_ variable is followed by a real expression, it is interpreted as the packing bin size, and the number of bits, required for packing, will be calculated by the _Atlsim_ interface.

If the user does not provide the limits explicitly, _min_ and/or _max_ are determined by the _Atlsim_ interface using the volume dimensions.

Example:

HITS GASS X:12: Y:11: ELOSS:0:

In case of the USER element, a subroutine \(XXXXSTEP(pointer,hit)\), where XXXX is the volume name, will be called to provide the _measurement_. This subroutine should be described as EXTERNAL in the module header. Its integer input argument _pointer_ is the address of the hit description array (10 words, real) in the GEANT memory and it returns in _hit_ the measurement. The format of this description can be found in the Appendix.

This option violates the data encapsulation principle as a user gets a direct access to the GEANT memory. It is not needed at present in DICE-95 and users are discouraged to use it until they are sure they really need it.

## 4 Digitisation

### Detector response description

The detector digitisation, i.e. simulation of the response of individual elements of a given detector after tracking of a compete event, is done in a separate _geant_ module.

A digitisation module has the header and the data handling part similar to a geometry module, but instead of blocks, describing detector geometry, it describes how a specific detector response in each separate element is produced, taken into account multiple hit overlap, noises, thresholds etc.

The content of the digitised information piece, the _digit_, should be described in the detector digitization module using the **DIGI** operator. This operator, similar to the HITS operator, creates necessary banks in the GEANT JSET structure.

DICE-95 creates digits in the _Alsim_ format, which is similar to the format of hits, but different from the ones used for the standard GEANT digits. The difference is summarised below:

* The amount of memory used by the _Altism_ digits in average is twice less then the one consumed by the standard GEANT digits.
* The transformation of the digitized measurements into integer numbers, representing packing bins, is done internally by the corresponding routines in the _Attsim_ library in the similar way as GEANT makes it for hits. When a user reads these digitised measurements back at the reconstruction stage, he gets them in the same coordinate system where they were "measured". This feature free the user from the necessity to transfer the packing constants to the reconstruction routines in a user code and eliminates one of the important source of the reconstruction errors.
* It is possible to introduce cumulative digitisations in the same way as the GEANT cumulative hits. If a non positive number was defined as the number of packing bits for a measurement, its value and the values of subsequent measurements will be summed, provided that the other digit parameters (track number,volume address,non-cumulative measurements) are the same.

### Collecting all hits in a detector element

The _Attsim_ interface contains 4 integer functions (AgFHIT0,AgFHIT1,AgSDIG0,AgSDIG1) which provide the hit access and the digitisation storage service. Their execution and the print verbosity are controlled by the datacards in a way described later. If the operation was successful, the functions return the OK flag (0 value).

To select a hit set to be analysed, a AgFHIT0(Cset,Cdet) function should be called, where Cset and Cdet are 4-letter names of an ATLAS system and its sensitive detector. The function returns OK, if the selected set contains hits and the digitisation of this ATLAS system has been requested by control cards, otherwise the digitisation should be abandoned.

If the address part of the DIGI set coincides with the address of the HIT set (same volume used as their address), this call also defines the output DIGI bank. Otherwise, if the _HITS_ and _DIGI_ detectors are different 5), the AgSDIG0(Cset,Cdet) function should be called.

Footnote 5: This is the case, for example, in the tile calorimeter, where hits are registered and stored per tiles with certain (\(r_{\rm{A}}\)) position, or in the integrated forward calorimeter, which contains tubes arranged in a certain (\(x_{\rm{F}}\)) grid, but where the DIGITs should be stored per \(\Delta\eta\times\Delta\phi\) bins.

After these initialization calls are successfully done, the _Attsim_ interface is ready to provide you sequentially with all hits in each detector element by performing the **AGFHIT1**(IH,ITRA,NUMBV,HITS) function. Here the output arguments are:

* _abs_(IH) will be on output the sequential hit number in the current detector element. A negative 1H is used to signal the last hit in the detector element.
* NUMBV is an integer array, that will contain on output the list of volume copy numbers which identify the path to this detector element.
* HITS is a real array which will contains the measurements belonging to this hit.
* _abs_(ITRA) will be the track number having produced this hit. The negative ITRA is used to signal that other particles also contributed to this detector element.

The function itself returns OK until all hits in the selected set are used.

In this way in the digitization routine the user does not need neither to introduce arrays to accumulate the information from different detector elements in parallel, nor even to know the full number of the detector elements. Moreover, if a user needs to know the space position of a hit, he can simply use the GEANT routine GDTOM to translate a point in the current detector element to the Master Reference System, as the content of the necessary common blocks is restored by the _Attsim_ interface.

Finally, when all hits in one detector element are received, the **AGSDIG1**(ITRA,NUMBV,DIGI) function should be called to store the simulated digitisation. Here the input arguments are:

* ITRA is the number of the track that has produced this digit. A negative ITRA will be stored as zero.
* NUMBV is the address of volume to which this digitisation belongs.
* DIGI is a real array containing the digitised measurements. Below you will find as an example a part of the ATLAS forward calorimeter digitisation routine. It gets energy deposited in a set of tubes with arbitrary geometry and produce the digitisations as the energy sum in a standard \(\eta,\phi\) presentation.

[MISSING_PAGE_FAIL:8]

DTACARD CONTROL

### Program control

Usual flags from the *MODE datacards are used by the _Atlisim_ interface to control the geometry building (GEOM), hii saving in sensitive detector (SIMU), switching on/offothe magnetic field (MFLD), to allow detector digitisation (D1GI) or reconstruction (RECO). The control is done in a transparent way, so a user does not need to analyse this flags himself. The only interesting flag is GEOM, which is used also to select the detector version. This flag is available in a geometry module as %IGEOM variable.

The verbosity of the printout is also controlled by datacards. As the print requirements may be different not only from detector to detector, but also for different _stages_ of the program execution, the actual print level is always produced as a product of the detector print flag, defined in the detector data card:

*MODE 'XXXX' 'PRIN' \(L_{4}\)...

and of the current stage print flag, defined in the _stage_ data card:

*MODE 'YYYY' 'PRIN' \(L_{s}\)...

where XXXX are conventional ATLAS detector system codes and stage codes YYYY can be 'GEOM', 'SIMU', 'DIGI', 'RECO' etc.

### Print control

In general the action of the resulting print level \(L=L_{4}\ast L\), is defined by the following strategy:

- no printout at all (same for L negative);

- minimal printout (not more than once per event);

- still reasonable amount of prints (up to 10 lines per event);

- you can tolerate it for a dozen events;

- 4 and more
- debugging to find a problem.

Some particular cases for different stages are explained below.

#### 6.2.1 GEOM - Geometry building stage

The print level decreases by one each time the program makes a jump into a next level block. So with small L you will get only general detector dimension, and with higher L you will get parameters of smaller detector pieces.

#### 6.2.2 SIMU - Simulation stage

The printout, tracing particles, is done by the GEANT routine GDEBUG. This routines operates under the control of DEBUG and ISWIT data cards (see section BASE 400) and may produce a very abundant printout.

In addition, the _Atlisim_ interface provides a possibility to tracing particles only in selected ATLAS detector systems. A detector *MODE 'XXXX' 'DEBU' 'D data card is used to limit the maximal volume insertion level, where a call to GDEBUG is done. So with D=1 one will get the tracing only the system mother volume, and with higher D from its internal volumes. The total number of volume levels, where the tracing is done, is defined by the detector print level.

#### 6.2.3 Digi - digitisation stage

The detector *MODE 'XXXX' 'DIGI' 'PRIN' 'L data card defines weiher this detector will be digitized (d=1) or not (d=0). At the print level 3 and more, the total number of digitised hits will be printed for each event. If the print level is 4 and more, the output digi set will be dumped. If it is 5 and more, the input hit set is dumped.

### Parameter input

The content of a data structure, defined in any module of DICE95, can be modified by a *DETP datacard. To modify a variable, user has to provide the name of the detector, the name and the value of the "use" selector of the desirable bank, and then names and new values of variables in the selected bank. All modification for the same detector should be done on the same *DETP datacard, which can be continued an several lines following the FFREAD rules.

Example. To modify the "Dx of the electronics board" in the example on page 5 on can use the following datacard:

*DETP 'GAAS' 'GAAG=3.'Dxele=3.1

Note that dots are mandatory, but identificators are case unsensitive.

## 7 Documentation and DATABASE SUPPORT

As it has been already mentioned, when the FILL statement is executed by the _Atlsim_ interface, the data are saved as a bank in the DETM structure [2]. At the same time the _Atlsim_ interface creates the appropriate documentation banks for DZDOC package [3]. For each bank in the DETM structure the documentation banks contain the creation date, authorship information, the variable names and comments as well as the full information on the bank relationship.

All this information is maintained in a RZ-file detm.rz which can be analysed by the DZDOC package. Running its interactive version DZDIDT, users can get the full information on the created banks as well as to print a hardcopy of the current ATLAS input data structure description. As the documentation RZ-file is updated automatically each time the program has been changed, this description is always up-todate.

The work is now in progress to interface the _Atlsim_ library to the HEPDB package [4]. When this option will be implemented, the FILL operator will be able to send the the corresponding records with the bank content to supporting database [5].

It will become possible to get with the USE operator not only versions of banks, defined directly in the module, but also to read them from the ATLAS geometry data base, supported centrally.

**Acknowledgments**

Many people participated in discussions.. Authors want to thank Maxim Potekhin and Serguey Baranov, who were the first "test" users of the _Atlsim_ package, Rob Veenhov and Sasha Vanyashin for many valuable comments on the draft of this paper. We are grateful to Rene Brun, who has initiated the present modification of DICE, and was extremely helpful to find a global view on its development.

## References

* Detector Description and Simulation Tool. CERN Program W5013. Geneva, 1994.
* [2]R.DeWolf, P.Nevski, Geometry saving and user input in SLUG. ATLAS internal note SOFT-NO-001, 13.07.93.
* Bank documentation tools. In ZEBRA, CERN Program Q100/Q101. Geneva, 1993.
* Database Management Package. CERN Program Q180, Geneva, 1993.
* [5]B.Khomenko, Minutes of the Wednesday Software meetings on 18/01/95.