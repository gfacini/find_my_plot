**ATLAS Internal Note**

**DAQ-NO-094**

**22 May 1998**

**The LDAQ in ATLAS DAQ prototype -1**

G.Ambrosini\({}^{\rm b}\), H-P.Beck\({}^{\rm a}\), D.Francis\({}^{\rm b}\), M.Joos\({}^{\rm b}\), GLehmann\({}^{\rm a}\), A.Mailov\({}^{\rm c}\),

L.Mapelli\({}^{\rm b}\), L. Monteiro\({}^{\rm b}\), G. Monacchi\({}^{\rm b}\), M.Niculescu\({}^{\rm b,c}\), K.Nurdan\({}^{\rm d}\), J.Petersen\({}^{\rm b}\), C. Ottavi\({}^{\rm b}\),

R.Spiwoks\({}^{\rm b}\), L.Tremblet\({}^{\rm b}\), G.Unel\({}^{\rm d}\), T.Wildish\({}^{\rm b}\)

a. Laboratory for High Energy Physics, University of Bern, Switzerland.

b. CERN, Geneva, Switzerland.

c. Institute of Atomic Physics, Bucharest, Romania.

d. Bogazici University, Istanbul, Turkey.

NoteNumber : 40

Version : 1.3

Date : 15 September 1997

Reference : [http://atddoc.cern.ch/Atlas/Notes/040/Note040-1.html](http://atddoc.cern.ch/Atlas/Notes/040/Note040-1.html)

## 1 Introduction

### Purpose of the document

This document is part of a set of documents which together form the deliverable of the pre-design phase of the Read-Out crate in the Atlas DAQ prototype -1. This document presents the initial high-level design of the Local DAQ (LDAQ) sub-system, gives a general description of its functional elements and summarises the achievement of the pre-design phase. The pre-design work was based on the Front-End DAQ Discussion Group Summary Document and Work Plan [Ref 1].

### Acronyms, definitions and abbreviations

See [Ref 2]

### Overview of the document

The boundaries and relationship to other Data Flow sub-systems are given in section 1.3. Section 2 presents a logical model of the LDAQ sub-system and identifies its major functional components. Sections 3 to 7 give a description of the pre-design of each of the LDAQ elements. In this document we also highlight those areas which have not been addressed during the pre-design phase and present a list of possible short and longer term improvements.This document should be read in conjunction with the companion summary documents [Ref 3] [Ref 4] and [Ref 5].

### Boundaries

The relationship between the LDAQ sub-system and other Atlas DAQ prototype -1 (sub-) systems is shown in Figure 1. The LDAQ sub-system interfaces with the Back-End system via a network communication interface which described elsewhere [Ref 14]. For reasons of control, error handling and monitoring the LDAQ sub-system interfaces with a DAQ unit subsystem. A DAQ unit is one or more I/O modules (IOMs). The interface between the two sub-systems is defined later in section 2.2 of this document.

Figure 1: The relationship between the LDAQ and other (sub-) systems.

## 2 General description

The Local DAQ (LDAQ) sub-system provides, at the level of a modular Data Flow system (read-out crate, sub-farm or event builder), all the high level DAQ functions which are not related to the main flow of the event data. The LDAQ is also the interface point to the Back-End DAQ system for the run control, the configuration databases, the Message Reporting System and the Information Service [Ref 14].

### Requirements

The LDAQ sub-system must fulfil the following requirements:

* Provide the crate control function to initialise, configure and coordinate the activities of DAQ unit elements. This function shall also provide a mechanism to handle and report errors originating from DAQ unit elements.
* Provide statistical sample of user selectable events to monitoring tasks.
* Allow a crate to operate either in stand alone mode (i.e. disconnected from the rest of the system, and in particular the Back-End functions such as the run control) or in integrated mode (i.e. connected to the rest of the DAQ system, the Back-End in particular).
* Cover the specific requirements of the dataflow building blocks: the Roead-Out crate, the Sub-Farm and the Event Builder.
* Allow to accommodate different hardware solutions both for the processor(s) and for the data and control links.
* Allow to accommodate different operating system solutions, initially LynxOS and Windows NT are considered.
* Allow the flexibility to add more functionality in the future.

### The ROC LDAQ logical model(s)

The logical elements of the LDAQ sub-system, identified on the basis of the functional requirements listed in section 2.1 are:

* The _run control_ function which provides run control within the ROC.
* The _event monitoring_ function which allows for the statistical sampling of event data.
* The _error_ function which performs the error handling and reporting within the ROC
* The _configuration and parameters data base_ used to initialise and configure the ROC elements.
* The _LDAQ communication_ function which allows the LDAQ to exchange information with the IOMs in a uniform way. It includes a protocol for communications and a model to partition LDAQ functions between the LDAQ module and the IOMs.
* The _LDAQ link_, a physical link to integrate the LDAQ into the ROC; this link spans all the modules in the ROC.

In Figure 2: we highlight the elements identified by the LDAQ design as well as how they are split between LDAQ and I/O modules. The _configuration and parameters data base_ elementwill actually be part of the Back-End, nevertheless the contents of and the access to the data base should be influenced by LDAQ requirements.

The definition of the interface between the LDAQ sub-system and the DAQ unit elements should allow for a maximum of flexibility with respect to the LDAQ elements. Because at this stage, no clear consensus has been reached on the way to integrate the LDAQ and the IOMs, we present two options and we leave open the choice. A decision should be taken during the next phases of the project.

#### 2.2.1 The LDAQ Model #1

The LDAQ model #1 (depicted in Fig 3) is based on a message passing system between LDAQ elements: the elements located in the LDAQ and the corresponding ones located on the IOMs. A logical type associated to each message identifies the function to be executed on the IOM side. The reception and the decoding of messages on the IOM side is under the responsibility of the LDAQ. In other words, the functionality of the LDAQ is extended to the IOMs. In this model the interface between the LDAQ and the IOM is a functional Application Programming Interface (API) on the IOM side. Each function of the LDAQ elements, is accessible on the IOM side via a specific function call and a list parameters.

The main advantage of this model is that it allows for a greater flexibility on the LDAQ side. The LDAQ functionality can easily be distributed in the ROC without affecting the IOM design. For example the LDAQ monitoring functionality can be partially moved on the IOM if the input stream of the IOM is handled by an intelligent PMC. Another possibility is to use different communication links and/or protocols for the control and monitoring elements due to their different requirements in terms of amount of data and throughput.

The disadvantage of this model is that the API is complex. One API must be defined per LDAQ element.

Figure 2: LDAQ Elements.

The LDAQ model #2 (depicted in Fig 4) is based on a message passing system between the LDAQ and the IOMs. A logical type associated to each message identifies the function to be executed on the IOM side. The reception and the decoding of messages on the IOM side is under the responsibility of the IOM. In this model the interface between the LDAQ and the IOM is the LDAQ link itself. The API consists of a simple message interface (a kind of send/ receive) on the two sides of the link and the specification the message format exchanged between the LDAQ and the IOMs.

The main advantage of this model is that the API is much simpler.

The disadvantage of this model is that we have lost the flexibility in the distribution of the LDAQ functions within the crate.

Figure 3: The LDAQ model #1.

### The Sub Farm LDAQ

The LDAQ logical model for the Sub-Farm is identical to the one defined for the Read-Out crate. The sub-farm DAQ unit sub-system is composed of one or more SFIs and one or more SFOs. In addition the LDAQ may have to provide the sub-farm supervisor function.

### The Event Builder LDAQ

The EVB system described in [Ref 15] logically connects elements of the Front-End DAQ Read-Out crates (ROBs, L3IF) to elements of the Farm DAQ (SFIs, sub-farm node). One of the requirements of the EVB is that is has to support partitioning [Ref 16]

The _Source_ (_Src_) and _Destination_ (_Dst_) components of the EVB are data flow tasks which physically belong to the front-end DAQ and the farm DAQ respectively. The _Interconnecting Network_ provides the technology specific data transfer and the _Network Manager_ (_NetMgr_) controls and monitors the function of the network. The _Data Flow Manager_ (_DFM_) embodies the EVB protocol.

The EVB system interfaces to the back-end DAQ via the LDAQ subsystem but the mechanism is slightly more complicated than the one used in the Front-End and Farm DAQs. The relationship between the LDAQ and the EVB is described in Figure 5.

* _Source_ (_Src_s) elements of the EVB are controlled by their associated _ROC LDAQs_ which are partition blind. In a partitioned EVB, the _ROC LDAQ_ only need to know its crate id.
* _Destination_ (_Dsts_) elements of the EVB are controlled by their associated _Sub-Farm LDAQs_ which are partition blind. In a partitioned EVB, the _Sub-Farm LDAQ_ only need to know its crate id.
* _DFM_ elements of the EVB is controlled by their associated _EVB LDAQ_ which are partition sensitive. The EVB LDAQ needs to access partition information (list of sources and destinations) and pass it to ist associated DFM. In a partitioned EVB, there is one instance of EVB LDAQ (and its associated DFM) per partition.

Figure 4: The LDAQ model #2* The _NetMgr_ element is a system task started at the initialisation of the system and is independent of the partitioning mechanism. It is therefore not under the direct control the EVB LDAQ.

### Status

A high level design of the LDAQ sub-system has been described in section 2.3. and two logical models have been presented. A prototype implementation based on model #1 of integration (API on the IOM side) is available and is described in a separate document [Ref 5]. The next sections describe the pre-design of each of the LDAQ component as well as the status of implementation and plans for improvements.

When checked against the requirements listed in section 2.1 the current prototype implementation do not address specific functional requirements of the event builder and sub-farm crate components.

## 3 Crate Configuration and Parametrisation

### Purpose and function

At DAQ start-up, the ROC and its elements must be initialised and properly configured. The crate configuration and parametrisation addresses the following items:

1. How to configure the ROC.

2. The description of the crate in terms of its hardware and software elements and how these elements are inter-related.

3. The parameters needed by the crate elements (LDAQ and IOMs).

4. How parameters are retrieved and communicated to crate elements.

-7 -

Figure 5: The relationship between the LDAQ and the Event Builder.

### The crate model

A generic model for the Read-Out crate has been defined prior to the prototyping of a small database partially describing the Read-Out crate. A detailed description of the configuration data base prototype is provided in [Ref 7]. Here we outline the main points.

#### 3.2.1 A general crate model

The physical layout of a read-out crate, in terms of modules (LDAQ, ROB, etc.) and interconnections is depicted in Figure 6:

This includes the following items:

1. The LDAQ module, running at least the control and monitoring applications as well as the LDAQ communications component.
2. The I/O modules running a single application. They are further specialised in terms of _Trigger module_ (TRG), _Level three interface_ (L3IF) and _Read-Out Buffer_ (ROB).
3. The data collection link, with its own communication component, interconnecting ROBs to the L3IF.
4. The TRG link, with its own communication component, interconnecting the TRG to the ROBs and the L3IF.
5. The LDAQ link interconnecting all the modules in the crate.

#### 3.2.2 A simplified model

As a first step, we have chosen a simplified description of the crate in terms of modules, applications and parameters. Physical and logical links have not been modelled explicitly, some of the necessary information (such as addresses) has been associated to the relevant modules.

1. The module. A module models an "hardware" element supporting one of the basic components of the read-out crate: the LDAQ or one of the crate I/O modules. A module is described by a number of attributes such as its name, type and address.
2. The module parameters. The module parameters describe module specific features.

- 8 -

Figure 6: The read-out crate elements.

3. The application. An application models a "software" element of the crate, implementing one of the basic DAQ functions such as the Control, the ROB or the TRG application software. An application is described by a number of attributes such as application name, application address and number of associated parameters.
4. The application parameters. The application parameters describe application specific features.

### Implementation

A small database, based on the OKS package [Ref 8] has been implemented according to the _simplified crate model_ described in section 3.2.2.

The data base schema, described in [Ref 7], allows flexibility to add new parameters as needed. Parameters are described by a pair: the symbolic name identifying the parameter and the value of the parameter. Parameters can be attached to system elements in the database (e.g. a ROB or the software which runs on a ROB).

A data access library (DAL) to traverse the data base according to different criteria (e.g. from the module point of view or from the application software point of view) has been defined and is described in [Ref 7].

Conventions to communicate parameters from the LDAQ to I/O modules have been devised in the context of the integration between LDAQ and Data Flow and are documented in [Ref 5].

### Issues to be addressed

The current prototype implementation is a stop gap solution to support the crate prototype until the solution provided by the Back-End becomes available.

The current prototype design, including both the information held in the data base and the structure of the DAL, ought to be refined, to e.g. also include the requirements of the event builder sub-system, to define the dataflow input to the configuration data base design.

### The LDAQ Communication

### Purpose and function

LDAQ elements (e.g. the crate control) need to communicate with all the other elements in the crate (e.g. a ROB). LDAQ elements (e.g. the monitoring) have to operate on other crate elements (e.g. a ROB) to perform that part of their functionality (e.g. sample an event fragment) which has to be executed remotely. Two issues have therefore to be addressed:

* The definition of a protocol for communication between modules.
* A model to partition LDAQ applications between the LDAQ and IOMs.

### Model definition and main features

The list of requirements which lead to the specification of the LDAQ communication model is detailed in [Ref 6]. Here we outline its characteristics.

* Messages consist of an header part, automatically allocated and managed by the communication package and a data part, allocated and managed by the user of the communication package, which contains the user message.
* We have adopted a very simple "RPC-like" approach to split LDAQ applications between LDAQ and IOMs. The message header contains a special (_type_) field which identifies the function to be executed on the I/O module.
* We have adopted a transaction-like model of communication between an LDAQ application and an IOM application. A transaction consists of sending a message and then waiting to receive the reply.
* The transaction is always initiated by the LDAQ, i.e. the IOM is a "passive" participant to the transaction.
* The transaction is synchronous, i.e. both send and receive are synchronous operations.
* Multicast transactions (1 to N) are also supported by primitive operations.

### Prototype Implementation

We have implemented a prototype of the communication model following the preceding features. It uses VME as the transport medium and has the following characteristics:

* VME shared memory, currently held in the LDAQ module, is used to allocate and store headers and data parts. Pointers to messages are passed between the LDAQ and IOMs.
* Hardware FIFOs are used to signal the occurrence of a new message to an IOM or the LDAQ. The pointer to the corresponding message header is passed in the FIFO.
* To send a reply an I/O module reuses the same header and data part space (shared buffers) of the incoming message.
* On the I/O module side, a message handler receives and dispatches (based on the type field described in section 4.2) incoming messages to the appropriate LDAQ function. Polling of the hardware FIFO device is used to detect an incoming message.
* Message multiplexing on the LDAQ side is achieved by a process which owns the LDAQ FIFO and dispatches incoming messages (i.e. IOM replies) to the appropriate destination (i.e. an LDAQ application). Interrupts, generated by an hardware FIFO, are used to detect occurrence of an incoming message.

On top of the communication protocol two additional services are available.

1. A _probe_ service: a, user selectable, list of IOMs can be defined to be periodically probed. The user is notified when one or more modules fail to reply to the probe request.
2. A _boot_ service: the first message sent to any IOM uses the boot service to initialise the hardware used to communicate over VME.

### Status and plans

The prototype implementation is functionally complete (with respect to the required characteristics outlined in section 4.2).

The current implementation may be improved in a number of areas:

* The current implementation uses the same buffer (WHY???) for send and reply messages. This limitation should be removed.
* The current implementation uses a fixed length message buffer and therefore constrains the applications (control and monitoring). This limitation should be removed.
* The current implementation of multi/broadcast transactions should be improved.
* The portability to other hardware and/or software environments should be improved: 1. The dependence on the RIO II hardware FIFOs should be removed. 1. The VMEbus mapping and access mechanisms must be reviewed when porting from LynxOS to WindowsNT.
* At start-up a service (boot) must be called by the user application to initialise the hardware used to communicate over VMEbus. This initialisation should be promoted to a primitive operation of the communication package.

The possibility of using a unique communication package for both LDAQ and data flow should be assessed.

## 5 The LDAQ link

### Purpose and function

_The LDAQ link_ provides the physical communication path to integrate the LDAQ with the I/O modules. This communication path is required to support two types of communication traffic:

* Control messages: these are typically short (up to few 100's bytes) and low rate (few per second maximum) messages.
* Transfer of monitoring data: these are longer (up to a few KBs) and medium rate (up to say 100Hz) messages.

### Prototype Implementation

For the purpose of the first prototype VME has been chosen as the simplest (and the only practical one) solution to implement the physical link between LDAQ and I/O modules implemented by RTPC/RIOII VME modules running LynxOS. A number of basic libraries are needed to support it:

* VME library: to support both generic VME mapping and a named shared memory abstraction over VME.

* BMA library: to support high performance transfers over VME.
* FIFO library: to support the RTPC/RIOII hardware FIFOs for communication purposes.
* Generic interrupt driver and related library: to handle VME and other system interrupts under LynxOS.

### Status and plans

A number of issues ought to be addressed in the future:

* To study alternative solutions to VMEbus as the intra-crate link used for the LDAQ.
* To study the integration of PC's, running WindowsNT, as processors supporting the LDAQ function. We have acquired an Intel based VME card running WindowsNT, this should be integrated as LDAQ support in the short/medium term. In addition PC's should be taken into account when studying alternatives to VMEbus.

## 6 The LDAQ crate control

### Purpose and function

The purpose of the LDAQ crate control function is to provide:

1. The local _run control_ function to initialise, configure and coordinate the IOMs in the ROC.
2. The _handling and reporting of errors_ occurring in the ROC which may be due to:

* the failure to execute a run control command in which case an action is taken locally by the run control. (e.g the global state of the ROC is changed to the error state)
* a run-time error asynchronously generated by an IOM, in which case the error condition may be forwarded to the Message Reporting System (MRS). [Ref 14]

### Model definition and main features

In the Read-Out crate the control function is split between the LDAQ and the I/O modules but the main elements are located in the LDAQ module (See figure 3). The LDAQ crate control function is composed of the following elements:

* The _Master Crate Controller_ (MCC) reacts to external stimuli originating from other LDAQ functions: the user interface function, the error and probe functions. The MCC sends control commands to the IOMs, receives command acknowledges and notifications of state changes from the IOMs. The MCC handles the communication with the Back-End DAQ system.
* The _error_ function handles and reports the asynchronous reception of run-time errors originating in the IOMs
* The _probe_ function provides the mechanism to periodically test the integrity of the IOMs and notifies the MCC about the failure of an IOM.

The _user interface_ allows an operator to interact with the ROC elements. The user interface communicates with the MCC only and not directly with the IOMs. It inputs user commands, forwards them to the MCC and displays IOM status information received from the MCC.

The MCC, error and probe functions use the _LDAO communication_ (detailed in section 4) to send control commands to the IOMs and to receive back status and/or statistic information from the IOMs.

The LDAQ crate control function interacts with other elements:

* The _conteuration database_ to retrieve the information necessary for the initialisation of the IOMs and the information for the hardware and software configuration of IOMs.
* The _Back-End system_ to exchange control commands, system parameters, error messages and status information.

#### 6.2.1 The master crate controller (MCC)

The MCC is the only component in the ROC which is visible from the Back-End run control. The MCC may be linked to a hierarchy of Back-End run controllers or directly attached to a user interface program when the ROC is operated in stand-alone mode.

Figure 7: The read-out crate control elements.

The global state of the ROC and by consequence the state of all its slave IOM elements is maintained by the MCC, which is driven by the execution of a finite state machine (FSM). This FSM controls the IOM activities in the ROC by:

* communicating with IOMs.
* handling a list of pre-defined states.
* accepting control commands while in a specific state.
* starting the remote execution of these commands (actions) in the IOMs.

State changes are the result of one of the following events:

* The successful execution of a control command sent by the FSM to all IOMs.
* the asynchronous notification of an error condition raised by an I/O module.
* the probing mechanism reporting the failure of an I/O module.

A description of the LDAQ run control state transition diagram as well as a the definition of the global ROC states, the control commands and their associated parameter list can be found in document [Ref 9]

#### 6.2.2 The user interface function

The LDAQ Master Crate Controller communicates with a simple user interface (GUI based and/or command line oriented) application over a client/server network connection. This application, the network client, is capable of:

* taking user input commands and sending them to the LDAQ MCC.
* receiving and displaying status information about the ROC elements.
* receiving and logging error messages.

#### 6.2.3 The error and probe functions

It is the responsibility of the LDAQ control to handle and report errors which are arising in the I/O modules of the Read-Out crate.

The I/O module _error_ reporting function may be viewed as the completion of a long outstanding transaction initiated by the LDAQ. The information reported by the error function to the MCC consists of the identification of the faulty IOM, the name of the executing thread in that IOM and a specific error code.

The I/O module _probe_ mechanism may be viewed as an endless loop of test transactions between the LDAQ and all the IOMs. When a transaction times out the probe function informs the MCC and returns the name of the faulty IOM.

A detailed description of the error mechanism can be found in document [Ref 10]. A detailed description of the probe mechanism can be found in document [Ref 6].

### Status and plan

A prototype of the crate control function has been implemented based on the model defined in section 4.2. This prototype is functional and is further described in document [Ref 9]. This implementation could nevertheless be improved in a number areas:

* The current implementation does not provide a way to check that the DAQ is alive. A mechanism to retrieve and display statistic information about the IOMs (e.g. number of events collected) must be fully implemented.
* In the current implementation the start-up and shutdown of the ROC applications is done by executing a remote shell script prior to starting the run control. These operations should be initiated from the run control application in the future.
* In the current implementation, whenever an error occurs, the LDAQ MCC enters a single error state and the only possibility to recover from this error state is to reinitialise the whole system. A mechanism to classify errors (warning, recoverable, fatal) and handle them (define a specific state transition) must be specified. Error handling will be further developed in the detail design phase of the LDAQ control.
* The current implementation of the LDAQ control allows the ROC to be operated standalone via a simple user interface GUI application. To allow the LDAQ run controller to operate in 'global' mode (linked to a hierarchy of Back-End controllers) as well as in'stand-alone' mode a suitable protocol between the LDAQ control and the Back-End must be specified. This includes all the information that needs to be exchanged between the LDAQ control and the Back-End to ensure the correct functioning of the sub-system.

## 7 The LDAQ event monitoring

### Purpose and basic principles

The purpose of the LDAQ monitoring is to provide a sample of events (ROB fragment, crate fragment, full event) to user monitoring tasks.

The event monitoring prototype has been designed according to the following basic principles:

* Allow for statistical sampling, not for sample all.
* Decouple the event data collection from the event data distribution to monitoring tasks.
* Maintain a pool of events on the LDAQ side to store a continuously updated, snapshot of the event data flowing through the crate.

### Model description

In the Read-Out crate the monitoring function is split between the LDAQ and the I/O modules. User monitoring tasks interact only with the LDAQ monitoring system and not directly with the I/O modules. The LDAQ event monitoring system is composed of the following elements:* The _gathering_ function collects events from the IOMs (ROBs, L3IF and TRG) and stores them in the 'data base'. The gathering uses the _LDAO communication_ (detailed in section 4) to send initialisation and data request commands to the IOMs and to receive back status and events from the IOMs.
* The _distribution_ function handles the request for and the distribution of data. It interacts with the user monitoring tasks and with the database sub-system.
* The _database_ function separates the gathering of event data from the distribution and therefore minimizes the interference with the Main Data Flow. The database organises the events collected by the gathering in such a way that the requests coming from the monitoring tasks can be treated as efficiently as possible. The database provides an updated mirror of the'real' data flowing through the DAQ system.
* The _user monitoring tasks_ which provides the user with functions to specify the type of events to be monitored and functions to request and retrieve events of a specific type.

The LDAQ monitoring system interacts with other elements:

* The _configuration database_ used to retrieve hardware (e.g physical addresses of I/O modules) and software (e.g application specific parameters) information necessary to initialise and to configure the IOMs, as well as to organize the gathering operation.
* The _Back-End system_ used to exchange system parameters, error messages and status information.

Full details on the event monitoring on the LDAQ side can be found in document [Ref 11]. Full details on the event monitoring on the IOM side can be found in document [Ref 12]

[MISSING_PAGE_EMPTY:17]

* write the obtained event into the data base.
* control the size of the database.
* update the database: events which are too old (meaningless for the statistical analysis) are removed from the data base.

#### 7.2.2 The distribution

Every time a new request arrives from monitoring tasks, the distribution task is responsible for request management operations as well as the distribution operation.

As explained in 7.2.1, the distribution task informs the gathering task about the event type associated to the new request. This interaction guarantees that the query operation to the database will always succeed: even if the requested event is not in the database yet, it will be quickly, since its collection has been launched.

#### 7.2.3 The database

The database is used to:

* separate the gathering from the distribution tasks, to minimize the interaction with the Main Data Flow.
* organise the events, in such a way that the requests coming from the monitoring tasks can be treated as fast as possible.
* provide an updated mirror of the'real' data flowing through the DAQ system.
* give a chronological order to the events.

### Status and Plans

The gathering, the distribution and the database components have been implemented and tested separately and their integration into the LDAQ sub-system has started. A number of short term improvements have been specified:

* In the current implementation, the database uses the Rogue Wave Tools library for persistent object. An implementation based on the OKS in package should be studied.
* In the current implementation, the distribution task, communicates with the user monitoring tasks via the ILU system [Ref 13] and is limited by the Ethernet throughput. More performant solutions should be considered for the communication with the monitoring tasks and for the event transfer.
* In the current implementation, no error handling is performed. A mechanism for the handling of monitoring errors must be specified and implemented.
* The interaction with the Back-End system must be fully specified and implemented.
* The possibility to control the user monitoring tasks from the run control must be investigated.

**References**

[1]F/E DAQ Discussion Group Summary Document and Work Plan, [http://atddoc.cern.ch/Atlas/FrontEnd/document/draft.ps](http://atddoc.cern.ch/Atlas/FrontEnd/document/draft.ps)

[2]Acronyms, definitions and abbreviations in Atlas DAQ prototype-1

[3]The generic I/O Module in Atlas DAQ prototype-1

[4]The main data flow in the Read-Out crate of Atlas DAQ prototype-1

[5]Integration of the LDAQ and IOM in the Read-Out crate of Atlas DAQ prototype-1

[6]Technical note on LDAQ communication system

[7]Technical Note on Configuration Database

[8]Technical Note on OKS

[9]Technical Note on Run Control

[10]Technical Note on Errors

[11]Technical Note on Monitoring

[12]Technical Note on IOM monitoring

[13]Technical Note on ILU

[14]Back-End documentation

[15]A logical model for Event Building

[16]Note on partitioning - In preparation