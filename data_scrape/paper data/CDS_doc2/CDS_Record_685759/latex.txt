[MISSING_PAGE_FAIL:1]

5.2 BasicGRoBuilder, GRoBuilder.20

5.3 BasicGT1Generator, GT1Generator.21

5.4 BasicLoRBuilder, LRoBuilder.21

5.5 BasicLT1Generator, LT1Generator.22

6.0 The Level 2 Modules.22

6.1 BasicDAQSwitch, DAQSwitch.24

6.2 BasicGT2Processor, GT2Processor.24

6.3 BasicLT2Processor, LT2Processor.24

6.4 BasicT2Buffer, T2Buffer.25

6.5 BasicT2Supervisor, T2Supervisor.26

7.0 The Level 3 Modules.27

7.1 BasicT3Processor, T3Processor.28

7.2 BasicT3Supervisor, T3Supervisor.28

8.0 Switching Code.28

9.0 The Process Modules.29

9.1 OSObject.29

9.2 The Processes.29

9.2.1 AmalgamateProcess.30

9.2.2 BroadcastProcess.30

9.2.3 DecisionProcess.31

9.2.4 DisposeProcess.31

9.2.5 ExtractProcess.31

9.2.6 InputProcess.31

9.2.7 OutputProcess.32

9.2.8 T2BufferStoreProcess.32

9.2.9 WindowExtractProcess.32

9.3 HardwareObject.33

10.0 The Data Structures.33

10.1 Raw Data.33

10.2 Control Data.34

10.3 Features.35

10.4 Trigger Data.35

11.0 MODSIM II Histogramming Package for use with ATLAS Trigger/DAQ-Simulations35

11.1 Which files to get and from where to get them.35

11.2 How to integrate with existing code.36

11.3 How to adapt behaviour by editing the setup-file.40

11.4 Known flaws in this version.41

12.0 The Configuration Files.42

12.1 The #define Section.43

12.1.1 Section 1.43

12.1.2 Section 2.43

12.2 Object Definition.43

12.3 Configuration Extensions.44

12.3.1 BasicDAQObject.44

12.3.2 ATMPTor.44

[MISSING_PAGE_EMPTY:3]

Next create a link in the SIMDAQ directory to point to your local version of MODSIM II [12]. This is done using:

{1}% ln -s /data/appl/modsim1.9.8 modsim

Here /data/appl/modsim1.9.8 should be the path to the directory below MODSIM's bin, of your local version. So for example:

{1}% cd /data/appl/modsim1.9.8

{2}% ls

drwxcr-xr-x 5 root 512 Jul 19 09:57.

drwxcr-xr-x 5 root 512 Jul 19 09:57..

drwxcr-xr-x 5 root 512 Jul 19 09:57 bin

drwxcr-xr-x 5 root 512 Jul 19 09:57 lib

drwxcr-xr-x 5 root 512 Jul 19 09:57 man

Now use the script file _compile_ to compile SIMDAQ, pressing <space> and 'q' when asked.

SIMDAQ is now ready to run with the command:

{1}% simdaq atlasATM622.conf

### SIMDAQ, Architecture Modelling

The second level trigger is an area of Atlas data acquisition where progress in commercial high speed processors and high performance switching systems has a major impact.

It is not feasible to study the second level trigger at full Atlas scale and speed in the laboratory. Modelling can take the results of small scale laboratory tests and map these to an Atlas scale.

SIMDAQ has been developed, following a proposal [4] in the ATLAS group, as a tool to model these systems. SIMDAQ has been implemented using the object orientated programming language MODSIM II [12].

SIMDAQ incorporates current design ideas and technologies with the ability to add new technologies as they become available. It can also be used to model proposed technologies, for example ATM, which are planned for the near future. However, it should be emphasised that an essential part of the system is "generic" switches with precisely defined and understood properties.

### Detector Modelling

There is much work being done in the area of detector design and modelling for Atlas. SIMDAQ can take current detector models and map these to the data acquisition model.

These detector models can easily be updated as designs change.

Ref. [7] details the current stage of detector designs for Atlas, with the relevant mappings to the second level trigger system.

For each detector the geometry and segmentation of the readout electronics, the number and capacity of I/O links for data transmission, the size of derandomizing buffers, the number and size (in bytes) of the readout channels (both full granularity and T2 resolution) and a possible reduction factor due to compression or zero-suppression can be modelled.

### Input from Physics Simulations

There is also a lot of work being done in the area of simulating physics performance [8] of detectors and trigger algorithms.

These simulations use GEANT [10] to produce readable data files in a portable text format [11] of the output of the detectors for events which have passed the level 1 trigger.

SIMDAQ can take these files and map them to the detector layouts to give realistic statistics for the input to the modelling simulation, including correlated data. These files also provide level 1 RoI information, which is essential to guide the level 2 system at high luminosities.

### Processing Algorithms and Speeds

Crucial parameters in the simulations are the processing times for the local processors in each subdetector, and global decision timings. These are data dependant and the estimates used are based on Ref. [9].

### Modsim Ii

MODSIM II [12] is a commercial object-orientated simulation language. It incorporates object-orientated methodologies with a powerful discrete event simulator.

_Objects_ can be built which represent the data acquisition components of the second level trigger. _Methods_ can also be built to allow these objects to interact with each other. Many of these objects can be linked in configurations to model the full Atlas data acquisition system. Statistics, page 35, can be accumulated on various variables of these objects during the simulation run.

### Goals of Modelling

The aims of modelling the Atlas data acquisition are to study the effect of various factors on the design of the DAQ systems at Atlas scale. These factors include:

* The topology of the interconnections.
* The bandwidth and latency of the I/O systems.

* The size of memories.
* The capacity of CPU's.
* The number of CPU's.
* The timings of trigger algorithm execution.

SIMDAQ will help study the influence of these factors on the DAQ system, and also analyse the performance of technologies, including different switching models, and level 2 models, e.g. the farm based model [3].

### How to run SIMDAQ with you desired configuration

SIMDAQ models architectures which are described in configuration files, with a.conf extension. The Configuration Files on page 42 describe these files.

### Setting a Configuration

There are two programs available in the SIMDAQ/configure directory to produce these configuration files. These are _Partition_ and _Configure_.

#### 3.1.1 Partition

The _Partition_ program is used to configure local partitions. These partitions represent part or all of a subdetector. The _Partition_ program produces configurations with the structure shown in Fig. 1.

The _Partition_ program is called using:

{l}% Partition { +option value }

The options are as follows:

* +extractSigma time: This will set the standard deviation for the time for feature extraction. The time is drawn from a normal distribution. The time must be specified in nano seconds. An example of this option is:

+extractSigma 200000
* +extractTime time: This will set the average feature extraction time for the local processors in the partition. If one is not specified, then 900 micro seconds is used. The time must be specified in nano seconds. An example of this option is:

Figure 1: The structure of a configuration using _Partition_+extractTime 700000
* +fastrun: This is whether the partition is using the fast run mode (which sends data only to the buffers hit by an ROI). If not specified then fastrun is not active. An example of this option is: +fastrun
* +help, -help: These will give information on the usage of the _Partition_ program. An example of this option is: +help
* +pfile targetFile: This is the file that the configuration will be saved as. If one is not specified, the default 'file' is used. An example of this option is: +pfile atlasEMC
* +pid partitionId: The partition identifier. This is used to uniquely identify the ports connecting the partition to the global system. If one is not specified, the default P1 is used. An example of this option is: +pid EMC
* +plcoproc numberOfProcessors: The number of local processors in the partition. There is no default number of local processors. If not specified, the _Partition_ program halts. An example of this option is: +plcoproc 50
* +pname partitionName: The partition name. This is used by the simdaq preprocessor include program. If one is not specified, the default PARTITION1 is used. An example of this option is: +pname EMCALO
* +psubdet subDetector: The name of the subdetector. The subdetector can be one of; EMCalorimeter, HACalorimeter, SiT, TRT or MuonSystem. If one is not specified, the default EMCalorimeter is used. An example of this option is: +psubdet EMCalorimeter
* +pswitch switchType: The type of the local switch within the partition. The switch can be one of; ATMalcatel155, ATMalcatel622, ATMFore, ATTATMFabric, SCISwitch or Generic. If one is not specified, then the default Generic is used. An example of this option is: +pswitch ATMalcatel155
* +segment etaMin to etaMax phiMin to phiMax numberEtaBuffers by numberPhiBuffers: This is used to define the T2 Buffer layout of a segment of the sub detector. Use it several times to define the whole sub detector. The labels PI and 2PI can be used in the phi description. There are no default segments. An example of this option is: +segment -3 to 3 0 to 2PI 10 by 10Note that the partition name, partition identifier and the subdetector should all be different.

An example of the use of the _Partition_ program follows ( represents continuation of a line):

{1}% Partition +pname EMCalo\  +psubdet EMC calorimeter\  +pid EMC\  +pfile atlasSmallEMC\  +segment -3 to 3 0 to 2PI 5 by 5\  +plocproc 10

This will produce a partition of the EMCalorimeter with 5 by 5 ( = 25 ) T2 buffers, covering the eta range -3 to 3 and the phi range 0 to 2pi, with 10 local processors. The partition will be saved in the file atlasSmallEMC.conf. Notice that the fastrun option has not been specified, and also that the local switch is not defined. When a switch is undefined the Generic switch is used.

Another example of the _Partition_ program is ( represents the continuation of a line):

{1}% Partition +pname EMCALO\  +psubdet EMC calorimeter\  +pid EMC\  +pfile atlasEMC\  +pswitch ATMALcatell55\  +plocproc 128\  +segment -3 to -1.4 0 to 2PI 2 by 64\  +segment -1.4 to 1.4 0 to 2PI 4 by 64\  +segment 1.4 to 3 0 to 2PI 2 by 64\  +fastrun

This will produce a design of the EMCalorimeter partition of ATLAS. Notice that the switch is defined as an ATMALcatel155 fabric, and that the Eta segmentation is split into 3 sections, -3 to -1.4, -1.4 to 1.4 and 1.4 to 3. The partition also has it's fastrun option set.

#### 3.1.2 Configure

The _Configure_ program is used to define the global configuration. It can be used to specify global parameters and also to include partitions defined with the _Partition_ program.

The _Configure_ program produces configurations with the structure shown in Fig. 2.

It is called using:

_Configure_ { +option value. }

The options are as follows:

* +addpartition pfileName: This will add the partition which has been specified with the pfileName. This option can be used several times to add several partitions. There is no default. If no partitions are added, then the _Configure_ program halts. An example of this option is: +addpartition atlasEMC
* +datafile file: This will set the physics data file that the simulation will use. The data file should be in the SIMDAQ directory. An example of this option is: +datafile tdump_I28324.data

Figure 2: The structure of a configuration using _Configure_* +dumpTime time: This is the time for the histograms and ATM switch (if used) to dump their statistics. The time should be specified in nano seconds. An example of this option is: +dumpTime 20000000
* +extension filePart: This is the file name extension to use for the physics data when it has been randomized. If you run two simulations from the same directory at the same time, then you will need to specify different extensions (as well as different histogram target directories.) An example of this option is: +extension gen
* +file targetFile: The target file for the global part of the configuration. If one is not specified, then the default 'atlas' is used. An example of this option is: +file atlas
* +globalSigma time: This sets the standard deviation for the global decision time of the global T2 processors. The decision time is drawn from a normal distribution. The time should be specified in nano seconds. An example of this option is: +globalSigma 10000
* +globalTime time: This sets the average global decision time for the global T2 processors. It should be specified in nano seconds. If on is not specified then the default 200us is used. An example of this option is: +globalTime 500000
* +globproc numberOfProcessors: The number of global processors. There is no default for this option, and if not specified _Configure_ will halt. An example of this option is: +globproc 25
* +help, -help: These gives information on the usage of the _Configure_ program. An example of this option is: +help
* +histolInterval time: This will set the time between printing output from the histograms. Times should be in nano seconds, and should be factors of 1 milli second. The number of milliseconds will be included in the histogram file name, eg for 1 milli second ".1." will be in the filename. An example, of 1 milli second, of this option is: +histolInterval 1000000
* +resetTime time: This will set the reset time for the histograms in the simulation. Reset time must be specified in nanoseconds. An example of this option is: +resetTime 10000
* +simtime time: This will set the simulation time for the run. It must be specified in nanoseconds. An example of this option is: +simtime 1000000* +switch switchType: The type of switch to use as the global switch. The global switch can be one of; ATMAIcate1155, ATMAIcate1622, ATMFore, ATTATMFabric, SCIS-witch or Generic. If one is not specified then the default Generic is used. An example of this option is: +switch ATTATMFabric Note that the partition file must be in the directory, as the _Configure_ program accesses the first line of this file to read the parameters of the partition. The following command produces a global configuration with 20 global processors with the filename atlas1.conf. The configuration includes a partition and a generic global switch (\ represents the continuation of a line): (1)% configure +globproc 20\  +switch Generic\  +file atlas\  +addpartition atlas1 An example of a multi-partition configuration with an ATTATMFabric as the global switch follows (\ represents the continuation of a line): (1)% configure +globproc 20\  +file atlas\  +switch ATTATMFabric\  +addpartition atlasEMC\  +addpartition atlasHAC This includes two partitions, from the files atlasEMC.conf and atlasHAC.conf.

#### 3.1.3 Configure scripts

Sets of calls to Partition and Configure can be grouped together in a script file, to produce a complete system. Some examples are provided in the SIMDAQ release. An executable script file _maker_ is located in the SIMDAQ/configure directory and can be edited to change configurations. The configuration specified in this file can be produced by typing (1)% maker This will produce the.conf files in the configure directory. The files _am155Make_, _am622Make_ and _sciMake_ are also provided. These produce the configuration files for several of the ATLAS sub detectors as currently envisioned.

### Using the configuration files

To run SIMDAQ with the configuration files you have produced, copy the *.conf files to the SIMDAQ directory. Then type

{1}% simdaq main.confHere main.conf is the name of your global configuration file.

### Graphical Interface

A graphical interface for configuration is hoped to be produced soon.

### The Support Modules

This section details the support modules which do not make up part of either the level 1 model or the level 2 model. The modules in this section are; BasicDAQObject, BasicDAQPort, Constants, DAQBuffer, DAQMod, DAQPartition, DAQSystem, Message and ThrottleObject.

### BasicDAQObject

BasicDAQObject is the base class for all of the DAQ objects, such as ports and processors. Objects are set up in a heirarchical tree, with owned objets belonging to the child queue of owning objects. Parent is used to point back up the tree. Each object has a unique class and serial number.

The fields of BasicDAQObject are:

* ClassId : The type of DAQ object.
* SerialNo : The serial number within the class.
* RootSystem : The DAQSystem which contains everything.
* Parent : The owner of this object.

Figure 3: Inheritence tree of the support objects

* ChildQueue : A list of the objects owned by this object. The methods of BasicDAQObject are:
* ConvertPortNo : Given a class and a serial number, this will return the identified port if it is a child of this object.
* DumpStatus : Writes out status information about the object.
* FindObjects : Returns a list of all the objects of the class given, from the object with the ancestor class given and downwards in this branch.
* Initialise : Initialises the object.
* MakeObjectTable : Does as FindObjects, but returns a table of the objects rather than a list.
* ObjInit : Standard initialise.
* ObjTerminate : Standard terminate.
* PrintConfiguration : Prints out configuration information on the object.
* ProcessConfExtensions : Deals with any extra configuration options read in from the configuration file.
* ReadConfiguration : Reads the basic configuration details.
* SetLogicalPort : Sets the logical port given to the port in the child queue with the class and serial number specified.
* SetParentChildRelation : Test purposes, do not use.
* SetRootSystem : Sets the pointer to the root DAQ system.
* StartObject : Starts the object, and all children, for the simulation run.
* gamePartition : Returns the DAQ partition the object is in.
* MessageArrived : Handles arriving messages.
* Start : Start method for simulation run.

### BasicDAQPort

BasicDAQPorts are used by DAQ objects in the simulation to pass data out on a link to a switch or another DAQ object. There are several different types of port, but all inherit from this BasicDAQPort.

The extra fields of BasicDAQPort are:

* PortNo : The port identification number.
* FarPortNo : Used to identify the far port.
* FarClassId : Used to identify the far port.
* FarPort : The BasicDAQPort this port is connected to.

* IODirection : Port communication direction.
* Key : An additional port identification.
* PortBusy : A resource to manage the ports communications.

The extra methods of BasicDAQPort are:
* SendMessage : Sends a message to the destination port.

The overridden methods of BasicDAQPort are:

* ConvertPortNo : If this object is identified by the class and serial number, then it returns itself.
* Initialise : Initialises the port.
* ObjInit : Standard initialise.
* ProcessConfExtensions : Deals with port specific configuration extensions read from the configuration file.
* MessageArrived : Handles incoming messages.

### Constants

There are some constans defined in the module Constants. These are time constants;

nano, micro, milli, second; size constants; byte, kilo, mega and pi.

### DAQBuffer

DAQBuffer is used to store event data. It is a queue and resource object to store and control the number of data's that it can contain.

The fields of DAQBuffer are:

* ClassId : The tye of object.
* DataBuffer : Queue to store the data.
* BufferManager : To test buffer full and wait for space.
* BufferFilled : To test buffer filled and wait for event
* Threshold : For throttling.
* Throttle : Throttle?

The methods of DAQBuffer are:

* Add : Adds data to the buffer.
* Create : Creates buffer with number of slots as specified.
* ObjInit : Standard initialise.
* ObjTerminate : Standard terminate.

ReadDestructively : Reads a data item from the buffer and removes it from the buffer.
* ReadDestructivelyThis : Reads a specified item from the buffer and removes ot from the buffer.
* ReadSpecial : Reads a data item from the buffer but does not remove it from the buffer?
* SetThreshold : Sets the level to threshold at, as well as the throttle object to use for throttling.

It has access functions, Add which adds, ReadDestructively which will read and remove the data, and ReadSpecial which will read but not remove the data.

### DAQMod

DAQMod is used to hold all of the Class constants for the DAQ objects, such as GT1GENERATOR. It also contains the QueueAndTriggerObj definition and several procedures.

### DAQPartition

The DAQPartition of a DAQ and trigger system represents a sub detector of the DAQ system. It contains information on the sub detector it represents, number of events in the sub detector, and histogramming information on this number of events.

The extra fields of DAQPartition are:

* events : Number of events in the buffers.
* histogram : Histogram of the number of events in the buffer.
* fastRun : Whether to only send RoI information to the buffers, to make the simulation run at a faster rate.

The extra methods of DAQPartition are:

* setSubDetector : Sets the sub detector from an enumeration.
* AddEventToBuffers : Increments the number of events and updates the histogram.
* RemoveEventFromBuffers : Decrements the number of events and updates the histogram.

It has a field, subDetector, which is the partitions subdetector. It has a method to set this subdetector, which can be done from the configuration file.

### DAQSystem

The DAQSystem is the overall system containing all of the DAQ objects. It keeps a histogram on the lifetime of the events passing through, as well as the overall histogram manager. It has arrays of ports to facilitate quick linking during set up. It also holds the basic data on how long the simulation should last and when to output statistics, as well as the method to output these statistics. It also contains the random objects to use to produce the local and global processing timings.

The extra fields of DAQSystem are:

* basicPortArray, atmPortArray, sciPortArray, fastPortArray, c40PortArray : These arrays of ports of various types are used at set up time to return a port of a given class and serial number, rather than doing a slow exhaustive search of all of the ports in the system.
* numberOfPartitions : Number of partitions in the system.
* lifetimeHistogram : Histogram of lifetime of events passing through system.
* extractRandom : Random generator for FEX timing.
* decisionRandom : Random generator for decision timing.
* SampleObjects : Stack holding one example of each type of object.
* StopTime : End of simulation time.
* ResetTime : Reset statistics of histogram time.
* DumpTime : Time to dump statistics from histograms.
* ClockTick : Value of onbe simulation clock tick in secs.
* ClockFreq : reciprocal of ClockTick.
* T1Throttle : A throttling object?
* DebugLevel : Level of debugging information in the run.
* histogramManager : Manages all of the histogram in the system.

The extra methods of DAQSystem are:

* IncludeObject : Includes theobject specified as a sample object.
* StartTimer : Starts a timer to output the simulation time every now and again.
* ResetHistograms : Resets all of the statistics of all the histograms managed by the histogram manager.
* SetPortArray : Given a class and a serial number, will set the appropriate entry in the appropriate array to the port specified.

It also has the debug level, which is used to control the amount of debug information that is provided at run time. It also has a histogram manager, which controls all of the histograms in the system.

### Message

Message's are used in the DAQ system to send data from one object to another, possible via a switch. Messages contain the source and the destination of the message, along with the size in bytes of the message and the queue of data items which is the actual message. It also contains methods to set these fields, add data to the message and query the number of data items held.

The fields of Message are:

* DataSize : The size of the data in bytes.
* source : The original source of the message.
* target : The final destination of the message.
* theData : Sequence of the data items.

The methods of Message are:

* setSource : Sets the source of the message.
* setTarget : Sets the destination of the message.
* addData : Adds a data item to the data contained in the message.
* numberOfDataItems : Returns the number of data items contained in the message.
* numberOfDataItemsOfType : Returns the number of data items of a specified type contained in a message.
* setDataQueue : Sets the data queue, data contained in the message, to the one specified.
* dump : Outputs information on the message.
* ObjTerminate : Standard terminate.

They have a source object, a target (destination) object and a list of theData. theData contains all of the data being transmitted.

It has several functions to set and query these fields.

### 4.9 ThrottleObject

ThrottleObject. More details needed.

The fields of ThrottleObject are:

* Counter
* Throttled

The methods of Throttle Object are:

* UpdateCounter

### The Level 1 Modules

This section details the modules which are used to produce a fake level 1 system. The modules in the level 1 system are provided to allow delays of data from an event to the T2 buffers. The delays for the regions of interest can also be modelled seperately. Currently no delay is implemented.

The level 1 system takes the form of Figure 1. The modules that are included in this section are: (Basic)FEBuffer, (Basic)GRoIBuilder, (Basic)GT1Generator, (Basic)LRoIBuilder, (Basic)LT1Generator.

Figure 4: Inheritence tree of the level 2 objects

Figure 5: The structure of the level 1 systemThe modules are split into Basic and generic modules. Basic modules have the word Basic in their name. Basic modules should provide the methods and fields common to the class, whereas the generic modules provide a complete implementation.

All generic objects below inherit from their Basic object.

### BasicFEBuffer, FEBuffer

The FEBuffer is a rate equalizing buffer between detector and T2 buffers. Data is held here during the level 1 decision, and is sent on to the t2 buffers when the level 1 decision arrives.

The fields of (Basic)FEBuffer are:

DataBuffer: Holds raw event data from detectors.

The methods of (Basic)FEBuffer are:

ObjInit : Standard initialise.

DumpStatus : Output status information.

Start : Starts the object for the simulation.

MessageArrived : Handles incoming messages.

When a message arrives at the FEBuffer, it puts it into a DataBuffer which is DAQBuffer.

A separate method checks this DataBuffer, and if there is anything in the buffer, it will send a copy of the information to all of the T2 buffers connected to it.

### BasicGRoIBuilder, GRoIBuilder

BasicGRoIBuilder inherits from BasicDAQObject. It then sets it's class id to GRoIBuILDER. GRoIBuilder is used to generator the global ROI's.

The fields of (Basic)GRoIBuilder are:

* t2Supervisor :

The methods of (Basic)GRoIBuilder are:

ObjInit :

MessageArrived :

Initialise :

When a message arrives at the GRoIBuilder it checks that it is T1Data, producing an error if it is not. It then extracts the ROI definitions from the data, and sends a copy of these definitions to all of the LRoI builders connected to it.

### BasicGT1Generator, GT1Generator

BasicGT1Generator inherits from BasicDAQObject. It then sets it's class id to GT1GENERATOR. GT1Generator is used to produce the events and pass them out to the system.

The fields of (Basic)GT1Generator are:

* eventServer :
* datafile :
* extension :
* T1EventClock :
* histogramNRois :

The methods of (Basic)GT1Generator are:

* nextT1YesDelay :
* DoDrop :
* DumpStatus :
* ObjInit :
* ObjTerminate :
* Initialise :
* MessageArrived :
* ProcessConfExtensions :
* Start :

It generates an event, and extracts the T1Data from this event. It then passes this T1Data, in a message, on to all of the GROIBuilders and LT1Generators connected to it. It then waits for a time, for the next T1 yes, and then loops back to produce another event.

### BasicLRoIBuilder, LRoIBuilder

BasicLRoIBuilder inherits from BasicDAQObject. It then sets it's class id to LRoIBuilder.

The fields of (Basic)LRoIBuilder are:

* t2Supervisor :

The methods of (Basic)LRoIBuilder are:

* ObjInit :
* Initialise :MessageArrived :

gimeSubDetector :

The method gimeSubdetector returns the subdetector that the ROI builder is in. LRoIBuilder is used to pass the ROI's in a partition out to the T2 buffers.

When it receives a message it extracts the window definitions from the data. It then asks each T2 buffer in it's partition whether the T2 buffer is hit. It then sends to each T2 buffer hit by the ROI, the window definition.

### BasicLT1Generator, LT1Generator

BasicLT1Generator inherits from BasicDAQObject. It then sets it's class id to LT1GENERATOR. LT1Generator is used to pass the event data in a partition to the FE buffers in the partition.

The methods of (Basic)LT1Generator are:

ObjInit :

MessageArrived :

When a message arrives, it extracts the event data from it. It then passes this event data, in a message, on to all of the FE buffers connected to it.

### The Level 2 Modules

This section details the modules which are used to produce the level 2 system.

The architectures of the level 2 system we are modelling have the form of Figure 2. The architectures are not restricted to this model. The modules which are included in this section are; (Basic)GT2Processor, (Basic)LT2Processor, (Basic)T2Buffer,

(Basic)T2Supervisor, DAQSwitch.

The modules are split into basic and generic modules. Basic modules have the word Basic in their name. Basic modules should provide the fields and methods common to the class, whereas the generic modules provide a complete implementation.

Figure 6: Inheritence tree of the level 2 objects

Figure 7: Possible structure of the level 2 system

### BasicDAQSwitch, DAQSwitch

The BasicDAQSwitch inherits from BasicDAQObject. It then sets it's class id to BASICDAQSWITCH.

Overriden methods of (Basic)DAQSwitch are:

* ObjInit :
* Start :
* MessageArrived :

When it receives a message, it checks the message for it's target (destination) and then passes the message on to this destination port.

### BasicGT2Processor, GT2Processor

The BasicGT2Processor inherits from BasicDAQObject. It sets it's class id to GT2PROCESSOR.

The extra fields of (Basic)GT2Processor are:

* globalPortIn :
* decisionPortOut :
* T2SupTable :

The overriden methods of (Basic)GT2Processor are:

* MessageArrived :
* Initialise :
* ProcessConfExtensions :

There are two fields, globalPortIn and decisionPortOut. These are logical ports and can be set in the configuration file. globalPortIn is the port on which the processor receives the features from which to make a decision on an event. decisionPortOut is the port on which the level 2 decisions are sent out.

### BasicLT2Processor, LT2Processor

The BasicLT2Processor inherits from BasicDAQObject. It sets it's class id to LT2PROCESSOR.

The extra fields of (Basic)LT2Processor are:

* globalPortOut :
* featurePortIn :The overridden methods of (Basic)LT2Processor are:

* MessageArrived :
* Initialise :
* ProcessConfExtensions :

There are two fields, globalPortOut and featurePortIn, which are logical ports and can be set in the configuration file. globalPortOut is the port on which the processor sends out it's extracted features. featurePortIn is the port on which data from which to extract the feature is received.

### BasicT2Buffer, T2Buffer

BasicT2Buffer inherits from BasicDAQObject. It then sets it's class id to T2BUFFER.

The extra fields of (Basic)T2Buffer are:

* t3PortOut :
* localPortOut :
* roiPortIn :
* eventDataPortIn :
* decisionPortIn :
* etaMin, etaMax :
* phiMin, phiMax :
* bufferHit :

The extra methods of (Basic)T2Buffer are:

* setEtaMax, setEtaMin :
* setPhiMax, setPhiMin :
* ROIMapsToT2Buffer :

The overridden methods of (Basic)T2Buffer are:

* MessageArrived :
* ProcessConfExtensions :
* Initialise :

are all logical ports and can be set in the configuration file. are real's and set in the configuration file.

t3PortOut is the port to send the event data out on once a level 2 yes has been received. localPortOut is the port to send data out on when an ROI has been received. roiPortIn is the port that ROI's are received on. eventDataPortIn is the port on which event data is received from level 1. decisionPortIn is the port level 2 decisions are received on.

 etaMin, etaMax, phiMin and phiMax describe the coverage of the T2 buffer in eta and phi.

The method ROIMapsToT2Buffer will return whether the T2Buffer maps to the ROI in eta-phi space or not.

The procedure Overlap is used in ROIMapsToT2Buffer.

### BasicT2Supervisor, T2Supervisor

BasicT2Supervisor inherits from BasicDAQObject. It then sets it's class id to T2SUPERVISOR.

The extra fields of (Basic)T2Supervisor are:

decisionPortIn :

decisionPortOut :

GT2PTable :

T2PTable :

LT2PTables :

T2BTables :

T2BTable :

localIndex :

globalIndex :

The extra methods of (Basic)T2Supervisor are:

WhichLT2Processor :

WhichGT2Processor :

WhichT3Processor :

The overridden methods of (Basic)T2Supervisor are:

MessageArrived :

Initialise :

ProcessConfExtensions :

There are two other fields. decisionPortIn and decisionPortOut. These are both logical ports and can be set in the configuration file.

decisionPortIn is the port that level 2 decisions are received on. decisionPortOut is the port that level 2 decisions are sent out on.

### The Level 3 Modules

This section details the modules which are used to produce a fake level 3 system.

The level 3 system takes the form of figure 3. The modules which are included in this section are; (Basic)T3Processor, (Basic)T3Supervisor.

Figure 8: Inheriteenence tree of the level 3 objects

Figure 9: The structure of the level 3 system

### BasicT3Processor, T3Processor

The BasicT3Processor inherits from a BasicDAQObject. It sets it's class id to T3PROCESSOR.

The extra fields of (Basic)T3Processor are:

bufferPortIn :

The extra methods of (Basic)T3Processor are:

TakeNoDecision :

The overridden methods of (Basic)T3Processor are:

MessageArrived :

Initialise :

ProcessConfExtensions :

It has a field bufferPortIn, which is a logical port, and can be set in the configuration file. This is the port on which it takes data from the level 2 buffers.

The T3Processor inherits from BasicT3Processor and also from HardwareObject.

The method TakeNoDecision is used by level 2 buffers to send the data for level 2 no decisions. This takes no simulation time, and is used to dispose of the events. TakeNoDecision will pass the data straight to the AmalgamateProcess of the T3 processor.

When data is received by the T3 Processor, it passes this data on to it's OSObject.

The internal structure of the T3Processor's processes can be set in the configuration file.

### BasicT3Supervisor, T3Supervisor

The BasicT3Supervisor inherits from a BasicDAQObject and sets it's class id to T3SUPERVISOR. At the moment it has no other functionality.

The T3Supervisor is currently just a BasicT3Supervisor.

### Switching Code

Various switching technologies have been modelled by various groups, and are detailed in seperate documents.

* The ATM code is implemented in the modules; ATMPort. AttATMFabric, AttElement and BasicATMSwitch. The documentation for these modules is available in [17].
* The SCI code is implemented in the modules in the directory SCILAB. The documentation for this code is available in [14].

The C40 code is implemented in the modules C40Linker and C40Port.

### 9.0 The Process Modules

This document will detail the modules within the generic/process subdirectory of the SIMDAQ model.

The modules here are used to build up the processors within the SIMDAQ model. This is done by joining separate process's by buffers. The process's all run on a single OS on a single piece of hardware.

The designs for processes in the level 2 objects are described in Ref. [13]. They all follow the structure given in figure 4. Where a HardwareObject contains an OSObject which in turn contains many Processes and Buffers.

### 9.1 OSObject

The OS Object is used to pass messages on from the hardware to the input process. It also provides the CPU resource for the processes.

The CPU is allocated by each process interrupting the OS and taking the CPU. Once the process has finished, the OS will re-schedule any of the processes which were interrupted.

### 9.2 The Processes

The processes which are detailed below are used to build up the functionality of the processors in the Level 2 trigger. Details of processors built up using these are given elsewhere.

Figure 10: Structure of level 2 modules

#### 9.2.1 AmalgamateProcess

The amalgamate process is used to combine a number of different items which are needed at the next level of processing.

An example of this is the Local Processors within the T2 model. These need to collect information from several of the T2 buffers, and once all of the information has been received, pass on this information for feature extraction.

This is implemented by using a series of queue's.

When a data item is received on the input buffer, it will check the number of sub-components for the item.

If there is only a single sub-component, then the item that has been received is passed on (in a queue) to the next process.

If more than one sub-component is needed, then the process checks whether any related components have already been received. If so it adds thee new item to this list and checks it the list is complete, passing it on if it is complete. If there have be no related components received, then it puts the new component in a new queue and stores this queue.

#### 9.2.2 BroadcastProcess

The broadcast process is used by the T2 Supervisor to pass out the level 2 decision to all of the T2 Buffers in the system.

Figure 11: Inheritence tree of the process objectsThe broadcast process receives a data item on it's input queue. It then sends out a message containing this data item to all of the T2 Buffers in the system. The list of T2 Buffers is produced by the T2 Supervisor earlier in the simulation.

#### DecisionProcess

The decision process is used by the global processors to produce the level 2 decision for an event.

The process first takes a queue of data item's from it's input queue.

It assumes this data it window features, and then extracts the roi features from these window features.

It then extracts the event features from the window features.

It then extracts the T2 data from the event features. This T2 data includes the level 2 decision.

It then drops all of the other data item's in the queue taken from the input. Then it finds out the input port on the T2 supervisor to take this information, and constructs a message with this data. This message it then sends on to the output queue.

#### DisposeProcess

The dispose process is used by the level 3 processor to dispose an event once all of the buffers have finished with it.

......

#### ExtractProcess

The extract process is used by the local processors to extract a feature.

The process takes a queue of data item's from it's input queue.

It takes the first item of this queue and extracts the window data from it. Then it drops the rest of the data item's in the queue.

A message is then constructed and the window data is added to it. The destination for this message is given by the T2 Supervisor. This message is then sent to the output queue.

#### InputProcess

The input process is used by most of the hardware to take messages from a port and put them in a queue for processing.

The method MessageArrived is called by the processor. Input process then simply passes each of the data item's in the message on to the output queue.

#### 9.2.7 OutputProcess

The output process is used by most of the hardware to send messages on to another piece of hardware.

The process simply takes a message from it's input queue and waits for it's output port to send the message on.

The output port is set in the configuration file by using the keyword outPort, and then the name of the logical port to be set as the output.

#### 9.2.8 T2BufferStoreProcess

The T2 buffer store process is used by the T2 Buffers to store and send on the event, region of interest and decision data.

The process takes a data item from it's input queue, and checks it's type.

If it is an Event data item, then it checks to see if there is a region of interest for this event. If so, it puts both the event data item and the region of interest into a queue and sends this on to it's output queue. The region of interest is removed from the internal buffer. If there is a region of interest, or not, the event data is stored in an internal buffer.

If it is a region of interest data item, then it checks to see if there is any event data for this data item. If there is some event data, it adds the event data, and the region of interest data, to a queue and sends this to it's output queue. If there is no event data, then the region of interest data is stored in an internal buffer.

If it is a decision data item, then it checks the event data internal buffer for data for this event. It removes this data from the buffer, and then if the decision is a no, it drops this data, if the decision is a yes, then the data is sent on to the level 3.

This will change some time. Update.

#### 9.2.9 WindowExtractProcess

The window extract process is used in the T2 Buffers to extract the window data to pass on to the local processors.

The process takes a queue from it's input queue. It retrieves the window definition from this queue, and extracts the window data from it. It then constructs a message with this window data in it, and passes this on to it's output queue.

The local processor to use as a destination is given by the T2 Supervisor.

### HardwareObject

The hardware object is used to pass on messages to the OS object and also to give the clock speed of the hardware.

### The Data Structures

This section details the data structures used to model the data from the detectors, and also the data structures produced by the level 2 system during processing. For example the raw data from detector, and the features extracted from this data.

The data structure is split into four categories:

* Raw Data
* Control Data
* Feature Data
* Trigger Data

### Raw Data

The raw data structure is used to model all of the raw data coming off the detector. The structure is of the form shown in Fig. 12

Figure 12: RawData data structure

### Control Data

The control data is used to model the control information which is sent around the system. This includes RoI and window definitions. The structure is of the form shown in Fig. 13

### Features

Features are the features which have been extracted by the DAQ system, and are used to make the decision on the event. The structure is of the form shown in Fig. 14

Figure 14: Features data structure

Figure 13: ControlData data structure

### Trigger Data

Trigger data is the data which holds the trigger decisions, and reasons, for the system. The structure is shown in Fig. 15

### MODSIM II Histogramming Package for use with ATLAS Trigger/DAQ-Simulations

This section documents the Histogramming Package. This package is a collection of MODSIM II routines (nearly all of which come in the form of methods of one single class) which serve to provide basic histogramming functionality to ATLAS Trigger/DAQ-Simulation programs.

The algorithms that are implemented by these methods are rather trivial and straightforward (even more true so for this first release), thus they do not require much documentation apart from what is given in the source-code. However the package has been prepared to interface with several backend programs with graphics capabilities in either online- or offline-modes.

The setup-requirements for allowing smooth operation of these options are given herein.

### Which files to get and from where to get them

The current distribution consists of the following source-files: DDAQAssert.mod, IDAQPsper.mod, IDAQPipe.mod, DAQPipe.h, DAQPipe.c, DDAQHisto.mod, IDAQHisto.mod, DDAQSetupFile.mod and IDAQSetupFile.mod. All source-files are available by anonymous ftp from sunsci.cern.ch from directory simulation/atlas_daqsim/latest_code.

Programmers who wish to make use of the Histogramming Package first have to add FROM DAQHisto IMPORT HistogramObj to their code. Some of the files in turn

Figure 15: TriggerData data structurerely on code imported from DDAQMod.mod, which is available from sun-sci.cern.ch as well.

The Histogramming Package has been developed using Version 1.9.8 of the MODSIM II programming environment. All source-files contain version information as maintained by _rcs_ (Revision Control System). By conventions derived from it, version numbers are included in comments starting with $Id: near the beginnings of the files. The version numbers for all files belonging to the current distribution read 1.0.

### How to integrate with existing code

Within the context of the Histogramming Package each histogram is represented by a MODSIM II-object of type HistogramObj. This type is defined in the definition file DDAQHisto.mod. During the lifetime of a histogram-object it expects to be acted upon by things happening in the following order (see Figure 1):

Figure 16: Calling order for methods during lifetime of a histogram object

A call to MODSIM II's procedure NEW with a properly typed argument allocates the histogram object.

It is the sole responsibility of the program making use of the Histogramming Package to issue such a call explicitly for every histogram that has to be handled. This is also true for calls to its methods and for the final call to MODSIM II's procedure DISPOSE. Things will have to be arranged in the program itself, the Histogramming Package will not trigger any such actions.

Since MODSIM II's own constructors cannot take arguments by definition, they cannot provide a newly created object with an internal state other than non-default easily. Therefore each creation of an object of type HistogramObj should immediately be followed by a call to its method Prepare, which serves as another "constructor", being responsible for allocating additional storage, opening pipes and / or setting up temporary files in some cases.

ASK METHOD Prepare (IN owner: ANYOBJ; IN label: STRING; IN min,max,interval: REAL);

Prepare takes two groups of arguments:

owner and label in combination serve to provide unique identification of histograms. Such identification is required whenever a histogram is displayed graphically and when one wishes to be able to distinguish between different histograms shown at the same time. It is also required when data contained in histograms is to be written out to files. With filenames having to be unique, so do histogram's identifications, since they essentially serve as filenames as well. (This will be explained in more detail below.)

The idea is that each histogram is owned by some other object, which will usually be of some SIMDAQ-type. Routines that construct labels for graphical display or construct filenames know about some frequently used types and are able to extract features suitable for identification from them. The ClassId and SerialNo of BasicDAQObjects are e.g. used in this way.

The value of the argument label is appended to what is constructed that way.

The purpose of introducing label in addition to owner is twofold. First, more than one histogram object can be owned by one single object, in which case labels can help to maintain uniqueness among histograms' identifications. Second, a method has been foreseen to setup the Histogramming Package in such a way that only histograms whose labels match a certain pattern will actually be printed. By making clever use of this option (associated to the tag _wildcard_ in the setup-file) and by choosing labels carefully, one can select the amount of data that is output on different runs of the simulation program without any need to recompile it.

The following are examples for histogram identifications: "BasicDAQObject 2000 0 buffer occupancy", "some object buffer occupancy". The object owning the histogram is a BasicDAQObject with ClassId 2000 and SerialNo 0in the first, and an object of any other type in the second example. "some object" is always substituted when the owner's type does not allow for the contribution of features for unique histogram identification or if the Histogramming Package does not know how to extract any. (In the current implementation only BasicDAQObjects and types derived from it are recognised.) label equals "buffer occupancy" in both cases.

The second group of parameters to Prepare serve to setup the coordinate system to be used along the x-axis of the histogram. The range between min and max on this axis will be filled conceptually with histogram bins of width interval each. (The number of bins in the histogram is determined only indirectly.) Two extra bins for values below and beyond these margins are foreseen for every histogram as well.

All bins in a histogram are initially set to heights zero. At any later time heights can be set back to zero explicitly by calling the method Reset.

ASK METHOD Reset; Normally one wishes to increment certain bins' heights at times when program-flow passes through special points that need consideration. The histogram will then be keeping track of how often these points have been passed through (using different weights when increments differ from one). Histograms will also record the "state" of the program upon each path-trough, each bin of a histogram being thought of as representing one state in this simple analogy.

A call to the method Grow raises the height of one bin in the histogram by one, GrowBy and GrowByInt generalize over this behaviour by allowing increment values other than one.

ASK METHOD Grow (IN: at: REAL);

ASK METHOD GrowBy (IN at,increment: REAL);

ASK METHOD GrowByInt (IN at: REAL; IN increment: INTEGER);

The value of at is considered to be expressed in the coordinate system defined by the parameters min and max in the call to the method Prepare. From these the method calculates which bin needs to be incremented. If the value is below or beyond its two margins, one of the histogram's special bins for too high or too low values will be raised in effect.

At any time a histogram can be asked for the total height of all of its bins. The method SumOfHeights will do the job.

ASK METHOD SumOfHeights: REAL;

When at some point enough information has been collected to justify for displaying the current state of the histogram (which might also be its final state) graphically it can be asked to print its content.

ASK METHOD Print;

The effects of calls to Print depend strongly on what has been specified in the setupfile. A distinction can be made between _online_- and _offline_-modes.

Online-mode will lead to histograms being show on-screen almost immediately, i.e. in any case while the simulation program is still running.

To accomplish this, the Histogramming Package usually relies on a special program that serves as a backend for showing histograms graphically on screen. It communicates with such a program using temporary files and also Unix-pipes, which is why part of the implementation had to be done in C. These aspects of the implementation are, however, fully hidden from the user for transparency, and will not hamper portability across a wide range of Unix-systems.

_gnuplot_ and _xgraph_ are among the currently supported programs for online-analysis. Both are available easily from numerous ftp-sites. During development, tests have been done with version 3.5 and version 11.3.2 of _gnuplot_ and _xgraph_ respectively.

Due to some rather technical reasons it turns out, that _gnuplot_ shows asynchronous behaviour whereas _xgraph_ does not. The following paragraphs will explain this difference:

_gnuplot_'s _asynchronous_ behaviour allows for several histograms to be displayed in several windows at the same time. The histograms may even alter in shape as the program continues running. To provide for this, a program has to call a single histogram's method Print several times in succession during the course of the histogram altering its shape. (Note that when the simulation programs finishes execution, so is _gnuplot_ forced to do. A waiting loop might be necessary near the end of the simulation program in some cases.)

_xgraph_ on the other hand shows _synchronous_ behaviour. This means that the method Print will return control to the caller only after the user has taken some action. It requires the user e.g. to click the application's _Exit_-button. It is obvious that now there is no way to show more than one histogram online at the same time or to see a histogram change its shape without interruptions.

Offline-mode means that data contained in histograms is output to files in a form that allows for later display or analysis with a suitable program. As with online-mode, different users are expected to favour different programs over others. Therefore support for several likely choices is foreseen, the difference between them is mainly in the syntax which is used when data is written out to files.

Supporting different options is, however, less troublesome in the case of offline-modes because a common standard for representing coordinates in text-files is usually supported. It foresees for each line in the file to hold a duple of coordinates, where coordinates are separated from each other by blanks. Coordinates are written as real numbers in plain ASCII-representation.

Currently supported options for offline-analysis include _gnuplot_ and _xgraph_ (again). There is also a mode called _psgnuplot_ which makes _gnuplot_ create files containing the full graphical representation of histograms in Postscript-format, i.e. the corresponding files can be sent to printers for immediate printout.

Probable candidates for future addition as new options are _Matlab_ and _PAW_. Due to the simple structure of data-files these tools however might be very well able to take input from files created with one of the options supported in the current version as well.

Apart from choosing the syntax of the output file (which is now understood to be a trivial task), different offline-modes will also lead to slightly different filenames. Filenames are formed by taking a histogram's identification, replacing any blanks by underscores and appending a suffix that identifies the offline-mode, i.e. the program that should finally receive the file. Typical examples of filenames are BasicDAOObject_2000\(0\) buffer_occupancy.gnuplot or some_object_buffer_occupancy.ps.

Note that the semantic of the setup-file foresees a way to steer the output-files to directories other than the present working directory. This can be done by utilizing the path-tag.

Depending on the selected option the method Print will branch to methods named PrintGnuplotOnline, PrintGnuplotOffline etc. These methods are considered beyond reach from outside, i.e. calling them explicitly should be avoided, although it is not explicitly forbidden. Instead, the corresponding entry in the setup-file should be edited to guarantee that changes take effect globally.

When a histogram-object is no longer needed, it is necessary to delete it by calling MODSIM II's procedure DISPOSE. If this is neglected, temporary files may remain.

### How to adapt behaviour by editing the setup-file

The Histogramming Package uses a setup-file _historc_ in which the user may store information that will affect the quantity and quality of the output produced when the simulation program is run. Its syntax is similar to what is used by convention throughout the Unix-world.

All lines starting with the character # are treated as comments, i.e. their contents are considered relevant only to human readers. All other lines have to be either empty or of the form _tag: value_.

Table 1 lists all currently supported tags and the semantics of values that are allowed to go with them. The following paragraph quotes from a sample setup-file:

# resource file to be used with MODSIM Histogramming
# Package for ATLAS Trigger/DAQ-Simulations

backend: gnnuplotwildcard: *  mode: offline  path: test ```

\begin{table}
\begin{tabular}{c c c} \hline \hline
**tag** & **value** & \\ \hline backend & asciiart & Pseudo-graphical representations of histograms are printed to stdout when in online-mode, or to files when in offline-mode. \\  & gnuplot & _gnuplot_ is selected as the preferred tool for online- or offline-mode. \\  & psgnuplot & Graphical-representation of histograms are stored in files using Postscript. Note that this value may only be used when in offline-mode. \\  & xgraph & _xgraph_ is selected as the preferred tool for online- or offline- mode. \\ \hline mode & online & Switches to online-modes: Histograms are shown immediately, i.e. while the simulation program is still running. Note that online-mode and _psgnuplot_ are incompatible options. \\  & offline & Switches to offline-modes: Histograms are stored in data-files in formats suitable for later offline- analysis and display, using a tool as indicated by the _backend_-option. \\ \hline path & All data-files will be created in the specified directory. \\  & wildcard & Calls to Print will only have an effect for histograms whose labels are matching regular expression given as this tag’s value. See the manual-pages for the Unix-command _ed_ for a description of regular expressions. \\ \hline \hline \end{tabular}
\end{table}
Table 1: Tags and values allowed to occur in the setup file 1. On sun-workstations with SunOS 4.1 _gunplot_ requires the environment variable LD_LIBRARY_PATH to be set in such a way that OpenWindows-libraries are searched for before X-libraries. Otherwise an error message "undefined symbol : _XtQString" will occur. (This is a problem found commonly also with other applications, so there might be a preinstalled script to solve it precisely. Try _setow_ e.g.)
2. Histograms as shown by _gunplot_ will appear in windows that are located initially at the same position on screen. As long as the user does not drag away the topmost window, only one histogram will be visible.
3. The current version ignores any values associated with the tag _wildcard_ in the setup-file. The match is carried out in such a way that every histograms fits for output.
4. If a single histogram is printed in offline-mode several times, output will be written to the same file more that once and the resulting file will thus contain only partial information. This will probably be dealt with in the future by inventing consecutive numbers as additional parts of filenames, thereby introducing even longer filenames such as BasicDAQObject_2000_0_buffer_occupancy.l.ps.
5. _gunplot_ seems to impose a limit on the total length of filenames in the order of magnitude of 50 characters. Output-files might therefore be generated with names truncated if the value of the tag _path_ in the setup-file contains too many characters.
6. During offline analysis it will be necessary to type in a number of commands in order to make programs like _gunplot_ or _sgraph_ show histograms instead of their default types of graphs. When in online-mode these commands are generated automatically by the Histogramming Package. In offline-mode the user is responsible for giving them.
7. If _gunplot_ and _sgraph_ do not reside in the executable-files-path, the Histogramming Package will not generate a specific error message but will simply not show results when in corresponding online-modes.
8. A method PrepareDynamic, which can serve as a fully functional substitute for Prepare will be provided in the next version. It will allow for histograms to be prepared in such a way that they may grow along their x-axes, with new bins added dynamically on demand.
9. Procedures to print or delete several or all histograms at once and methods to carry information for labelling x-axes of histograms (with dimensioning codes e.g.) are also being discussed.

The current implementation is not intended to be complete. Indeed, I have accepted this drawback as not too bad because it will hopefully encourage feedback and discussion.

### 12.0 The Configuration Files

The configuration files are used to define a given configuration for the elements of a SIMDAQ simulation. At the start of a run, the SIMDAQ program reads in these configuration files and builds the system which is described. The simulation is then run on this system.

There are three main areas in the configuration files; #define section which is used to define given names to class id's, object definition which defines the objects to be in a system, and object parameters or object configuration extensions which define certain attributes of an object.

### The #define Section

At the top of the main.conf file, there is a section which contains #defines. These mean that names can be used instead of numbers, and makes the.conf files more readable. The pre-processor, at run time, converts the names into numbers which SIMAQ can then convert to objects.

#### 12.1.1 Section 1

The first section of #defines contains lines such as:

#define LT2Processor 2008

This will give the label 'LT2Processor' the number 2008, which refers to the class id of the Local T2 Processor. These class id's are stored in the module DAQMod.

#### 12.1.2 Section 2

The next section of #defines contains lines such as:

#define LT2PToGT2SPort BasicDAQPort

These define the ports from, in this example, the Local T2 Processor to the Global T2 Switch to be of type BasicDAQPort. This is useful if we want to change the switch type. For example, if the switch is changed to an ATM switch, we just need to modify this line to;

#define LT2PToGT2SPort BasicATMSwitch

and all of the ports will be changed.

### Object Definition

A major part of the configuration files is taken up with the object definitions. These object definitions have the form;

object LT2Processor *

...

end object

Here the Object type is a Local T2 Processor. The star after the name is a configuration extension and represents a serial number, the * means a number will be automatically allocated. There can be more configuration extensions after the star, which will be parameters read by that object. These are discussed in Configuration Extensions on page 44. Parameters can also be entered on separate lines, see Object Parameters on page 46.

Where, in the above example, there are some dots, we can enter more objects.

Objects in SIMDAQ are hierarchical. So one object can own many other objects. These owed objects are in the parent objects ChildQueue. An example of this is port objects.

Most elements of the simulation system have ports to link up and communicate with other elements. These are defined as;

object LT2Processor *

object LT2PToGT2SPort P1LT2PToGT2SPort1

GT2SToP1LT2PPort1 GT2SToLT2PPort GenOUT 1

end object

...

end object

Here, we can see the use of the #define from LT2PToGT2PPort. Also we have given a specific label to the serial number, in this case P1LT2PToGT2SPort1. This label is given so that the port can be referred to in other objects, namely the Global Switch it is connecting to. There follow details of the port it is connected to, serial number and class id, and also the communication type of the port, in this case GenOut for output port, and a key, 1.

### Configuration Extensions

The configuration extensions which go after the object type are detailed below.

#### 12.3.1 BasicDAQObject

object BasicDAQObject <SerialNo>

The BasicDAQObject is the base object from which all other DAQ object inherit. The only configuration extension is the <SerialNo>. If a star (*) is given here, then at read-in time, a unique serial number will be allocated.

#### 12.3.2 ATMPort

object ATMPort <SerialNo/PortNo> <FarPortNo> <FarClassId> <IODirection> <Key>

An ATM port has 5 configuration extensions.

* <SerialNo/PortNo> : This is the serial number, which also acts as the port number.
* <FarPortNo> : This is the far port number, which is the serial number of the port it is connected to.

* <FarClassId> : This the object type of the port it is connected to, for example ATMPort. At configuration time, this port object will be connected to the port object with the far port number and class.
* <IODirection> : This is the direction of data at this port, eg GenIN or GenOUT for input or output.
* <Key> : This is a key used by the switching people.

#### AttATMFabric

object AttATMFabric <SerialNo> <InPorts> X <OutPorts> <SwitchType>

The AttATMFabric has 5 configuration extensions:

* <SerialNo> : This is the serial number.
* <InPorts> : This is the number of input ports.
* X : This is a label to represent 'by', as in 5 by 5.
* <OutPorts> : This is the number of output ports.
* <SwitchType> : This is the type of the switch.

#### BasicATMSwitch

object BasicATMSwitch <SerialNo> <InPorts> X <OutPorts> <SwitchType>

The BasicATMSwitch has 5 configuration extensions. They are the same as those for the AttATMFabric.

#### BasicDAQPort.

object BasicDAQPort <SerialNo/PortNo> <FarPortNo> <FarClassId> <IODirection> <Key>

The BasicDAQPort has 5 configuration extensions. These are the same as those for the ATMPort.

#### DAQSystem

object DAQSystem <SerialNo>

The DAQSystem has 1 configuration extension, the <SerialNo>. Is this needed?

### Object Parameters

Objects in the system can have parameter which the configurer can set. These are set using parameter statements in the object. And example of this is the etaphi coverage of a T2 Buffer;

object T2Buffer *

etaphi -3 3 0 6.283

...

end object

Here the etaphi range of the T2 Buffer is being set to etaMin = -3, etaMax = 3, phiMin = 0, phiMax = 6.283 (2 * Pi). The parameters are read using the objects ProcessConf-Extensions method.

A list of parameters follows;

#### 12.4.1 datafile

The datafile parameter is set in the GT1Generator object. It is set using a command of the form;

datafile data.file

where data.file is the file from which the event generator will read it's events.

#### 12.4.2 debuglevel

The debuglevel parameter is set in the main.conf file, outside of any object. It is the level of debugging information that the simulation will provide to the standard output while it is running. The current ranges are 0 - 7. It is set using a command of the form;

debuglevel 1

which will set the debug amount of information to a minimal level.

#### 12.4.3 etaphi

The etaphi parameters are set in a T2Buffer object. They are the ranges in eta and in phi that the T2Buffer covers. They are set using a command of the form;

etaphi -3 3 0 6.283

which will set the buffer to cover the range [-3, 3] in eta and [0, 6.283] in phi.

#### 12.4.4 logicalPort

The logicalPort parameter is set within an object that has logical ports available. These are the main processing objects, T2Buffer, LT2Processor, GT2Processor, etc. It is used to provide a named 'logical' port instead of using the actual port. It is set using a command of the form;

 logicalPort globalPortOut P1LT2PToGT2SPort1

which will set a LT2Processors global out port, for sending extracted features to the global system, to the port with the specified serial number.

#### 12.4.5 inBuffer, outBuffer

The inBuffer and outBuffer parameters are set within a process within an operating system. The operating system has a number of buffers for communicating between different processes and these parameters set which buffer a process used for input or output. They are set using a command of the form;

 inBuffer TriggerBuffer 1

 outBuffer TriggerBuffer 2

 which will set the in Buffer at the Trigger Buffer with serial number 1, and the out buffer as the Trigger Buffer with serial number 2.

#### 12.4.6 outPort

The outPort parameter is set in an OutputProcess in an operating system object. It is the logical port that the process will use to send data out. It is set using a command of the form;

 outPort globalOutPort

 which will set the output port as the logical port globalOutPort, which must be set elsewhere in the Processor.

#### 12.4.7 processTime

The processTime parameter is set in a Process within an operating system object. It is the amount of simulation time a process takes, and is in simulation time units, currently nano-seconds. It is set using a command of the form;

 processTime 1000

 which will set the process time as 1 microsecond.

#### 12.4.8 roiOutQueue, t3OutQueue

The roiOutQueue and t3OutQueue parameters are set in a T2 buffer store process within an operating system. They are similar to the outBuffer parameter, but a T2 buffer store process sends data to either level 3 or the local level 2, so these parameters are used. They are set using commands of the form;

roiOutQueue TriggerBuffer 3

t3OutQueue TriggerBuffer 4

which will set the roiOutQueue, for data for level 2 processing, to the Trigger Buffer with serial number 3, and the t3OutQueue, for data to the level 3 system, to the Trigger Buffer with serial number 4.

#### 12.4.9 simtime

The simtime parameter is set in the main.conf file, outside of any object. It is the length of simulation time that SIMAQ will run for, and is in simulation time units, which are currently nanoseconds. It is set using a command of the form;

simtime 7000000

which will set the simtime to 7 milli seconds.

### Bibliography

1. "Modelling of the ATLAS Data Acquisition and Trigger System", A. Bogaerts et al, ATLAS DAQ note 18, November 1994.
2. "ATLAS Letter of Intent for a General-Purpose pp Experiment at the Large Hadron Collider at CERN", Atlas Collaboration, CERN/LHCC/92-4, October 1992.
3. "Ideas for a Local/Global Level-2 Trigger System", N.Ellis, Atlas DAQ Note 12, April 1994.
4. "Proposal for ATLAS DAQ Modelling", A. Bogaerts, N. Ellis, F. Harris, J. Vermeulen, April 1994.
5. "Modelling of local/global architectures for second level trigger at the LHC experiment", Z. Hajduk et al., EAST 94-17, February 1994.
6. "Design and Simulation of Fibre Channel Based Event Builders", R. Spiwoks, RD 13 Note 132, December 1994.
7. "Readout data specifications for modelling a level-2 trigger using regions of interest", R Bock and P LeDu, Atlas DAQ Note xxx, September 1994.
8. "ATLAS Trigger Simulation User Guide", J Carter, Atlas DAQ Note xxx, September 1994.
9. "Second Level Trigger Feature Extraction Algorithms", R. Hauser & I Legrand, EAST 94-13, June 1994.
10."GEANT Detector Description and Simulation Tool", Application Software Group, CN Division, CERN, CERN Program Library Long Write-ups Q123, June 1993.
11."ATLAS Data for Trigger Studies in a Portable Text Format", J Carter, EAST 94-33,October 1994.

12."MODSIM II - The Language for Object-Oriented Programming", CACI Products Company, La Jolla, California, January 1993.

13."Internal Structure of the Processors in SIMDAQ", S Hunt, Atlas DAQ Note xxx, November 1994.

14."The SCILab Cookbook - A Simulation Environment for the Scalable Coherent Interface", A. Bogaerts & B. Wu, RD24 Note, October 1994.

15."Modelling Results of the Atlas Data Acquisition and Trigger System", Atlas Modelling Group, Atlas DAQ Note xxx, November 1994.

16."Modelling of the ATLAS Data Acquisition and Trigger System with SCI", A. Bogaerts, H. Li, B. Skaali, B. Wu, ATLAS DAQ Note 40, January 1995.

17."Using ATM Switches Model in SIMDAQ", D.Calvet,??? Note xxx, August 1994.

## Index

A

DisposeProcess.................31

AddPartition.................10

Algorithms.................5

AmalgamateProcess.................30

ATMPort.................28

AttATMFabricic.................28

AttElement.................28

B

BasicATMSwitch.................28

BasicDAQObject.................13

BasicDAQPort.................14

BasicDAQSwitch.................24

BasicFEBuffer.................20

BasicGRoIBuilder.................20

BasicGT1Generator.................21

BasicGT2Processor.................24

BasicLRoIBuilder.................21

BasicLT1Generator.................22

BasicLT2Processor.................24

BasicT2Buffer.................25

BasicT2Supervisor.................26

BasicT3Processor.................28

BasicT3Supervisor.................28

BroadcastProcess.................30

C
C40Linker.................29

C40Port.................29

Configuration.................6,42

Configure.................10,12

Constants.................15

D

DAQBuffer.................15

DAQMod.................16

DAQPartition.................16

DAQSwitch.................24

DAQSystem.................17

Data Structures.................33

Datafile.................10,46

DebugLevel.................46

DecisionProcess.................31

Detector.................4

DisposeProcess.................31

DumpTime.................11

E

E

E

EtaPhi.................46

ATMPort.................28

Extension.................11

AttATMFabricic.................28

ExtractProcess.................31

AttElement.................28

ExtractSigma.................7

B

ExactTime.................8

BasicATMSwitch.................28

BasicDAQObject.................13

FastRun.................8

BasicDAQPort.................14

Features.................34

BasicDAQSwitch.................24

FELBuffer.................20

BasicFEBuffer.................11

BasicGRoIBuilder.................20

BasicGT1Generator.................21

BasicGT2Processor.................24

BasicLRoIBuilder.................21

BasicLT1Generator.................22

BasicLT2Processor.................24

Graphical Interface.................13

GRoIBuilder.................20

BasicT2Supervisor.................26

GT1Generator.................21

BasicT3Processor.................28

BasicT3Processor.................28

Basket3Supervisor.................30

BroadcastProcess.................30

C

C40Linker.................29

C40Port.................29

Configuration.................6,42

Congiture.................10,12

Constants.................15

D

DAQBuffer.................15

DAQMod.................16

DAQPartition.................16

DAQSwitch.................24

DAQSystem.................17

Data Structures.................33

Datafile.................10,46

DebugLevel.................46

DecisionProcess.................31

Detector.................4

DisposeProcess.................31

DumpTime.................11

DumpTime.................11

E

EtaPhi.................46

ATMPort.................28

Extension.................11

AttATMFabricic.................28

AttElement.................28

B

ExactTime.................8

BasicATMSwitch.................28

BasicDAQObject.................13

BasicDAQPort.................14

BasicDAQSwitch.................24

BasicFEBuffer.................20

File.................11

BasicGRoIBuilder.................20

BasicGT1Generator.................21

BasicGT2Processor.................24

BasicGT2Processor.................24

BasicGT3Supervisor.................28

BroadcastProcess.................30

C

C40Linker.................29

C40Port.................29

Configuration.................6,42

C40Sor.................10,12

Constants.................15

D

DAQBuffer.................15

DAQMod.................16

DAQPartition.................16

DAQSwitch.................24

DAQSystem.................17

Data Structures.................33

Datafile.................10,46

DebugLevel.................46

DecisionProcess.................31

Detector.................4

DisposeProcess.................31

DumpTime.................11

DumpTime.................11

E

EtaPhi.................46

ATMPort.................28

Extension.................11

AttATMFabricic.................28

ExtractProcess.................31

AttElement.................28

ExtractSigma.................7

B

ExactTime.................8

BasicATMSwitch.................28

BasicDAQObject.................13

BasicDAQPort.................14

BasicDAQSwitch.................24

BasicDAQSwitch.................24

BasicGFBuffer.................20

File.................20

File.................20

File.................20

G

G

G

G
G

G

G
G

G

G
G
G
G
G
G
G

G
G
G
G
G
G
G
G
G

G
G
G
G
G
G
G
G
G
G
G
G
G
G

G
G
G
G
G
G
G

G
G
G
G
G
G
G
G

G
G
G
G
G
G

G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G

## Index

M

MakeSystem.................12

Message.................18

MODSIM II.................5

O

Object Parameters.................46

OSObject.................29

OutBuffer.................47

OutPort.................47

OutputProcess.................32

Overview.................4

P

Partition.................7, 9

PFile.................8

Physics.................5

PId.................8

PLocProc.................8

PName.................8

Process Modules.................29

ProcessTime.................47

PSubDet.................8

PSwitch.................8

R
RawData.................33

Reset.................38

ResetTime.................11

RoIOutQueue.................48

Run.................4

S
SCILAB.................28

Segment.................9

SimTime.................11, 48

SumOffHeights.................38

Support Modules.................13

Switch.................12

Switches.................28

T
T2Buffer.................25

T2BufferStoreProcess.................32

T2Supervisor.................26

T3OutQueue.................48