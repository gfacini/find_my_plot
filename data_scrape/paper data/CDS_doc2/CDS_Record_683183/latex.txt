**ATLAS Internal Note**

**SOFT-NO-007**

**9 December 1993**

FORTRAN Programming Conventions for ATLAS offline software

Chris Onions

December 1st,1993

###### Contents

* 1 Introduction
* 2 FORTRAN standards
* 3 Conventions
	* 3.1 Code management
	* 3.2 Statement Syntax and Layout
	* 3.3 Comments
	* 3.4 Program Units, Subprograms
	* 3.5 Order of Statements
	* 3.6 Arrays
	* 3.7 Initialization
	* 3.8 Control Statements
	* 3.9 Specification Statements and Data Types
* 3.10 Input/Output
* 4 Naming and Numbering Conventions
	* 4.1 Numbering conventions
	* 4.2 Naming conventions for variables
	* 4.3 Naming conventions for variables subroutines and banks
* A Bit and byte handling
* A.1 Logical operations
* A.2 Shift operations
* A.3 Bit subfields
* A.4 Bit testing

## Chapter 1 Introduction

The purpose of this report is to define the conventions to be used in all FORTRAN programs which make up the portable applications software for ATLAS. Any code should compile without any errors or warnings.

The note is based on the following documents:

* Fortran Coding Conventions (DD/US/3)
* Fortran 77 Programming Conventions for ALEPH (ALEPH Note 136)
* Fortran 77 Programming Conventions for the UA2 Upgrade (p-pbar note 484)

The rules have been classified as either:

* essential for portability or
* good programming style for readability

## Chapter 2 FORTRAN standards

The current FORTRAN standard is FORTRAN 90. ATLAS continues to use the previous standard (FORTRAN 77) for the immediate future, as compilers are not yet available on all platforms. Some FORTRAN 90 features are already generally available as extensions in current compilers and we make use of this (small) number of extensions.

Certain FORTRAN 77 features are obsolescent in FORTRAN 90 (will disappear from the language in a later revision) and hence should be avoided: _[MANDATORY]_

* arithmetic-IF
* branching to an END IF from outside it's block
* real and double precision DO variables and control expressions
* shared DO termination, and DO termination on a statement other than on a CONTINUE or an END DO statement
* ASSIGN and the assigned GO TO
* alternate RETURN
* PAUSE
* assigned FORMAT specifics

## Chapter 3 Conventions

### 3.1 Code management

Our standard code manager is CMZ.

1. Each deck should contain only 1 subroutine or function. _[MANDATORY]_
2. Each common deck should contain only 1 common. _[MANDATORY]_
3. A deck should have the same name as the subroutine or function. _[MANDATORY]_
4. A common deck should have the same name as the common. _[MANDATORY]_
5. COMMON sequences should be inserted into the code with +CDE, other sequences with +SEQ. _[MANDATORY]_
6. Sequences should be contained between comment lines to clearly indicate the start and end of the sequence. _[RECOMMENDED]_

All commons are stored in patch XXXCDES.

### 3.2 Statement Syntax and Layout

1. Use only the standard character set, apart from the exceptions mentioned here. _[MANDATORY]_

The only permitted special characters are:,': = +. * / ( ) $

! - " _[Common Fortran 77 extension]_

Lower case characters are allowed. _[Common Fortran 77 extension]_

2. Do not use the currency symbol $ in a name. _[MANDATORY]_

3. If a statement consists of an initial line and one or more continuation lines, no line but the last should appear to terminate the statement legally. (For example, all lines but the last should terminate in an operator or comma). _[MANDATORY]_

4. Do not split a name between two lines. _[MANDATORY]_5. Do not use FORTRAN key-words as symbolic names. _[MANDATORY]_
6. Do not imbed blanks within names, constants, or keywords. _[MANDATORY]_
7. Syntactic entities not already separated by separator characters should be separated by one or more blanks. For example, the following keywords should always be followed by a blank: DO, GO TO, CALL, SUBROUTINE, FUNCTION, EXTERNAL. _[MANDATORY]_
8. Do not use any non-blank characters in columns 1-5 of a continuation line. _[MANDATORY]_
9. Do not use any other source format than the standard f77 one (1-5: label, 6: continuation, 7-72: statement). _[MANDATORY]_
10. Do not write more than one statement per line. _[MANDATORY]_

### Comments

1. Use in-line comments (following an exclamation mark! not in column 1). _[RECOMMENDED]_
2. Use the letter!, C or * in column 1 of standard comment lines. _[RECOMMENDED]_
3. Do not insert comment lines between program units. _[MANDATORY]_
4. Comments should be clearly distinguishable from code. The text of comments should be indented with respect to nearby code. _[RECOMMENDED]_
5. Comments should be useful and concise, containing only information not already obvious from the code. Empty comments, rows of asterisks, or boxes (but NOT blank lines) may be used to separate major portions of code or highlight important statements, but should be used sparingly to avoid filling up terminal screens. _[RECOMMENDED]_

### Program Units, Subprograms

1. Main programs should always begin with the statement: PROGRAM name which should have no associated parameter list. _[MANDATORY]_
2. Each subprogram should begin with a few lines of comments explaining the purpose of the routine, the source (author, references, date), and definition of formal parameters. Explanation of expected input, output, tables/banks filled, used or modified, and special non-standard features should also be indicated. New routines should be created within CMZ, in which case a template is used to create a standard routine header. _[MANDATORY]_
3. Declare in an EXTERNAL statement all external functions (that is, all functions which are not standard intrinsic functions). _[MANDATORY]_
4. Do not define external functions having the same name as standard intrinsic functions. _[MANDATORY]_5. Note that the values returned by the'standard' intrinsic functions CHAR and ICHAR are processor-dependent. Since this is likely to lead to a portability problem, the CERN Program Library routines CHTOI and ITOCH should be used. These functions are based on a portable look-up table which produces the same results on all computers. _[RECOMMENDED]_
6. FUNCTIONS should not alter any of their arguments, nor any COMMON variable, nor perform I/O nor have any other side-effect. _[RECOMMENDED]_
7. Statement functions should be contained between comment lines in a manner which makes clear that they are not the first executable statements. _[MANDATORY]_
8. The names of formal parameters of statement functions should not occur elsewhere in the same subprogram. _[MANDATORY]_
9. Do not use ENTRY statements. _[MANDATORY]_
10. Use the SAVE declaration where an entity with an initial value that might be changed is to be reused with the new value. _[MANDATORY]_
11. The arguments in a list should normally be ordered: input, output, input/output, external names. _[RECOMMENDED]_
12. Use the asterisk(*) notation to declare the length of character variables passed as arguments if their length is unknown to the called routine. _[MANDATORY]_
13. Program units (subroutines) should be short enough to be easily understood. With a very few exceptions where efficiency is critical, the maximum length should be 100 lines of executable statements, 200 lines total. _[RECOMMENDED]_
14. A subprogram should not contain references to COMMON blocks which are not required in that subprogram. _[MANDATORY]_
15. Do not pass as argument any variable which is contained in a COMMON block referenced by both the calling and the called routines, if the argument appears on the left-hand side of an assignment in the called routine. _[MANDATORY]_
16. Use only those intrinsic functions which appear in the standard (and are indicated as such in most compiler manuals), and use generic functions wherever possible. e.g., use LOG, not ALOG or DLOG; use MIN, not AMIN1, etc.. _[MANDATORY]_

### Order of Statements

2. Make as much use as possible of symbolic constants (PARAMETER statement) for true constants. _[RECOMMENDED]_
3. Do not initialize variables of one type with values of another (except possibly a single-precision floating-point variable with a double precision constant, to allow easy type promotion). _[RECOMMENDED]_
4. Use only the standard form of the PARAMETTER statement: PARAMETTER (PI=2./7.,ONE=1.0) in particular, do not place function calls (other than those which return INTEGER, LOGICAL or CHARACTER) inside constant expressions in PARAMETTER statements. _[MANDATORY]_

### Control Statements

1. DO-loop control parameters should be of type INTEGER only. _[MANDATORY]_
2. Apart from simple one-statement loops, each DO-loop should terminate on a separate CONTINUE or END DO statement. _[RECOMMENDED]_
3. The STOP statement is not necessary in the main program. If a STOP statement is necessary anywhere else it should always be immediately preceded by an unconditional write statement giving the reason for termination and the routine name. _[MANDATORY]_
4. Do not use backward jumps. _[RECOMMENDED]_
5. Avoid all jumps wherever possible. _[RECOMMENDED]_
6. Do not use non-standard control constructs such as UNTL. _[MANDATORY]_ DO WHILE, END DO are allowed _[Common Fortran 77 extension]_
7. Do not pass control into a DO-loop, IF-block or ELSE-clause other than by the normal initial statement. _[MANDATORY]_

### Specification Statements and Data Types

1. Place COMPLEX and DOUBLE PRECISION variables at the beginning of any COMMON block in which they appear. _[MANDATORY]_
2. A COMMON statement should define only one COMMON block; a COMMON block should be defined in a single COMMON statement. _[MANDATORY]_
3. The name of a COMMON block should normally not occur otherwise as a name in any subprogram in which it is referenced. _[RECOMMENDED]_ However, in the special case of the window commons, the first variable in the common is the name of the common block.
4. COMMON blocks should be kept in +KEEP sequences and inserted in the necessary subprograms using +CDE. _[MANDATORY]_5. The dimensions of COMMON arrays should be in the COMMON declarations themselves, and should be defined as often as possible in terms of symbolic constants specified in PARAMETTER statements which are grouped together with the COMMON blocks to which they refer. _[MANDATORY]_
6. Do not mix variables of type CHARACTER with variables of other types in COMMON blocks. _[MANDATORY]_
7. The use of EQUIVALENCE statements should be minimised. Where EQUIVALENCE statements are used, they should be grouped with the array declarations concerned. _[RECOMMENDED]_
8. Use only the standard data types, avoiding reduced and extended precision data types (e.g. INTEGER*2, LOGICAL*1) as well as binary, octal, hexadecimal and Hollerith, unless essential for the application. _[RECOMMENDED]_
9. Do not use the operators.EQ. and.NE. with floating-point expressions as operands. _[RECOMMENDED]_
10. Use the relational operators.LT.,.LE.,.GT., and.GE. to compare character strings only if they are of equal length and composed of either all letters or all digits. In all other cases use the intrinsic functions LLT, LLE, LGT and LGE. _[MANDATORY]_
11. Do not use any other logical operator than the standard.NOT.,.AND.,.OR.,.EQV. and.NEQV., nor any abbreviated form. Do not use these operators on operands of any type other than LOGICAL. _[MANDATORY]_
12. Do not use abbreviations for.TRUE. and.FALSE. _[MANDATORY]_
13. Ensure strong typing by specifying IMPLICIT NONE _.[Common Fortran 77 extension] [MANDATORY]_
14. Do not compare arithmetic expressions of different types. _[MANDATORY]_
15. In mixed-mode expressions and assignments, the type conversions should be written explicitly. _[RECOMMENDED]_

### Input/Output

1. Logical unit numbers should be symbolic constants, or variables; they should never be asterisks(*). _[MANDATORY]_
2. Do not make use of any numerical value of the IOSTAT parameter; use only whether it is zero or non-zero. _[MANDATORY]_
3. I/O statements on external files should contain the error recovery parameters ERR=, END=, IOSTAT=, as appropriate. _[MANDATORY]_
4. Do not use non-standard I/O statements such as ENCODE/DECODE (use internal files), DEFINE FILE (use OPEN), NAMELIST, PUNCH, BUFFER IN/BUFFER OUT and other asynchronous operations, nor any non-standard parameters. _[MANDATORY]_
5. Use WRITE rather than PRINT statements. _[MANDATORY]_6. Do not use the H edit descriptor. _[MANDATORY]_
7. If a format specification is stored in an array, the array should be of type CHARACTER. _[MANDATORY]_
8. Format specifiers should always be separated by a comma, a slash, or a colon. _[MANDATORY]_

## Chapter 4 Naming and Numbering Conventions

### 4.1 Numbering conventions

1. Statement numbers should be in ascending order. _[MANDATORY]_
2. END statements should not bear a statement label.

### 4.2 Naming conventions for variables

1. Variable names may be up to 31 characters in length.
2. All variables in COMMON must have at least 6-letter names. _[MANDATORY]_
3. Use mnemonic names. _[RECOMMENDED]_

### 4.3 Naming conventions for variables subroutines and banks

Modules should have 6-letter names, other subroutines may have up to 7-letter names. The name of a common may have up to 7 letters. Bank names are restricted by ZEBRA to 4 letters.

First letter.

The first letter indicates the subsystem or general package:

A General ATLAS

U Utility package

T Trigger

V Vertex

I Inner detector

C Calorimetry

M Muon system

etc.

The second letter may stand for a part of the subsystem, for example

CE Calorimeter ElectromagneticCH Calorimeter Hadronic

CC Calorimeter Combined (em + had)

Choose B for the Barrel part of a subdetector and E for the Endcap part.

Some letters are reserved:

Z ZEBRA

xZ ZEBRA (2nd letter Z)

G GEANT

XG routine of subsystem x in context of GEANT

S SLUG

## Appendix A Bit and byte handling

It is recommended to use the BITPAK package (CERN library M441) for machine independent bit and byte handling. BITPAK handles bits and bytes in a single word, with bit zero being the least significant bit.

It consists of the following subprograms :

Functions : IOR, IAND, NOT, IEOR, ISHFT, ISHFTC, IBITS,

 BTEST, IBSET, IBCLR

Subroutines : MVBITS

A numeric storage unit is considered to consist of a string of bits numbered from right to left, starting at zero. The standard defines II bit manipulation functions on such units, 8 of which are the ANSI/ISA functions found as intrinsic functions in many compilers. This package complements the functions available in compilers, ensuring that the full range is available on all machines. This description includes all the functions for the sake of completeness.

### Logical operations

* Function reference IOR(m,n) provides the inclusive OR of the two integer arguments.
* Function reference IAND(m,n) provides the logical AND of the two integer arguments.
* Function reference NOT(m) provides the logical complement of the integer argument.
* Function reference IEOR(m,n) provides the exclusive OR of the two integer arguments.

### Shift operations

A shift count k specifies

 a left shift for k>0

 no shift for k=0

 a right shift for k<0

Function reference ISHIFT(m,k) provides the value of the integer argument m with the bits shifted. Bits shifted out to the left or right are lost, and zeros are shifted in from the opposite end.

* Function reference ISHFTC(m,k,ic) provides the value of the integer argument m with the rightmost ic bits shifted, and the remaining bits untouched. The shift is circular; no bits are lost.

### Bit subfields

* Function reference IBITS(m,i,len) provides, right justified, the value of the len bits of the integer argument m, starting from position i.
* Subroutine reference CALL MVBITS(m,i,len,n,j) moves len bits of integer argument m, starting at position i, to the integer argument n, starting at position j. All other bits of n are left untouched. The arguments m and n may refer to the same numeric storage unit.

### Bit testing

* Function reference BTEST(n,i) has the value.TRUE. if bit i of the integer argument n is set, and.FALSE. otherwise. Note: many compilers require BTEST to be declared type LOGICAL.
* Function reference IBSET(n,i) has the value of the integer argument n with bit i set to 1.
* Function reference IBCLR(n,i) has the value of the integer argument n with bit i cleared to 0.

Notes: If bits are specified outside the range of one numeric storage unit, or if fields are specified which are longer than one numeric storage unit or zero, or if shifts are specified which are longer than the fields being shifted, then the results are undefined.