**ATLAS Internal Note**

**SOFT-NO-013**

**30 June 1994**

PART 1

**GENZ - Generated Event Handling using Zebra**

**GENZ**

Users' Guide

Version 2.00

June 30, 1994

Robert DeWolf

Cavendish Laboratory

Cambridge, UKTable of Contents

* 1 Introduction
	* 1.1 What Does GENZ Record?
	* 1.2 How is GENZ Used?
	* 1.3 Units and Conventions
	* 1.4 Availability
* 2 Zebra Bank Formats
	* 2.1 GENZ Banks
		* 2.1.1 A Note on "Event" and Run Numbers
		* 2.1.2 GENE Bank
		* 2.1.3 GENP Bank
		* 2.1.4 GENR Bank
	* 2.2 Top Level Banks.
		* 2.2.1 EVNT Bank
		* 2.2.2 RUNNT Bank
		* 2.2.3 PASS Bank
	* 2.3 Link Sets
* 3 GENZ Zebra Organization
	* 3.1 Using GENZ Independently of a User's Zebra Store
	* 3.2 Using GENZ within a User's Zebra Store
* 4 Subroutine Calls
	* 4.1 Basic GENZ Calls
		* 4.1.1 GNZINIT. Initialize GENZ
		* 4.1.2 GNZOPEN. Open a GENZ Input or Output Stream
		* 4.1.3 GNZREAD. Read a GENZ Event from the Primary Stream
		* 4.1.4 GNZWRIT. Write out a GENZ Event
		* 4.1.5 GNZPRIN. Print Current Event
		* 4.1.6 GNZEND. Close GENZ I/O and Zebra packages.
	* 4.2 Setting and Printing GENZ Parameters
		* 4.2.1 GNZPARI. Set Integer Parameters
		* 4.2.2 GNZPARR. Set Real Parameters
		* 4.2.3 GNZPARC. Set Character Parameter
		* 4.2.4 GNZPPAR. Print GENZ Parameter
	* 4.3 HEPEVT Conversion Calls
		* 4.3.1 GNZPFRC. HEPEVT to GENZ Conversion
		* 4.3.2 GNZPOHC. GENZ to HEPEVT Conversion
	* 4.4 Specifying the GENZ Zebra Store
		* 4.4.1 GNZPSTOR. Declare User's Zebra Store to GENZ
		* 4.4.2 GNZLINK. Declare a User's Link
	* 4.5 Routines to Handle Events on Secondary Stream
		* 4.5.1 GNZBACK. Read an Event from Secondary Stream
		* 4.5.2 GNZPILE. Add Events to Primary Links from Secondary Links
		* 4.5.3 GNZSHUN. Shunt an Event to Primary Tree from Secondary Tree
	* 4.6 Data Access Routines
		* 4.6.1 GNZGETD. Get Daughter Information
		* 4.6.2 GNZGETE. Get Event Information
		* 4.6.3 GNZGETG. Get Gate Information
		* 4.6.4 GNZGETP. Get Particle Information
		* 4.6.5 GNZGETR. Get Run Information
		* 4.6.6 GNZGETV. Get vertex information
		* 4.6.7 GNZGETBC. Get top level bank contents
	* 4.7 Data Entry Routines
		* 4.7.1 GNZEVNT. Book new EVNT Bank
		* 4.7.2 GNZRUNT. Book new RUNT Bank
		* 4.7.3 GNZDROP. Drop a GENZ bank
		* 4.7.4 GNZNEWE. Book a new GENE bank
		* 4.7.5 GNZMODE. Modify an event bank
		* 4.7.6 GNZNEWR. Book a new GENR bank
4.7.7 GNZNEWP. Add a new particle record to a GENP bank
31
4.7.8 GNZXREF. Set cross-reference value to non-GENZ package
32
4.7.9 GNZKILP. Kill particle IP and/or its descendents
4.7.10 GNZCHKM. Check mother pointers in desired event
33
4.7.11 GNZSETBC. Set top level bank contents
4.8 Magnetic Field Utilities
4.8.1 GNZSTEP. Step a particle (in vacuo) in uniform magnetic field.
4.8.2 GNZGROT. Get Rotation matrix for rotation about given axis.
4.8.3 GNZROTA. Perform rotation on vector
4.9 Other Utilities
4.9.1 GNZLOOP. Loop over particles in an event, calling user routine
4.9.2 GNZSHUT. Close an Individual I/O Channel
4.9.3 UGNZFILT. User filter for Zebra I/O Headers
4.10 Deprecated Subroutines
4.10.1 GNZCLOS. Close I/O streams. (DEPRECTATED ROUTINE)
4.10.2 GNZSETIP/GNZSETI. Set Integer Parameter
4.10.3 GNZSETRP/GNZSETR. Set Real Parameter
4.10.4 GNZSETCP/GNZSETC. Set Character Parameter
5 GENZ Input and Output
5.1 FZ Format
5.2 GENZ FZ I/O Record Organization
5.3 FZ User Header Vector
6 Examples of Programs using GENZ
6.1 HEPEVT - GENZ Translation. Simplest Case
6.2 HEPEVT - GENZ Translation using User's Zebra Store
6.3 Using GENZ's Data Entry Routines to Build Events
6.4 Read GENZ Events
6.5 Read GENZ Events and Translate to HEPEVT
6.6 Read GENZ Events from Two Streams, Combine, and Output6.7 Read GENZ Events and Display Simple Graphics using HIGZ
* 7 GENZ Internal Flags
* 7.1 Run Information Control Flags

## Chapter 1: Introduction

GENZ is a package for the handling of the events, sets of particles and partons, as output by physics event generators. There are potentially conflicting demands put on the format used to handle this data. Generator events can be very large, demanding a compact format and an efficient management of memory. Yet the particle data, identities, 4-momenta, vertex position, etc., as well as the relational information between particles, must be readily available. Furthermore, such data must be readily stored and transferred between computing platforms.

GENZ uses the Zebra package [1] to perform its memory management and input/output. The data structures defined within GENZ are intended to become standard formats, hopefully to be used "as is" in other standard packages and in experiments' own software. Thus, the bank format aspect of GENZ may be of greater scope that the GENZ package itself, since GENZ cannot hope to cover all users' needs in terms of event manipulation.

One of the original motivations for GENZ is to provide a means of reading and writing generator events stored in the HEPEVT common block [2], using a format that is as machine-independent as possible. This is perhaps a necessary condition for GENZ to be an acceptable backward-compatible standard for High Energy Physics. The move to Zebra, however, provides more than this. GENZ allows

* transportablity of the data between machines via Zebra "tranfer" formats,
* memory management of the generator data (in contrast to the fixed-length arrays in HEPEVT),
* extension to multiple events in one gate using a Zebra linear structure.

A longer term view, and probably the view that should guide difficult decisions, is that GENZ should become a standard way of writing out events from event generators and reading them in to packages such as GEANT. For this reason, where extra information has been considered likely to be useful, a place has been found for it in GENZ, even if that data is not stored in the HEPEVT data structure.

### 1.1 What Does GENZ Record?

GENZ banks have been designed to carry information about particles and partons involved in particle physics interactions, as produced by event generators. Usually there is one primary interaction between two interacting incoming particles or partons in an event. The remainder of the particles or partons are outgoing; intermediate short lived states may be retained or not according to requirements. Furthermore, it may be advantageous to treat some unstable particles as stable by not storing any decay products for them. Thus, the particles stored in a generator banks may vary considerably. Usually, however, a clear distinction is desired between the process of event generation and the immediate decay of the products, and the subsequent interaction of particles with a specific experimental apparatus. GENZ banks, therefore, are expected only to represent the state of the event up to any possible interaction with a detector.

The identity, momenta and mass of the particles are obvious intrinsic data that one wants to have for each particle in the event. The status word, ISTHEP, from the HEPEVT standard, which says whether a particle is stable or unstable,(or perhaps not a particle at all - to allow for other data in the HEPEVT structure), has been recorded as well for backward compatibility.

Relational information is also stored. Each particle may store one or two pointers to mother particles. If the second such mother pointer is negative, the absolute values of the two pointers are taken to give arange of mothers. With this system, that maximum generality of combination and decay process can be described without listing all mother or daughter relationships.

Vertex information for particles output by generators is often not necessary, with many particles starting at the original interaction, i.e., most start distances relative to the primary interaction would be essentially null. On the other hand, in certain specific cases, vertex information is crucial. A further demand is for the vertex information to be able to be recalculated in the presence of a magnetic field. In order to economize on memory, but retain the essential vertex information, the start time relative to the primary interaction in the lab frame has been recorded in the GENZ banks.

The GENZ package provides tools for the reconstruction of information not explicitly stored in its data structures. Two examples relevant to the last two paragraphs can be given: For instance, a subroutine is provided that returns a list of all the daughters of a given particle. Another subroutine can be called to return the start point of a given particle relative to the primary interaction, optionally taking account of the effects of a (uniform) magnetic field.

Besides the particle information itself, separate banks exist in GENZ for the storage of global event information such as primary interaction position and time, and generator name. Further banks exist to mark start of runs and give global run information, e.g., version of software used.

The formats of the GENZ banks have been designed following the Standard Logical Analysis Chains (SLAC) proposals[3]. These guidelines guarantee that bank formats are extendable to include further information.

For more information, see chapter 2 which describes the format of the Zebra banks used in GENZ.

### 1.2 How is GENZ Used?

GENZ is used as a slave package to another Fortran program. It can be used at several levels of complexity. For simple use, GENZ hides from the user all of its Zebra work, the user only having to reserve sufficient memory for the GENZ event storage. In the simplest case of translation to or from HEPEVT, single user calls to GENZ routines do the work. GENZ provides an event dumping utility for listing the current event to the standard output. Various parameters of the GENZ package such as Fortran I/O streams, Zebra I/O formats, and print levels can be controlled by calls to GENZ utility routines, GNZPARI,GNZPARR, and GNZPARC.

The following is an outline of a program to generate events, translate to GENZ and then write them out:

PROGRAM HEPOUT

...

C HEPEVT common block

COMMON/HEPEVT/....

C GENZ common block

COMMON/GNCSTO/MYMEMO(50000)

...

C Set run number to 50

GNZPARI(1,'RUN',50)

...

GNZINIT(50000)

C Set output stream to 23 and open:

GNZOPEN(23,'OUTP','genzout.dat')

### Units and Conventions

DO 1 to NHEP

...

C generate HEPEVT using generator package:

CALL generator

...

C Translate to GENZ banks from HEPEVT Common to primary event link:

CALL GNZFRHC(IRET)

...

C Print out event on primary event link with verbosity level LEVL

CALL GNZPRIN(1,LEVL)

C and then write out:

CALL GNZWRIT(IRET)

...

ENDDO

...

CALL GWZEND

END

GENZ is also adaptible to more complex uses, for instance, when the user already has his own Zebra store declared and wishes the GENZ banks to be stored there. Such alternate ways to set up the memory management of GENZ are described in the chapter "GENZ Zebra Organization".

A number of subroutines are provided to allow the use of GENZ without any reference to HEPEVT. These routines can be used to extract data from, or to feed event data into GENZ banks. Thus GENZ can be a tool for the writer of Monte Carlos and for the author of generator event analysis routines.

A number of example programs are supplied in chapter "Examples of Programs using GENZ".

Finally, GENZ banks may be manipulated directly in user-written subprograms, preferably where the CMZ sequences defined in the GENZ source library have been used. This may be desirable in cases where high run-time efficiency is needed, avoiding the overheads associated with the supplied data access tools.

### Units and Conventions

SI units have been chosen throughout, except for momentum and mass, where GeV/c and GeV/c 2 are used. No loss of precision results from this choice. Particle codes used are those recommended by the Particle Data Group [4].

### Availability

It is foreseen to include GENZ in CERNLIB when it reaches a stable state. Currently, GENZ source code and documentation are to be found in the file GENZ CMZ on PUBZP 197 on CERNVM. A library of compiled routines, GENZ TXTLIB, can be found on the same disk.

Documentation is found in the Patch GENZDOC of the GENZ CMZ library. This manual can be printed according to instructions in GENZDOC/README.

Install scripts for various machines are to be found in $KUMACS/INSTALL.

## Chapter 2: Zebra Bank Formats

### GENZ Banks

The banks for the GENZ package have been designed in coordination with an initiative to standardize bank organization for HEP, the "SLAC" proposals[3]. In this scheme, the first three words of all banks are reserved for by the system. In the case of the GENZ banks, with no extensions to carry further information such as helicity or colour, the words take on simple interpretations: the first word gives format information, given a value 1 for this version; the second indicates whether the bank is individual or collective (modular), and gives the number of entries in the latter case; the third gives the modularity.

Readers are invited to look up the SLAC proposal for the general definition of these words. It suffices to say that by using the higher decimal places of the integers in the system word (\(>\)10000), the repeat blocks can be made to include references to data in additional banks in a very general way. Such non-trivial use of the SLAC system is planned in future for the optional storage of additional particle information.

#### A Note on "Event" and Run Numbers

In the bank descriptions below, there will be several types of event or gate numbers referred to. The distinctions that will be made between the types are based upon a certain picture of how events will be manipulated in a full scale experiment; for simpler uses, these distinctions may be irrelevant.

The first type of event number is really an experimental gate number, and is referred below as such. This number is that recommended to be stored in the EVNT data structure. Since the EVNT bank in GENZ is just a notional top level bank, the format below is just a suggestion for the first few words of such a bank. In any case, the gate number there is in most cases a sequentially incrementing number. After the simulation stage of event processing, and the application of a simulated trigger, this number might be over-written by a trigger number. At this point, the trigger number should simulate the behaviour of a trigger number from real data. Similarly, the run number stored in the RUNT and EVNT banks becomes significant during detector simulation because at that point it would determine which run (i.e. which part of the experimental running period) to base calibration constants on. To conclude, the run and event numbers in the RUNT and EVNT banks gain increasing significance as the events are simulated towards imitation raw data. Over-writing of these numbers may be performed to make a pre-generated event conform to simulation needs.

In GENZ, the values written to the EVNT and RUNT bank are chosen to allow the user to identify GENZ output as "raw" generator output. The run number in the RUNT and EVNT bank is set to zero. The event number just increments from 1. (Users who want to write their own values in these banks can use GNZSETBC - set bank contents.)

The second type of event number is the "generator event number". This is a number that is assigned at event generation time (from NEVHEP for HEPEVT translation; from calls to GN2NEWE in GENZ utility event building). It, together with the generator name, run number and generator job ID (plus any database information that may be keyed by these quantities), should record the process of the generation of that particular event for future reference. Thus, this number is preserved in all manipulations of GENZ events.

The final event number referred to is the "event ID within gate". This is merely a numbering, starting at 1 for each new gate, of the events that occur within the experimental gate. In GENZ, the convention is to store this number in the ZEBRA IDN of the GENE bank.

### GENZ Banks

#### GENE Bank

The unit of data at the event level is the GENE bank. The format for GENE banks is given in TableGENE banks can be attached together in a linear structure to represent the interactions in a gate. Each bank contains global information relevant to that event: the run number and event number from the generator that produced the event, the generator name, the vertex position and time, and event weight information.

#### GENP Bank

The particle information for an event is stored in a GENP bank, found at the second structural link down from each GENE bank. TableThe data format has been chosen to be as compact as possible in order to store the very large LHC particle multiplicities, but also to maintain utility and efficiency.

The requirement of compactness and a few other considerations, have resulted in a different set of conventions from HEPEVT, and not only in the reduction of the number of words per particle. For instance, the decision to record the two mother pointers (and not two daughters) removes the redundancy and the potential for inconsistency present in the HEPEVT common block. It also frees GENZ from the convention of maintaining daughters in order in the bank, allowing the addition or removal of extra daughters without too much difficulty.

As a final extension in generality, the convention has been adopted that a negative second mother pointer denotes that there is a range of mother particles: from the particle pointed to by the first mother to the particle pointed to by the absolute value of the second. It is clear that this system gives the maximum flexibility possible with two available words. The only illegal ordering is that of a dispersed

[MISSING_PAGE_FAIL:11]

### Top Level Banks.

range of mothers. The next least likely scenario, that of having a range of mothers at all, is indicated by the one non-natural convention (the negative second mother rule.

It was granted that one more reference pointer was necessary in order to allow relatively quick retrieval of the end time of the particle and to allow cross-referencing into other packages. The index of the first daughter is therefore stored for unstable particles (0 for stable particles). When GENZ is interfaced to other packages (for instance GEANT), this word should be re-written as the negative of the cross-reference datum ( -ITRA in the GEANT case).

The particle status word is defined as in HEPEVT. Particle identity is given by the standard Particle Data Group code[4]. Pointers within the bank, i.e. the two mother pointers and the first daughter pointer when it is positive, refer to the repeat block number. For instance, if the first mother pointer is \(I\), then the position of the mother's status word is given by \(modularity\times(I-1)+3+1\). As in HEPEVT, The second mother pointer is zero if there is only one mother. Two non-zero mothers does not imply a range of mothers, unless the second is negative. A first daughter pointer \(\leq 0\) denotes a stable particle with respect to the generator; a negative value indicates a cross-reference into another package.

Vertex information relative to the interaction point is largely zero in HEPEVT and has therefore not been included in the GENP banks except for its time component. The utility routine GNZGETV can be used to reconstruct the vertex position from the time.

The mass (not necessarily the on-shell mass) has been included in the GENP bank rather than the energy. This is to give the orthogonal components (in a Euclidean sense) of the particle's dynamics and thus the maximum precision.

#### GENR Bank

Run information is stored in a GENR bank. The format for GENR banks is given in TableMany of the global quantities that should be recorded for a job are found here, such as time and date of run, machine, and versions of the packages used.

### Top Level Banks.

The banks filled by GENZ must be able to travel through the chain of simulation and analysis, carrying the original interaction information. Since the generator is the starting point for this chain of processes, it is proposed that GENZ generate structures as described by the SLAC initiative [3].

#### EVNT Bank

A top level bank called EVNT carries all the event information. The bank format is given in TableAfter the link for the PASS banks (which carry history of the event processing - see Sectionthe next link is used to suspend the GENE linear structure. The entire structure for an event (at the generator stage) is depicted in FigureThis structure is written by the GENZ package every event and is the structure expected to be encountered during a read.

#### RUNT Bank

Though not part of the SLAC proposals, a RUNT bank is used in the GENZ package to suspend the GENR bank. The format used by GENZ for the RUNT bank is given in TableSuch a setup may be

## Chapter 2 Zebra Bank Formats

### 2.2 Top Level Banks.

used as a starting point for experiments to carry other long-term information, though the variability of experimental needs in this regard make the RUNT banks standardization somewhat less likely than that for EVNT. The banks output at run start are depicted in Figure

#### PASS Bank

PASS banks are designed to carry the history of the EVNT tree through its processing stages by the accumulation of a linear structure; each process add/ another PASS bank to the linear structure recording the relevant parameters of that process, the most important being the JobID. TableGENZ.

GENZ constructs PASS banks at link -1 of EVNT banks, the data written for a simple generator job are JobID of the process, the JobID repeated (the JobID of the process that generated this event), and the IDN of the GENE bank added in that run (usually 1). For more complex jobs, for instance one where events are being generated at IDN = 1, and other events are being read in an placed in the same gate, the PASS bank will have a non-trivial structure, with a repeat unit for each GENE bank present, giving the JobID of the generator job of origin and the position in the GENE linear structure.

Since PASS banks should be created at each analysis pass on the data, or perhaps at each logically separate "processor" step, the format flag plays an important role in identifying the type of data stored. The format flag value 1 is used by GENZ for processes which generate events.

Figure 2.1: Event banks

Figure 2.2: Banks written out at start of run

[MISSING_PAGE_EMPTY:15]

### Link Sets

The top-level banks described above, EVNT and RUNT, are pointed to in memory by link variables, which, depending on how GENZ has been invoked, reside either in GENZ's or a user's common block. GENZ (via Zebra) manages two such link variables for each bank type in order to allow the reading in of events on two independent input streams. The two pairs of links are refered to as the "primary" and "secondary" link set. In most cases events simulating potential physics triggers will be read in to the primary link set, while the background events will be read in to the secondary set.

Many user subroutines require the link set number in order to specify which data structures are to be refered to. The link set specific should be given as 1 for the primary and 2 for the secondary link set.

## Chapter 3: GENZebra Organization

The organization of Zebra within GENZ can be done in two ways. In the first, typically in the case of "naive" usage of GENZ, GENZ declares and uses its own Zebra store to manage the data structures. In the second case, GENZ can be intructed to use a Zebra store declared by the user or by another application.

### Using GENZ Independently of a User's Zebra Store

This way of using GENZ almost completely hides Zebra from the user. Except for supplying a suitably large appropriately named common block and declaring its size to GENZ, he need know nothing about the Zebra package.

The user must have the common block / GNCSTO/ in his program. This must be declared to contain an arbitarily named array that is long enough to accomodate the maximum amount of data expected to be held by GENZ as particle information at any one time. When GNZINIT is called, the absolute value of its argument will be taken by GENZ to be the desired length of the store.

GNZINIT declares its own permanent structural links to support the top level banks, RUNT and EVNT. Each type of bank is given two link variables, so that there are two sets of links. One set, the primary link set, is used for most purposes - most event reading, translation and manipulation, and all event output. The other set, the secondary link set, is used for reading in events on a second input stream for adding on the the events in the primary link set.

In the simplest case, the initialization sequence for GENZ is as follows:

 PROGRAM MAIN .  COMMON/GNCSTO/YNMEMO(50000) .  ( Calls to GNZPARI,GNZPARC,GNZPARG go here ) .  GZINIT(50000)  GZOPEN(30,'INP1','genzin.dat')  GZOPEN(31,'OUTPUT','genzout.dat')

In the case where another package is also using Zebra and has been called before GNZINIT, one wants to avoid the re-initialization of Zebra when GNZINIT is called. GNZINIT must be called with a negative argument in order to prevent this. This is, in fact, the same convention used by HBOOK. For instance, both

 COMMON/PAWC/MEMPAW(70000)  COMMON/GNCSTO/YNMEMO(50000) .  CALL HLINIT(70000) .  GZINIT(-50000)  GZOPEN(30,'INP1','genzin.dat')  GZOPEN(31,'OUTPUT','genzout.dat')

### Using GENZ within a User's Zebra Store

and

 COMMON/PAWC/MEMPAW(70000)

 COMMON/GNCSTO/MYMEMO(50000)

 GNZINIT(50000)

 GNZOPEN(30,'INP1','genzin.dat')

 GNZOPEN(31,'OUTPUT','genzout.dat')

 CALL HLMIT(-70000)

are valid initializations of HBOOK and GENZ.

### Using GENZ within a User's Zebra Store

It is expected that one class of GENZ user will be experiments that will will read and write GENZ using large programs that have their own Zebra store and link organisation. In this case, the user must _first_ tell GENZ that he wants to use his own store. A call to GNZSTOR preforms this, giving to GENZ the number of the Zebra store used by the user, and its starting location. The GENZ common GNCSTO need not be declared in the user code in this case. In addition, the user must inform GENZ of the location of the link variables that he will use to store the RUNT and EVNT structures. GENZ will then be able to operate using the user's Zebra setup. The following code would tranfer the GENZ activities to the user's store:

 CALL GNZSTOR(MYSTOR,LQ(1))

 CALL GNZLINK('RUNT',1,MYDIVL,LKRUNT)

 CALL GNZLINK('EVENT',1,MYDIVS,LKEVNT)

 GNZINIT(0)

The two GNZLINK calls tell GENZ where to book the top level links 'RUNT' and 'EVENT' that support the GENZ run and event data structures. The second argument tells GENZ whether the link being given is for the primary or secondary link set, 1 and 2 respectively. Here, 1 is given for the links, so primary links are being declared.The divisions to which the data structures belong are also declared. Usually, the RUNT bank would be in a long-term division, here MYDIVL, while EVNT would be in a short term division, MYDIVS. Finally the user's link variable from the common block where he has declared his Zebra store is passed to GNZLINK.

GENZ demands that the primary and secondary links for the same bank structure (e.g., the two EVNT trees) must be in the same division. This is because GENZ must be allowed to perform ZSHUNT operations between the two structures. Failure to comply with this demand will produce warnings.

## Chapter 4: Subroutine Calls

### Basic GENZ Calls

The subroutine calls that are necessary or of interest to all users of GENZ are given here. With these, he should be able to set up GENZ, read and write events, and interface to HEPEVT. ( Most GENZ users will also want to change parameters and access information from GENZ, subjects of following sections.)

#### 4.1.1 Gnzinit. Initialize Genz

CALL Gnzinit(LENGN)

This subroutine _must_ be called in order initialize GENZ. It should be called, however, _after_ any calls to GNZPARI, GNZPARR, or GNZPARC that change Zebra parameters. Users who are using their own Zebra store (rather than using one set up by GENZ) must call GNZINIT after calls to GNZSTOR or GNZLINK. If Zebra has already been initialized (ie, by calls to HBOOK, KUINIT, etc.. or by the user), GNZINIT must be called with LENGN less than or equal to 0 in order to prevent re-initialization of Zebra. Unless GNZSTOR has been called, GNZINIT sets up a Zebra store and divisions for its banks. Finally, GNZINIT opens the I/O streams.

Input Parameters

LENGN Number of longwords in common block GNCSTO.

LENGN \(\leq\) 0, do not re-initialize ZEBRA.

If GENZ has been instructed not to use its own Zebra store by a call

to GNZSTOR, LENGN is not used.

#### 4.1.2 Gnzopen. Open a GENZ Input or Output Stream

CALL GnzOPEN(LUNIT,CSTRM,CFILE)

This subroutine must be called for each I/O stream that is to be used in the job. The routine calls the ZEBRA routine FZFILE. Other parameters to the FZFILE call can be changed from the default GENZ value by calling GNZPARC.

Input Parameters

LUNIT FORTRAN unit number for this stream

CSTRM 4-letter code for the I/O stream:

'INP1' - primary input stream

'INP2' - secondary (background) input stream

'OUTPUT' - output stream

CFILE Name of file to open

'' - Execute OPEN with no file name

#### 4.1.3 Gnzread. Read a GENZ Event from the Primary Stream

CALL Gnzread(IRET)

### Basic GENZ Calls

If IRET = 0 after this call, GENZ has successfully read an EVNT data structure. If GNZREAD encounters a RUNT data structure before finding and EVNT data structure, this is read in as well.

IRET is returned equal to the return code from the Zebra read (FZIN) as found in the Zebra array IQUEST(1). Because GENZ always writes out a Zebra Start-of-Run record before a RUNT bank, a call to GNZREAD returning IRET = 1 (Zebra Start-of-Run read) will always preceed the call that reads in a new RUNT bank.

EVNT or RUNT banks already existing will be dropped if new EVNT or RUNT data structures (respectively) are read in. Note that non-zero values of IRET do not cause the old banks to be dropped. For instance, a call returning with IRET = 1 (Zebra Start-of-Run) will leave the old RUNT bank (from the previous run) and the last EVNT bank in place. However, if the EVNT bank is in a short-term division (It is by default in GENZ.), and MZDROP(0) has been called by the user as part of his event loop, then the old EVNT bank will have been dropped already.

Output Parameters IRET FZIN return status from IQUEST(1) = 0 Normal completion

#### 4.1.4 GNZWRIT. Write out a GENZ Event

CALL GZWRIT(IRET)

The EVNT data structure on the primary link set is written out. If the run tree (RUNT) has not yet been written out for the run, a Zebra Start-of-Run record is first written and then the RUNT data structure followed by the EVNT data structure, in separate FZOUT calls.

IRET is returned equal to the return code from the Zebra write (FZOUT) as found in the Zebra array IQUEST(1).

Output Parameters IRET FZOUT return status from IQUEST(1) = 0 Normal completion

#### 4.1.5 GNZPRIN. Print Current Event

CALL GZPRIN(ILINK,LEVEL)

Print the contents of the current GENZ banks. The contents of the current GENE/GENP banks are printed in a nice format, making this a useful event dump utility. The contents of the GENR bank are printed if there has been a new run since the last GNZPRIN call This routine may be called before or after the call to GNZFRHC, or for a reading job, after the call to GNZREAD.

Input Parameters ILINK Link set print contents of = 1 Primary link set

## Chapter 4 Subroutine Calls

* 2 Secondary link set
* 1 no printing
* 1 gate and events summary
* 2 print all stable particles
* 3 print all particles
* 4 print all particles plus vertex information
* ditto -

#### 4.1.6 GNZEND. Close GENZ I/O and Zebra packages.

CALL GNZEND

This routine is used to close any open GENZ I/O streams and to produce a summary of GENZ activity. If the GENZ Zebra store is not owned by the user (i.e., if GNZSTOR has not been called), then GNZEND will call MZEND, closing down Zebra and printing its summary.

It is suggested, therefore, that if the user has initialized Zebra himself, he should call MZEND himself as well at the very end of his job after all calls to HBOOK or other CERN packages.

### 4.2 Setting and Printing GENZ Parameters

There exist a number of parameters within GENZ that the user may want to set with calls to GNZPARI, GNZPARR, or GNZPARC for integer, real and character parameters, respectively. These include things that the user will almost certainly want to set, such as the current run number and the generator name, to things he will not likely want to set, such as the ZEBRA logging levels.

#### 4.2.1 GNZPARI: Set Integer Parameters

CALL GNZPARI(NPAR,CHPAR,IVALU)

Set the integer parameter specified by CHPAR.

Input Parameters
* NPAR Number of parameters to set with this call
* CHPAR() CHARACTER*4 string array selecting the option(s) to set
* IVALU() Integer value to be set

The parameters that can be set with GNZPARI are as follow:

### Setting and Printing GENZ Parameters

Option Key Explanation Default Value 'NSTA' Number of standard words to write in GENP bank 10 'LEN1' Record length in longwords 8100 'LEN2' Record length in longwords 8100 'LENO' Record length in longwords 8100 'TERM' Fortran terminal output unit 6 'MZEB' Zebra logging level -1 'PLMZ' Print level for MZ 0 'PLFZ' Print level for FZ 0 'PLGN' Print level for GENZ 0 'RUNN' Run Number 'Jobid 'GAT0' Offset of Gate number (first gate number -1) 0 'JBID' Jobid 0 'UWRD' Number of user words in GENP banks 0 'GVER' Generator version number *100 0 'GDAT' Generator date (yymmdd) 0 Note that the parameter MZEB is only used if GENZ uses its own store (i.e., GNZSTOR is not called) and if GNZINIT is passed with a positive argument.

#### 4.2.2 GNZPARR. Set Real Parameters

CALL GNZPARR(NPAR,CHPAR,VALUE)

Set the real parameter specified by CHPAR to VALU.

Input Parameters NPAR Number of parameters to set with this call CHPAR() CHARACTER*4 string array selecting the option(s) to set VALU() Array of real values to be set

The parameters that can be set with GNZPARR are as follow:

Option Key Explanation Default Value 'TVMI' Minimum time in seconds relative to 1.0E-18 interaction recognised as separate vertex. 'BX' x-component of Magnetic Field in Tesla 0.0 'BY' y-component of Magnetic Field in Tesla 0.0 'BZ' z-component of Magnetic Field in Tesla 0.0 'BMIN' threshold field strength for calling field routines 0.0001

#### 4.2.3 GNZPARC. Set Character Parameter

CALL GNZPARC(NPAR,CHPAR,CVALU)

Set the character parameter specified by CHPAR to the value CVALU.

### 4.3.1 GNZFRHC.

#### 4.3.2 GNZTOHC. GENZ to HEPEVT Conversion

The GENZ has been set by the calling of GNZPARI(1,'RUNN',number)

### Specifying the GENZ Zebra Store

(or via an effectively similar call), and the RUNT tree exists, then the contents of the GENR bank will be transferred to the HEPEVT common block with NEVHEP = -1. Otherwise, if the EVNT tree exists, then the information in the first GENE bank is translated into HEPEVT.

Because the act of calling GNZTOHC when there is a new run turns off the "new run" flag, a second call to GNZTOHC, after a return when NEVHEP=-1, will return the contents of the EVNT tree into the HEPEVT common. This second call to GNZTOHC is necessary in order to see the first event of a run being read in as GENZ data. See the example program RDTOHEP in directory GENZEXAM to see exactly how this is done.

Output Parameters

IRET

Return status.

= 0

No error

= 1

No appropriate bank found

### Specifying the GENZ Zebra Store

The following routines are used to dictate to GENZ that its own Zebra store is not to be booked and that the user's store is to be used instead. By passing details of the user's store and the location of the top-level links that he is using to carry run and event data, GENZ can manipulate data in the user's store.

#### GNZSTOR. Declare User's Zebra Store to GENZ

CALL GNZSTOR(MYSTO,LQ)

GENZ is to use Zebra store MYSTO to record its data. Even though GENZ does not have a copy of the common block that the user has declared his store in, by looking at the location of LQ(1), GENZ can work out how to manipulate data in array LQ.

Input Parameters

MYSTO

ID of user program's store

LQ

Array in which the user program has its store

#### GNZLINK. Declare a User's Link

CALL GNZLINK(CBTOP,ILINK,IDIV,JLINK)

Data structure CBTOP in link set ILINK is declared to GENZ to be in division IDIV and is positioned at JLINK. JLINK must be a structural link variable in the link section of the user's Zebra store or a structural link in a permanent link area common block declared by the user with MZLINK.

Input Parameters

CBTOP
CHARACTER*4 variable or constant giving the name of the specified

### 4.5 Run data structure

The user must declare, by pairs of GNZLINK calls, both RUNT and EVNT links for a given link set. That is, he must declare both RUNT and EVNT link for the primary link set, and if he declares either for the secondary link set, he must declare both.

### 4.5 Routines to Handle Events on Secondary Stream

#### GNZBACK. Read an Event from Secondary Stream

CALL GNZBACK(IRET)

If on return, IRET = 0, then an EVNT data structure has been read from the secondary stream to the secondary links. RUNT structures may also have been read in if encountered before the next EVNT bank.

IRET is returned equal to the return code from the last Zebra read (FZIN) as found in the Zebra array IQUEST(1).

Output Parameters

IRET

FZIN return status from IQUEST(1)

= 0 Normal completion

#### GNZPILE. Add Events to Primary Links from Secondary Links

CALL GNZPILE(NPILE)

Tranfer NPILE GENE banks from the secondary EVNT tree to the primary EVNT tree. GNZBACK will be called if more events are needed on the secondary stream. Thus, GNZBACK need not be explicitly called by the user at all in the simplest case.

Input Parameters

NPILE

Number of GENE banks (events) to add to the GENE linear structure in

the primary EVNT structure

#### GNZSHUN. Shunt an Event to Primary Tree from Secondary Tree

CALL GNZSHUN(IDVAN,IDOLD,IDNEW)

### Data Access Routines

Tranfer a GENE bank with IDN of IDWAN from secondary EVNT tree to the primary EVNT tree. The former IDN of the moved GENE bank is returned in IDOLD. The new IDN of the moved GENE bank in the primary GENE linear structure is returned in IDNEW. IDOLD and IDNEW are returned as zero if no bank was shunted

GNZSHUN will book a new PASS bank on the primary tree if one has not been created by the current job. If a new PASS bank exists for the current job, GNZSHUN updates it.

Input Parameters IDWAN IDN of GENE bank to be transferred from the secondary EVNT tree = 0 Take last bank on secondary GENE linear structure Input Parameters IDOLD Former IDN of the bank in the secondary GENE linear structure = 0 Operation failed IDNEW IDN given to transferred bank in the primary GENE linear structure = 0 Operation failed

### Data Access Routines

Some routines have been developed to access particle and event information. These 'GET' routines can be used, for instance, if translation is not being done to HEPEVT during a read job.

#### GNZGETD. Get Daughter Information

GNZGETD(ILINK,IDN,IP,NDAUG,IDAUG)

Return in array IDAUG up to NDAUG indices of daughter particles for particle IP in event IDN in link set ILINK.

Input Parameters ILINK Link set specifier IDN IDN of the desired GENE bank IP member number of the given mother particle NDAUG Maximum number of daughters to return in IDAUG Output Parameters NDAUG Number of daughters returned in array IDAUG = 0 No daughters found IDAUG Array containing the member numbers of the daughter particles

#### GNZGETE. Get Event Information

GNZGETE(ILINK,IDN,NPART,IRUN,IEVT,CGNA,VERT,INTFL,WEIGH)

Return information on the IDN _th_ event in the present gate in link set ILINK

### Chapter 4 Subroutine Calls

**Input Parameters**

ILINK **Link set specific**.**

= 1 **primary tree**

= 2 **secondary tree**

IDN **ID of the GENE bank (Zebra IDN of the bank in the GENE linear**

**structure).**

**Output Parameters**

NPART **Numbers of particles or partons in event record**

IRUN **Run number from generator run**

IEVT **Event number from generator run**

CGNAM **Generator name (CHARACTER*4)**

VERT **4-vector given the primary vertex position of the event**

IWTFL **weight flag**

WEIGH **event weight**

#### 4.6.3 GNZGETG. Get Gate Information

**GNZGETG(ILINK,NEVEN)**

Return information on the current gate (that is, the current GENE linear structure) in link set ILINK.

**Input Parameters**

ILINK **Link set specific**.**

= 1 **primary tree**

= 2 **secondary tree**

**Output Parameters**

NEVEN **Number of events in the current gate**

#### 4.6.4 GNZGETP. Get Particle Information

**GNZGETP(ILINK,IDN,IP,ISTAT,IDPDG,P,AMASS,NOTE,TIME,IDASI)**

Return information from the particle record specified by ILINK,IDN,IP. If particle record does not exist, (or if ISTAT = 0), ISTAT is returned equal to zero.

**Input Parameters**

ILINK **Link set specific**.**

= 1 **primary tree**

= 2 **secondary tree**

IDN **ID of the GENE bank (Zebra IDN of the bank in the GENE linear**

structure).**

### Data Access Routines

IP particle record to read.

Output Parameters

ISTAT particle status

IDPDG particle code (Particle Data Group code)

P(4) 4-momentum of particle (in GeV )

AMASS mass of particle (in GeV/c 2)

MOTH(2) pointers to mother records

TIME Start time of particle relative to interaction,in seconds.

IDAU1 pointer to first daughter

#### 4.6.5 GNZGETR. Get Run Information

CALL GNZGETR(ILINK,JIDGN,IGRUN,IGTIM,IGDAT,CMACH,CGENE,VRGEN,IDATG, +VRGNZ,VRZEB)

Return global run information from the GENR bank in link set ILINK.

Input Parameters

ILINK Link set specifier

= 1 primary link set

= 2 secondary link set

Output Parameters

JIDGN Original generator run's job ID

IGRUN run number as specified in the original generator run

IGTIM time of the generator run as hhmmss

IGDAT date of the generator run as yymmdd

CMACH generator run platform (CHAR*4)

CGENE generator name (CHAR*4)

VRGEN generator version as vv.ssss (REAL*4)

IDATG date of the generator version as yymmdd

VRGNZ GENZ version (REAL*4)

VRGNZ Zebra version (REAL*4)

#### 4.6.6 GNZGETV. Get vertex information

CALL GNZGETV(ILINK,IDN,IP,VSIAR,INWRT,PRET,AROT,ROTMA)

Obtain the start point of a particle specified by ILINK,IDN,IP.This is found by tracing back from particle IP until the time is within TVMI seconds of zero (the primary interaction). TVMI is a parameter that can be set with GNZPARR. TVMI provides a cut-off to the traceback through the ancestors, preventing it from going far into the very short decays and partons showers. A small error in the calculation of the order of TVMI (or the speed of light times TVMI) may be introduced.

The index of the particle decaying at the returned vertex point is returned in IMVRT. This may not be the immediate mother particle of IP, which can be found by calling GNZGETP. It is rather the first particle in the ancestor traceback that has a non-negligible lifetime. The particle must have a laboratory

### Chapter 4 Subroutine Calls

lifetime greater than the GENZ parameter TVMI and also must be a unique ancestor of IP; that is in the traceback from IP to IMVRT, there is only ever one mother. If these conditions are not met, IMVRT is returned as 0.

IMVRT is also used as an error flag for bad input argument values and other errors.In these cases, there is always accompanying printout.

The remaining output parameters are of interest to users who have set a (uniform) magnetic field using GNZPARR. PRET is the 3-momentum of particle IP rotated according to the deflections of its ancestor particles in the field. AROT is the accumulated angle of rotation in radians about the magnetic field axis up to but not including IP's flight. ROTMA returns the rotation matrix that can be used to rotate 3-vectors, for instance using the utility GNZPROTA.

Input ParametersILNKLink set specifier=1 primary link set=2 secondary link setIDNID of event in the gateIPparticle member numberOutputParametersVSTARstart vertex position and time, x,y,z,t. This is returned relative to the interaction point in metres and seconds.IMVRTindex of particle decaying at VSTAR (see notes)=0IP decays within TVMI of primary vertex=-1Error conditionPRET(3)3-momentum of particle IP accounting for rotation in B-fieldAROTangle of rotation in radians about field axisROTMA(3,3)rotation matrix for rotation in B-field

### 4.6 GNZGETBC. Get top level bank contents

CALL GNZGETBC(ILINK,CBANK,NWANT,IYECT,NGET)

Return at most NWANT words in IVECT from bank CBANK at the top level of link set ILINK. The actual number of words returned is given in NGET.

This routine is provided along with GNZSETBC to allow primitive access to data written in th EVNT and RUNNT banks. It is assumed that these banks, being used globally by the user's application for suspending many sorts or bank, may contain more information than is stored by GENZ. Indeed, even the assignment of data in these banks that is done by GENZ is only meant as a suggestion. For this reason, the access tools for these routines have been written "generically", with no naming of data words, or any assumed length.

Input ParametersILNKLink set specifier=1 primary link set=2 secondary link setCBANKtop level bank name. 'EVENT' or 'RUNT'

### Data Entry Routines

NWANT maximum number of words to return in IVECT

IVECT(NWANT) words returned from the bank's data area

NGET number of words actually returned in IVECT

### Data Entry Routines

The following routines allow the user to create and fill GENZ banks, allowing the use of GENZ independent of any other standard format for storing generated event information.

GNZRUNNT and GNZEVENT are the basic routines to start new runs and events, dropping the old data structures, while GNZDROP can be called at any time to drop the RUNNT or EVNT structures. The "xxxNEWx" routines, GNZNEWR, GNZNEWE, book new GENR and GENE banks, respectively, while GNZNEWP adds new information to GENP banks. GNZMODE can be used to modify an existing GENE bank. GNZXREF lets the user set a cross-reference word (for instance into another package) in the particle record. GNZKILP can be used to remove as cleanly as possible a particle from the event record. GNZCHKM can be used to make sure that a user's manipulation of the particle record has not left mother references to dead particles.

#### GNZEVNT. Book new EVNT Bank

CALL GNZEVNT(ILINK,IGATE)

Any old EVNT bank on the ILINK tree is dropped (along with any depending banks) and a new one

booked writing the the current GENZ parameters.

Input Parameters

ILINK Link set specifier

= 1 primary link set

= 2 secondary link set

IGATE Gate number

#### GNZRUNNT. Book new RUNNT Bank

CALL GNZRUNNT(ILINK)

A new RUNNT bank is booked, after dropping any old RUNNT bank and its dependent banks. Data is

written into the new bank according to the present GENZ parameters.

Input Parameters

ILINK Link set specifier

= 1 primary link set

= 2 secondary link set30 Chapter 4 Subroutine Calls

#### GNZDROP

Drop a GENZ bank

CALL GHZDROP(ILINK,CBANK)

Bank CBANK in link set ILINK is dropped.

Input Parameters

ILINK  Link set specifier

= 1  primary link set

= 2  secondary link set

CBANK  CHARACTER?4 variable or constant giving the bank to be dropped

'RUNT' or 'EVENT' are the only legal values

#### GNZNEWE

Book a new GENE bank

CALL GNZNEWE(ILINK,IEWT,YRET,IWITFL,WEIGH,IDN)

A new GENE bank is booked on the ILINK tree. The generator event number is given in IEVNT. (Note that this is in principle distinct from the gate number, set in the GNZEVNT call.) The vertex position and time is given in VERT(1 - 4). The event weight flag is passed in IVTFL and the weight itself in WEIGH. Other event characteristics are obtained from the current parameters. The event index within the gate, equal to the ZEBRA ID in the GENE linear structure, is returned in IDN. Since GNZNEWE adds events at the end of the linear structure, IDN will increment, starting at 1, for sucessive calls to GNZNEWE.

Input Parameters

ILINK  link set specifier

IEVNT  generator event number

VERT(4)  array giving event vertex as x,y,z,t in metres and seconds

IVTFL  weight flag

WEIGH  event weight

Output Parameters

IDN  event ID given to this event (=Zebra IDN of the new GENE bank)

#### GNZMODE

Modify an event bank

CALL GNZMODE(ILINK,IDN,CHPAT,IRUN,IEWT,CBANA,YRET,IWITFL,WEIGH)

Modify the GENE with ID IDN bank in the ILINK tree. The data to be written is selected by the character value CHPAT.

Input Parameters

ILINK  Link set referred to

= 1  primary link set 

### Data Entry Routines

* 2 secondary link set
* IDN ID of event in gate (Zebra IDN of GENE bank in linear structure)
* CHPAT Character variable or constant specifying which event parameters to change
* 'E' event number
* 'V' vertex
* 'T' time
* 'R' run number
* 'G' generator name
* 'W' weight and weight flag

For example, CHPAT = 'RVT' \(\rightarrow\) change run number,vertex, and IRUN run number as recorded by generator
* IEVT event number as recorded by generator
* CGNEM generation name
* VERT(4) x,y,z,t of event interaction (metres,seconds)
* IVTTL weight flag
* WEIGH event weight

#### 4.7.6 GNZNEWR. Book a new GENR bank

* CALL GNZNEWR(ILINK)
* A new GENR bank is booked on the ILINK tree. All run characteristics are written from the GENZ current parameters.

* Input Parameters
* ILINK link set specifier

#### 4.7.7 GNZNEWP. Add a new particle record to a GENP bank
* CALL GNZNEWP(ILINK,IDN,IP,ISIAT,IDPDG,P,AMASS,NOTH,MODT,TIME,IPGOT)

Add a particle to the GENP bank of the IDNth GENE bank in ILINK tree. The particle is added as member IP if IP \(\neq\) 0, otherwise, it is added at the next possible member location, that is, at the end of the bank. In either case, IPGOT is returned as the member number of the new particle record. If IP points to an already existing particle, the old data is over-written.

* IPGOT = 0 if the procedure wasn't sucessful.
* Input Parameters
* ILINK Link set specifier.
* = 1 primary tree
* = 2 secondary tree

### Chapter 4 Subroutine Calls

IDN ID of the GENE bank to alter (Zebra IDN of the bank in the GENE linear structure). IP particle record to change. If zero, take next one. ISTAT particle status IDPDG particle code (Particle Data Group code) P(3) 3-momentum of particle (in GeV ) AMAS mass of particle (in GeV/c 2) MOTH(2) pointers to mother records MODT Mode of time argument. See below. TIME Start time of particle in seconds. MODT = 0 TIME should be given relative to interaction MODT = 1 TIME should be given relative to mother's start (ie, TIME is mother's lifetime), if mother exists.

Output Parameters IPGOT GENP index used for this particle = 0 The call was not carried out successfully

#### GNZXREF. Set cross-reference value to non-GENZ package

CALL GNZXREF(ILINK,IDN,IP,IPOIN,NORPH)

Set the "1st daughter pointer" of the specified particle record to the negative of IPOIN, where IPOIN is a x-reference value to a non-GENZ data structure.

This procedure is usually applied to particles that have IDAU1 \(\leq\) 0 returned from GNZGETP. Such particles have no daughter particles in GENZ; they are stable as far as GENZ is concerned. Thus these particles can be handled by another package (such as GEANT) and negative values stored in IDAU1 to give the cross-reference into that package.

If this routine is called for a particle that has IDAU1 \(>\) 0, the re-writing of IDAU1 wil still be carried out. This is, however, a more significant change to the GENZ event structure. Before writing in the new value, ALL the daughter particles of particle IP will be have their statuses set to zero if particle IP is the only mother. This process is continued down into succeeding generations. The number of particles killed by this process is returned in NORPH

Input Parameters ILINK Link set specifier = 1 primary link set = 2 secondary link set IDN ID of event in the gate IP index of particle record to change IPOIN (negative of) cross-reference value to write, ie., IPOIN must be greater than or equal to zero.

Output Parameters NORPH number of particles orphaned by the procedure

### Data Entry Routines

#### GNZKILP. Kill particle IP and/or its descendents

CALL GNZKILP(ILINK,IDN,IP,CHOPT,NDEAD)

The specified particle has its status set to zero and/or descendents of the particle can be killed. The number of dead particles is returned in NDEAD.

Input Parameters

CFLAG

String passed by the calling routine to be passed down to UGNZLOOP

ILINK

Link set specifier

= 1 primary link set

= 2 secondary link set

IDN

ID of event in the gate

IP

index of particle to kill

CHOPT

option flag

''= remove this particle and its descendents

'S' = remove this particle only from the particle record

'D' = remove the descendents of particle IP, but not IP itself

Note that the two non-default options are incompatible

Output Parameters

NDEAD

Number of particles killed by this call

#### GNZCHKM. Check mother pointers in desired event

CALL GNZCHKM(ILINK,IDN,CHOPT,NORPH)

Check mother pointers in desired event. Looping through the event, if the mother pointers for a given particle point only to status 0 particles, the user may opt to kill these "orphaned" particles. The default is not to kill.

Input Parameters

ILINK

Link set specifier

= 1 primary link set

= 2 secondary link set

IDN

ID of event in the gate to be checked

CHOPT

option flag

''= orphaned particles are kept.

'K' = orphaned particles are killed.

Output Parameters

NORPH

Number of orphan particles found (killed or not)

#### GNZSETBC. Set top level bank contents

CALL GNZSETBC(ILINK,CBAKK,WANT,IVECT,NWRIT)

Write vector IVECT into the data area of a top level bank, EVNT or RUNT. Write up to NWANT words. NWRIT returns the number of words actually written, taking into account the length of the bank.

This routine is provided along with GNZGETBC to allow primitive access to data written in th EVNT and RUNT banks. It is assumed that these banks, being used globally by the user's application for suspending many sorts or bank, may contain more information than is stored by GENZ. Indeed, even the assignment of data in these banks that is done by GENZ is only meant as a suggestion. For this reason, the access tools for these routines have been written "generically", with no naming of data words, or any assumed length.

Input Parameters

ILINK

Link set specifier

= 1 primary link set

= 2 secondary link set

CBANK

top level bank name. 'EVNT' or 'RUNT'

NWANT

maximum number of words to write to the data area of CBANK

IVECT(NWANT)

data to write into bank

NWRT

number of words actually written to bank

### 4.8 Magnetic Field Utilities

The following utilities are primarily for internal GENZ use. Calls to GNZGETV use these routines if and only if there is a magnetic field set via calls to GNZPARR. Users may be find them useful as well with the warning that the particles are propagated in GNZSTEP _in vacuo_ and in a uniform magnetic field.

#### GNZSTEP. Step a particle (in vacuo) in uniform magnetic field.

CALL GNZSTEP(PIN,B,T,Q,AM,POUT,DELITY,ANG)

GENZ internal and utility routine for stepping a particle (in vacuo) in a uniform magnetic field.

The output angle of rotation can be used to generate a rotation matrix using routine GNZGROT. This can then be applied using GNZROTA.

Input Parameters

PIN(3)

input 3-momentum (GeV/c)

B(3)

magnetic field in Teslas (taken to be uniform)

T

time duration of step in seconds (Lab. frame)

Q

electric charge of particle

AM

mass of particle in GeV/cc

Output Parameters

POUT(3)

output 3-momentum (GeV/c)

DELTX(3)

output change of position in metres

ANGR

angle of rotation in radians about Field axis

#### GNZGROT. Get Rotation matrix for rotation about given axis.

CALL GNZGROT(ANG,AIIS,ROTA)

### Other Utilities

Calculate rotation matrix for given angle and axis. This routine should be used with GNZROTA to perform rotations on vectors.

Input Parameters  ANGR.  Angle of rotation in radians  AXIS(3)  axis of rotation (Need not be normalized)  Output Parameters  ROTMA(3,3)  rotation matrix (REAL 3x3) for the :otation as used by GNZROTA

#### 4.8.3 GNZROTA. Perform rotation on vector

CALL GNZROTA(VIN,ROTMA,VOUT)

Apply rotation matrix to vector VIN. Output vector VOUT may occupy the same storage as VIN. The first index of ROTMA (fastest moving in memory) is the column index; the second is the row index. Thus rotation of a vector is performed, as for Vnew = ROTMA x Vold, in the following way:

 DO I = 1,3  VNEW(I) = 0.  DO J = 1,3  VNEW(I) = VNEW(I) + VOLD(J) * ROTMA(J,I)  ENDDO  ENDDO

Input Parameters  VIN(3)  Input vector  ROTMA(3,3)  rotation matrix for the rotation as given by GNZGROT or GNZGETV Output Parameter  VOUT(3)  Output vector

### Other Utilities

#### 4.9.1 GNZLOOP. Loop over particles in an event, calling user routine

CALL GNZLOOP(CFLAG,ILINK,IDN,MODE)

Particle in event IDN in link set ILINK are looped over. The routine UGNZLOOP (A dummy version of which is found in the GENZ library ) is called for classes of particles according to MODE.

Input Parameters  CFLAG  String passed by the calling routine to be passed down to UGNZLOOP  ILINK  Link set specifier  = 1  primary link set  = 2  secondary link set  IDN  ID of event in the gate

[MISSING_PAGE_EMPTY:37]

### 4.10. Deprecated Subroutines

Input Parameters

NUH Number of words in the header just read

IHEAD The header vector

Input Parameters

LKEEP =.TRUE. to keep structure

### 4.10. Deprecated Subroutines

#### 4.10.1 GNZCLOS. Close I/O streams. (DEPRECATED ROUTINE)

CALL GNZCLOS

Close all opened GENZ (Zebra) I/O streams. This operation should be normally be performed using GNZEND. If the closing of a stream is really necessary, the routine GNZSHUT may be called.

#### 4.10.2 GNZSETIP/GNZSETI. Set Integer Parameter

CALL GNZSETIP(CHPAR,IVALU)

Set the integer parameter specified by CHPAR.

Input Parameters

CHPAR CHARACTER*4 variable or string selecting the option to set

IVALU Integer value to be set

The parameters that can be set with GNZSETIP are as follow:

Option Key Explanation Default Value

'NSTA' Number of standard words to write in GENP bank 10

'LEN1' Record length in longwords 8100

'LEN2' Record length in longwords 8100

'LENO' Record length in longwords 8100

'TERM' Fortran terminal output unit 6

'MZEB' Zebra logging level -1

'PLMZ' Print level for MZ 0

'PLFZ' Print level for FZ 0

'PLGN' Print level for GENZ 0

'RUNN' Run Number

'GAT0' Offset of Gate number (first gate number -1) 0

'JBID' Jobid

'UWRD' Number of user words in GENP banks 0

'GVER' Generator version number *100 0

'GDAT' Generator date (yymmdd) 0

### Chapter 4 Subroutine Calls

Note that the parameter MZEB is only used if GENZ uses its own store (i.e., GNZSTOR is not called) and if GNZINIT is passed with a positive argument.

#### 4.10.3 GNZSETRP/GNZSETR. Set Real Parameter

CALL GNZSETRP(CHPAR,VALU)

Set the real parameter specified by CHPAR to VALU.

Input Parameters

CHPAR
CHARACTER*4 variable or string selecting the option to set

VALU

Real value to be set

The parameters that can be set with GNZSETRP are as follow:

Option Key Explanation Default Value

'TVMI', Minimum time in seconds relative to 1.0E-18

interaction recognised as separate vertex.

'BX'

x-component of Magnetic Field in Tesla 0.0

'BY'

y-component of Magnetic Field in Tesla 0.0

'BZ'

s-component of Magnetic Field in Tesla 0.0

'BMIN'

threshold field strength for calling field routines 0.0001

#### 4.10.4 GNZSETCP/GNZSETC. Set Character Parameter

CALL GNZSETCP(CHPAR,CVALU)

Set the character parameter specified by CHPAR to the value CVALU.

Input Parameters

CHPAR
CHARACTER*4 variable or string selecting the option to set

CVALU
CHARACTER*4 variable or string to be set

The following parameters can be changed with calls to GNZSETCP:

Option Key Explanation Default Value

'CFZ1', FZ option for primary input stream 'LKF'

'CFZ2', FZ option for secondary input stream 'LKF'

'CFZO', FZ option for output stream 'OXF'

'GENE', Generator name '---'

## Chapter 5 GENZ Input and Output

GENZ used the ZEBRA routines FZIN and FZOUT to do its I/O. This lets ZEBRA worry about the translation of data in specific formats from one machine's internal representation to another.

### FZ Format

Several FZ defaults have been chosen that give a good functionality to GENZ, although users may change the values using calls to GNZPARI and GNZPARC. A default record length of 8100 words has been chosen. This gives good usage of space on a tape and allows efficient reading and writing. The Zebra I/O format has been chosen to be exchange ('X') format.

### GENZ FZ I/O Record Organization

The beginning of a run is signalled in a generation job using GENZ by setting a run number, or by calling GNZFRHC with a negative value in NEVHEP. The next call to GNZWRIT will cause an FZRUN call to be executed, producing a Zebra Start-of-Run record on the output medium. Then GNZWRIT will write out the RUNT data structure. This record is written with a Zebra "new event" flag set. Finally, if there is an EVNT bank booked at this time, the EVNT bank will be written out, also with a "new event" flag. The initial writing of the RUNT bank is therefore a "pseudo-event"; for Zebra purposes, it is an event.

On subsequent calls to GNZWRIT, only EVNT data structures are written out. The GNZCLOS call generates a ZEBRA End-of-file.

Multiple runs can be written to a single file (although this practice is not recommended) but setting a new run number using GNZPARI. This flags a new call to FZRUN and the new RUNT structure to be written out.

### FZ User Header Vector

GENZ banks use the FZ user header vector to store two types of information; information about run numbers and event numbers (so that runs or events can be selected), and bank identification in the form of the Hollerith name (IDH) of the top-level bank in the read data structure.

The "user header words" written by GENZ are as follows:

RUNT Bank Header Vector  EVNT Bank Header Vector ---------------------------------------------------------------------

IHEAD(1) Run Number (Default=0)  Event(Gate) Number  IHEAD(2) 0 0  IHEAD(3) Hollerith of Bank name  Hollerith of Bank Name

The bank names are used to read in the banks from the input medium to the appropriate Zebra link variable. The bank is first read with FZIN option 'S' (Select) to read in the user header vector. The bank name is then looked at to determine where the bank is to be read in on a subsequent call to FZIN with the 'A' (Accept) option.

This allocation of words is based on the system used by GEANT, where the first words in header banks, RUNG or HEAD, are used to give run and event number, respectively. To flag that GENZ output is raw generator output and not been through an experiment-specific package, the run number is set to zero. The second words of these banks are used to tell the GEANT I/O how many more data structures to read in the same "event" (where "event" can either be a real event,ie. a HEAD bank plus following banks, or an initialization event, RUNG plus following banks ). Since, in GENZ, only one data structure is written per "event", this word is set to zero. When reading, however, GENZ does look at this word, and will skip the next IHEAD(2) data structures. The third word of the header vector, IHEAD(3) is not used by GEANT. GENZ therefore uses it to store the bank name as holleirth.