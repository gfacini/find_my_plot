**An Introduction to the Atlas Software Process**

Rosemary Candlin, _Edinburg University_

4 June 1996

## 1 The Need for Quality Software

The Atlas experiment will be spread over a very long time, lasting perhaps as much as fifteen years, or more. We therefore have to design software that will be adaptable to an evolving experiment and that will be robust and easy to maintain. This places much more stringent requirements on software quality than has perhaps been necessary in the past. It will no longer be likely that the person who originally wrote a software module will be around to sort out problems ten years later. Much of the Atlas software will be provided by people with short-term assignments, such as Ph.D. students. This means that we have to place a great deal of emphasis on ensuring that the design of the whole software system is clear and easy for newcomers to understand, that the purpose of each software module is well defined, and that documentation is comprehensive and kept up-to-date. In addition, of course, we have the traditional essential requirements that the software does what the users want it to do correctly and efficiently. Even more than in previous experiments, success depends crucially on software. In Level 3 processing, data are irrevocably rejected by a program and errors in bulk processing would result in unnecessary and unacceptable delays. It is therefore particularly important that Atlas software should be trustworthy.

The Atlas Software Process (ASP) is a proposed programme of software development that addresses these concerns. It is an example of a trend that has become widespread in the software industry and in large organizations (see, for example, [2]) of regarding the production of software as being similar in many ways to the production of hardware. It is therefore appropriate to make use of techniques for quality control that have been current for many years in production engineering. A key idea is that the functional requirements, whether of the complete system, or of some part of the system, should be clearly specified in some defined document and that the corresponding software product should be formally checked against this specification. The ASP sets out in some detail the order in which the various project activities take place, the documents that are required and the people who are responsible for the various tasks in the project. The aim is to have all this defined in one document, so that those involved in the project know just what is expected of them, and can see how their work contributes to the whole system. It is important that the overall philosophy of design, and the "look" of the design and code documents are uniform across the project, as this will greatly aid maintenance. It will also assist newcomers who want to contribute to the subsequent evolution of the software.

## 2 Key Features of the Atlas Software Process

### Motivation

The ASP is not intended to add an unnecessary layer of bureaucracy to the development process! Rather, it should be seen as an attempt to set standards which become a natural part of the everyday life of a system developer. It defines the interactions between managers, designers and programmers (who may often be the same people, although they play different roles on different occasions), and the sequence of activities in which they engage. The ASP report [1] attempts to specify all this in considerable detail, and may seem over-prescriptive at first sight. But it is valuable to have a clear picture of what we are going to do, and to spell out just how we want the project to proceed and what we want to produce. We are convinced that we need to set up some definite procedures before we start development, but we also recognize that the process (and the ASP document itself) may need to be adapted in the light of experience.

### Deliverables

These are documents of various kinds, such as management plans, designs, or source code which developers are obliged to produce at particular stages in the ASP. Their format and content are carefully defined in the ASP by sets of rules, some of which appear as appendices in [1]. Each deliverable is reviewed by a small group before being released for general use, so that there is a guarantee that it is of acceptable quality. The deliverables are a set of related documents providing a complete description of the software system, as it exists so far, which are always maintained in a consistent and up-to-date state.

In addition to these mandatory documents, there will also, of course, be a number of working documents, such as preliminary designs or background papers on various technologies. These will not, in general, have to conform to a particular format, or be subjected to a formal review. However, they should be referenced in the appropriate deliverable document so that they can easily be found.

### Evolutionary Development

One of the ways in which software really is rather different from hardware is that it permits design changes in a module while the module is actually being developed. In many ways, this is a helpful feature, because there is no point in proceeding with an inadequate design if a better one is available. On the other hand, uncontrolled changes by anonymous programmers lead to a lot of subsequent difficulties with maintenance. The ASP addresses this problem by _expecting_ software to change during development and setting up procedures to handle it.

After a preliminary phase, when the user requirements are captured and the outline of the system structure is worked out, development is carried out in a sequence of short cycles (of eight working weeks, in our proposed scheme). At any stage, there is a working system, though to start with, it will have very limited functionality. Each new cycle adds some more software modules, integrates them with the existing system and applies some global tests. So there is a continuous growth of the system and mistakes can be identified early, before too much investment has been made. This type of development is termed "evolutionary" [3], and although it was not originally invented in the context of object-oriented development, it is highly suitable for it. Developers can work independently on implementing and testing classes during a cycle, and then incorporate them for system testing at the end of the cycle.

Evolutionary development also looks appropriate for the Atlas application. We must expect that there will always be changes in parts of the software, as algorithms are improved or new features are required. In many cases, the change will involve exchanging one version of a class method for another, or of plugging in a new class. With the good encapsulation that object oriented design encourages, these changes can be made with little disturbance to the rest of the system. They will be proposed at the end of a cycle and any necessary changes to previous documentation will be recorded.

### Project Organization

If the project is to run smoothly, responsibilities must be defined. These refer to "roles" rather than "persons" in the ASP, because sometimes one person may combine two or more responsibilities. One group of roles is concerned with the design and implementation of the software itself, while the other is mostly concerned with running the ASP.

In the first group is the so-called "chief architect" who has the task of organizing a small group to define the overall structure of the software and dividing it up into "domains" corresponding to coherent work packages. These are parcelled out to "domain architect s", who have the responsibility for organizing the design and implementation of the software in their individual domains. Each will coordinate the group of domain programmers and report back to the chief architect at the end of the cycle.

The other group of roles is more various. It includes the project manager and a number of support people, such as those who take responsibility for project documentation or configuration management. The project manager is responsible for setting objectives, planning the organization of the work, and allocating resources. In a big domain, the manager will probably be a separate person from the architect, whereas in a smaller domain, these roles will be combined. In any case, the manager and the architect must work closely together.

From a practical point of view, there is a need for hierarchy of organization, so that the individual domains (which might correspond to a well-defined unit of Atlas like a calorimeter, or to a well-defined feature like a GUI) can get on with their own work semi-independently. However, there is also the need to ensure that the system will work as a whole. Accordingly, there is the concept of the "core team", consisting at first of the project manager, the chief architect and a "user requirements monitor" who identify the domain structure of the system and find appropriate specialists to act as domain architects. Subsequently, the core team is augmented by the domain architects, and it is this group who evaluate progress at the end of each development cycle.

### Quality Assurance

Two important mechanisms for ensuring and improving software quality are envisaged. The first has been briefly mentioned already: the formal review of deliverables. Starting from the document defining the user requirements, proceeding through various design documents to the final source code, it must be possible to show that each new deliverable satisfies the requirements implied by the preceding document in the sequence. In addition, for the sake of having uniform standards for structure, notation and content for a given type of document, a deliverable must conform to rules defined in the ASP. In a formal review, a small group of peer developers, who may include members from some other, related project, examine a document in detail, checking that it is consistent in all respects with its input and that it conforms to the ASP rules.

The second mechanism is longer term, and consists of identifying useful software metrics that might give an indication of quality. For example, classes with a very large number of methods, or very long methods, might be more bug-prone and more difficult to maintain. The "metrics collector" has the responsibility for collecting observational data, and giving feedback to programmers on what sort of values might correspond to "large" or "long". As the cycles succeed each other, it should be possible to get an increasingly good idea of these values.

### Software Process Improvement

As well as improving the quality of the software, we have the possibility of improving the actual process by which software is produced (as recommended in [4]). The metrics collector will also gather data on the time devoted to different kinds of activities and to the use of resources and may be able to identify ways in which the organization of the project could be improved. The fact that various aspects of the ASP itself are measured will provide a firm foundation on which to improve management control.

## 3 Conclusions

This is a very brief introduction to the ideas behind the Atlas Software Process. A more formal presentation appears in [1] which gives a detailed description of the topics mentioned here (though it should be noted that the ASP document is not yet complete). It is not to be expected that the procedures of the ASP are the best possible, considering that we shall be working with a new design paradigm and a new programming language, and do not yet have experience of how a large collaboration will adapt to this new environment. We do however think that there is a need for a well-defined software process and propose the ASP as a starting point. The ASP itself admits the likelihood that it will have to be adapted over time, and contains the flexibility that will allow it to evolve with the project.

## References

* [1] K. Bos, R. Candlin and S. M. Fisher, _The Atlas Software Process_, available from [http://moose.cern.ch/moose/documents/asp/asp.ps](http://moose.cern.ch/moose/documents/asp/asp.ps)