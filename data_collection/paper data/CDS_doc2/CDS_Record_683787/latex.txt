**A Data Preparation Algorithm for the**

**Precision Tracker LVL2 FEX**

**Reinier Dankers1**

NIKHEF, Amsterdam, The Netherlands.

**John Baines2**

Rutherford Appleton Laboratory, Chilton, Didcot, United Kingdom.

Footnote 1: Email: r78@nikhef.nl

Footnote 2: Email: j.t.m.baines@rl.ac.uk

**Abstract**

In this note a data preparation algorithm for the precision tracker LVL2 FEX is presented. This algorithm is divided into four different steps: data pre-selection, clustering, space-point formation and post-selection. For each step, a description of the algorithm, performance results, timing measurements and a parameterisation of the timing measurements are presented. Finally suggestions for implementation of the algorithm in the LVL2 system are given.

[MISSING_PAGE_EMPTY:2]

Introduction

In this note a set of algorithms are presented which process the raw data from the SCT and pixel detectors into a format suitable for the precision tracker LVL2 **F**eature **EX**traction (**FEX**)3 stage. The raw data consists of hits in the format produced by the **R**ead **O**ut **D**rivers (**RODs**). The data preparation process consists of the following four steps:

Footnote 3: For the precision tracker, feature extraction consists of finding tracks. A FEX algorithm is described in [1] which takes as input the SCT and pixel data prepared by the algorithms presented in this note.

* **Pre-selection**: selection of hits from SCT and pixel detector modules lying within the **R**egion **of **I**nterst (**RoI**) defined by the first (or second) level trigger;
* **Clustering**: association of adjacent hits into clusters;
* **Space-point formation**: association of clusters from the "\(\phi\)-layer" and the "stereo-layer" (SCT only); formation of space-points represented as \((\phi,r,z)\) co-ordinates;
* **Post-selection** (optional): selection of space-points lying within the RoI;

The output from the data preparation process is a list space-points lying within the RoI represented as \((\phi,r,z)\) co-ordinates.

Since the data preparation algorithms must operate in an online environment, a very important aspect is execution time. For each data preparation step, results of timing measurements are given. The data preparation algorithms are implemented in the software package SCTFEX, described in section 2.

## 2 SCTFEX

### Implementation

In order to study the execution times of the data preparation algorithms for the precision tracker, the C++ program SCTFEX has been written. This program does not make use of any external non-ANSI C++ libraries (apart from some platform dependant timing routines). It can, therefore, be implemented on any platform for which an ANSI C++ compiler exists. The SCTFEX program is independent from the ATLAS trigger simulation package, ATRIG. The differences between the algorithms in SCTFEX and ATRIG are mainly in the implementation, however there are some small differences in the details of the algorithms themselves. Some work is still required to integrate the algorithms presented here within the ATRIG framework.

The implementation of the algorithms within SCTFEX does not completely reproduce the full implementation within the trigger system. An important difference for the timing measurements is that the overheads associated with the communication between the LVL2 processors, **R**ead **O**ut **B**uffers (**ROBs**), global trigger processor and supervisor4 are not included. For the results presented here, the events are read from a data file.

Footnote 4: This is dependent on the architecture of the LVL2 system.

#### 2.1.1 Optimisation

The implementation of the algorithms can have a large impact on their execution speed. For example, an improved version of the pixel clustering algorithm is about a factor of 100 faster than the original version (see section 6.3 for a description of the improved clustering algorithm). Care has been taken to implement the algorithms as efficiently as possible, and especially to avoid repetition of calculations. Sometimes, however, a less efficient implementation has been chosen for reasons of flexibility. For example, to be able to easily test various versions of an algorithm, so-called "virtual functions" are sometimes used. Which implementation of the virtual function is called is decided at run time. A virtual function can be less efficient than a normal function because it can not be expanded inline5.

Wherever reasonable, LookUp Tables (LUTs) have been used to speed up the algorithms. A LUT is a table containing pre-calculated values of a function. Instead of performing the calculation, only a table index is calculated and the function result is read from the table. LUTs are especially useful when the function has discrete (e.g. integer) input values.

In the case of a continuous input distribution, a LUT can only be used by sampling a discrete set of input values with a consequent limitation on the precision of the result. In the current implementation, LUTs are only used in the case of a discrete set of input values.

### Procedure for timing measurements

Two different platforms have been used for timing measurements:

* An Apple Macintosh with a PowerPC 750 processor and 48 MB internal memory, running with MacOS 7.5.5. This PowerPC processor is installed on a PowerForce G3 processor card [2]. The CPU speed, the speed of the system bus, the size of the cache memory and the speed of the cache memory are adjustable. In all the configurations tested a CPU speed of 315 MHz and a system bus speed of 45 MHz were used. Four different configurations of the cache memory were tested (no cache, a 1 MB cache of 315 MHz, a 1 MB cache of 105 MHz and a 256 kB cache of 315 MHz).
* A Dell PC with a 400 MHz Pentium II processor, running with Windows NT 4.00. This system has 64 MB of internal memory, a cache memory of 512 kB and a 100 MHz system bus.

The C++ compiler used on the PowerPC is Metroworks CodeWarrior (version CW Pro 3). The compiler used on the Pentium II is Microsoft visual C++ (version 5.1). With both compilers the highest possible optimisation has been used (small non-virtual functions are, for example, automatically expanded inline).

The testing and handling of error conditions (array overflow, illegal data) has been implemented using the C++ assert macro. After the code development and testing phase, the execution of the assert macros may be disabled using a pre-processor directive. All the timing measurements have been obtained with the checks on error conditions disabled.

Only the calculation time of the algorithms is taken into account. Any file input/output or output to screen is excluded from the measurements. Initialisation is only taken into account if it has to be repeated for each RoI. Initialisation at the beginning of the program is not taken into account. All timing measurements presented in this note are in \(\upmu\)s.

#### 2.2.1 Timing measurements on the PowerPC

For the PowerPC a special timing routine NanoSec has been written, with a resolution better than 1 \(\upmu\)s. The timing measurements were made without suspending all other processes on the PC. Occasionally a timing measurement can be much higher than normal due to interrupts by the operating system. In order to prevent the timing results being biased by these uncharacteristically large values, the measurements were repeated several times and any value more than two times the mean was rejected. The mean execution time was recalculated from the remaining values.

#### 2.2.2 Timing measurements on the Pentium II

On the Pentium II a dedicated board with a **D**igital **S**ignal **P**rocessor (**DSP**) is used for timing measurements. The resolution is better than 1 \(\upmu\)s. Again the measurement is repeated several times and uncharacteristically large values are discarded.

#### 2.2.3 Timing measurements on other computer platforms

On computer platforms with a C/C++ compiler available, the ANSI C++ clock routine can be used. Since the resolution of this timing routine is generally rather coarse (e.g. 1 ms on a Pentium II), the time taken to execute the test routine many times (e.g. \(10^{3}\) or \(10^{4}\) times) is measured and the mean execution time is calculated.

## 3 Input files for SCTFEX

### Detector geometry

SCTFEX uses a geometry database read from an ASCII data file. The layout of the detector is that described in the inner detector TDR [3], a summary of this layout is given below. A transverse view of the barrel part of the precision tracker is shown in figure 1.

The precision tracker consists of pixel detectors on the inside and the Semi-conductor Tracker (SCT) at the outer radii. Both systems provide coverage up to a pseudo-rapidity of \(|\eta|<2.5\).

The SCT consists of a barrel part in the region \(|\underline{z}|<74.5\) cm and two end-caps in the region 83 cm \(<|\underline{z}|<278\) cm. Each SCT end-cap consists of nine discs distributed along \(z\), each containing two or three concentric rings of modules. Each module consists of two back-to-back detectors, one with strips oriented radially ("\(\phi\)-layer") and the other rotated by 40 mrad so as to provide stereo information ("stereo-layer"). Alternate planes have a positive (\(u\)-layer) or negative (\(v\)-layer) stereo angle. The barrel part consists of four concentric cylinders in the radial range 30 cm \(<r<52\) cm. The modules of the barrel are tilted at 10 degrees to the tangential in order to reduce the spread of charge due to the Lorentz offset6. The transition from barrel to end-cap geometry occurs at \(|\eta|\sim 1.5\). The total number of readout channels in the SCT is about \(6.2\times 10^{6}\).

Footnote 6: The electric field within the silicon wafer is approximately perpendicular to the magnetic field direction, causing a lateral displacement of the charge as it drifts towards the strips. This is partially compensated by tilting the module.

The barrel pixel detector consists of three concentric cylinders, each containing 13 rings of modules along \(z\). The innermost layer (the B-layer) has a radius of 4 cm, the outermost layer has a radius of 14 cm. The B-layer has a half-length of 38 cm and covers the entire pseudorapidity range \(|\eta|\leq 2.5\). The other two cylinders cover the range \(|\eta|\leq 1.7\). The barrel pixel detectors are also tilted with respect to the tangential. In the layout used for this study the pixel detectors are tilted in the opposite sense to the SCT modules in order to increase the pixel cluster width. In more recent layouts the tilt of the pixel detectors has the same sign as for the SCT modules [12]. The coverage is extended to \(|\eta|<2.5\) by two end-caps (47 cm \(\leq|\underline{z}|\leq 107\) cm) each containing four discs, three with two concentric rings of detectors, and the disc at highest \(|\underline{z}|\) containing one ring (this arrangement has also been changed in the most recent layout [12]). The total number of read-out channels in the pixel detector is \(1.4\times 10^{8}\).

### Data files

The data samples used for this study are those produced for the Inner Detector TDR. The events were produced by a full GEANT detector simulation within the SLUG framework with the DICE detector description. The

Figure 1: Transverse view of a quadrant of the ATLAS barrel precision detector.

[MISSING_PAGE_FAIL:6]

## 4 Input data format

A 32-bit word has been used to uniquely describe each pixel/strip in the detector. The input to the data preparation process consists of a list of the addresses of pixels/strips with hits. The various bit fields of the address word, defined in figure 4.1 to figure 4.3, have the following meaning:

* The part field distinguishes between barrel SCT, +\(z\) SCT end-cap, -\(z\) SCT end-cap, barrel pixel detector, +\(z\) pixel detector end-cap or -\(z\) pixel detector end-cap.
* The plane field indicates the barrel cylinder number or the disk number in the end-caps.
* The ring field indicates the module position in \(z\) (barrel) or \(r\) (end-cap).
* For the SCT, the layer field indicates whether the strip is in the "\(\phi\)-layer" or "stereo-layer"
* Finally, the strip field (SCT) and column and row fields (pixel detectors) identify the readout channels within the detectors.

For the SCT and end-cap pixel detector, one bit of the address word is not used. This addressing scheme, based on detector geometry, has been used here for convenience. In the final system a different scheme may be used based on **R**ead **O**ut **D**river (**ROD**) number and module identifier. A group of modules are connected to a ROD. The module identifier need only specify the module number within that group. In such a scheme the address might be split up into a header giving the ROD address followed by a list of addresses specifying the strip uniquely within the ROD. Such a difference in format would have a minor effect on the benchmark times for the data preparation algorithms.

For this study, the input data for each RoI consists of a single list of hits for each part (barrel or end-cap) of each detector (SCT or pixel). In the final implementation on the FEX processors, the hits will be received in fragments, consisting of the data from one or a few RODs. A header containing information about the current RoI will precede each fragment [6]. The merging of the fragments in one list is regarded as part of the communication overhead and not taken into account in the current implementation.

Figure 4.1: Meaning of the individual bits in the address word, SCT.

## 5 Pre-selection algorithm

### Modules within the RoI

The data from a ROD is stored in a ROB. In general only a subset of the modules connected to a ROB will lie within a given RoI. In the present design, in the case of a request for data from a ROB, the information from all modules will be sent. Thus, the first step of data-preparation for the FEX is to select the sub-set of data from modules lying wholly or partially within the RoI.

For the work reported here, a RoI size \(\Delta\eta\times\Delta\phi=0.2\times 0.2\) has been used corresponding to the size of a LVL1 electron/photon RoI. In the (\(r\), \(\phi\)) plane the RoI is a cone with its vertex at the origin. In the (\(r\), \(z\)) plane it is a truncated cone with a minimum half-width of 11.2 cm (corresponding to a 2\(\sigma\) spread of the LHC interaction point) at \(r=0\). A barrel module is assumed to lie within a RoI if:

\[\phi_{modMax}\geq\phi_{RoMin}\wedge\phi_{RoMax}\geq\phi_{modMin} \tag{5.1}\] \[z_{modMax}\geq z_{RoMin}(r_{mod})\wedge z_{RoMax}(r_{mod})\geq z _{modMin}\]

with (\(\phi_{modMin}\)\(\phi_{modMax}\)\(z_{modMin}\)\(z_{modMax}\)) the (\(\phi\), \(z\)) range spanned by the module, (\(\phi_{RoMin}\)\(\phi_{RoMax}\)\(z_{RoMin}\)\(z_{RoMax}\)) the (\(\phi\), \(z\)) range spanned by the RoI and \(r_{mod}\) the radial position of the module. An end-cap module is assumed to lie within an RoI if:

\[\phi_{modMax}\geq\phi_{RoMin}\wedge\phi_{RoMax}\geq\phi_{modMin} \tag{5.2}\] \[r_{modMax}\geq r_{RoMin}(z_{mod})\wedge r_{RoMax}(z_{mod})\geq r _{modMin}\]

where \(r(z_{mod})\) is the radius of the RoI at \(z=z_{mod}\).

A module-to-ROD mapping scheme determines which detector module is connected to which ROD. For the results presented here a mapping based on 16 modules per ROD was used. Complete freedom in the assignment of modules to RODs was assumed8. The mapping scheme was optimised so as to minimise the number of ROBs to be read out per RoI using a method based on simulated annealing [8]. As no mapping scheme was available for the pixel detectors, the data selection step was only implemented for the SCT.

Footnote 8: In more recent designs the ROD is connected to 24 SCT modules or 48 pixel modules (these numbers may be doubled in the final design). There will be constraints on the grouping of modules connected to a ROD. For the SCT barrel it is foreseen that all the modules from a single half-stave (6 modules) will be connected to the same ROD.

### Implementation of pre-selection algorithm

The **PSD** (Program **S**tructure **D**iagram) for the algorithm for the selection of hits from modules containing RoI data implemented in SCTFEX is given in figure 5.1. The implementation consists of a loop over the hits in the input lists. For each hit the corresponding detector module is determined based on the module bits of the address word and the hit is only copied to the output list if the module is lying within the RoI.

Since there are only a finite number of possible RoI positions, a LUT can be constructed containing, for each possible RoI, a bit pattern indicating which modules lie within the RoI. For electron RoIs the LUT size for pixels and SCT would be about 1.5 MB, corresponding to \(N_{Rob}\times N_{modules}\) entries. For practical reasons the full LUT is not calculated in advance in the current implementation of SCTFEX. Instead, a small (500 bytes) LUT containing just the SCT information is constructed for the current RoI only. This table needs to be recalculated for each new RoI. This recalculation is not taken into account in the presented timing values. So the timing results are the same as if the big table were used.

Figure 4.3: Meaning of the individual bits in the address word, end-cap pixel detector.

The input data files used contain only the data from modules lying within the RoI. A table giving the assignment of modules to ROBs (derived by the method described in [8]) is used to determine the number of additional modules that would be read out in the real system. Fake hits are generated to simulate the data from these additional modules based on the mean occupancy of the modules inside the RoI. In general the occupancy will be higher inside an RoI than outside an RoI9. This means that the number of additionally generated hits will be too large, and the calculation timings will be pessimistic.

Footnote 9: The hits inside a RoI are created by the high-\(p_{T}\) electron/jet plus minimum bias background. The hits outside a RoI are created by the minimum bias background only.

Loop over hits in input list

Check if current hit on different module

No

Yes

Update current module

Check if current module lies within the current RoI

Store hit in output list if current module falls within the current RoI

_Figure 5.1 PSD for algorithm for the selection of hits from modules containing RoI data._

### Pre-selection performance results

#### 5.3.1 Number of SCT ROBs receiving a data request per LVL1 RoI

A ROB receives a request for data if at least one of the modules connected to it lies within the RoI. A histogram of the number of (SCT) ROBs receiving a request per RoI, based on 16 modules per ROB, is shown in figure 5.2. This distribution is shifted to higher values than reported in a previous study [8]. This is due to the fact that, in this study, the spread of the interaction point in \(z\) has been taken into account when determining which modules lie within the RoI.

**Figure 5.2 Histogram of the number of SCT ROBs receiving a data request per LVL1 RoI for electron + pile-up events.**

The distributions of the numbers of modules with at least one hit inside the RoI are given for the different detector parts in figure 5.3 to figure 5.6 (electron + pile-up RoIs). RoIs that fall entirely outside a given detector part are excluded from the plots. However entries are included from RoIs that fall only partially within a given detector part (this is the reason for the smaller peak in the distributions at lower numbers of modules). An RoI can include data from up to about 40 modules in the barrel, up to about 30 modules in the end-cap.

#### 5.3.3 Number of hits per RoI

The distributions for the number of hits per RoI, passing the pre-selection, are shown for the different sub-detectors in figures 5.7 to 5.10 for electron + pile-up RoIs. Only RoIs that cover the corresponding sub-detector part are taken into account.

Since, at design luminosity, the occupancy is predominantly due to tracks, the number of hits is proportional to the solid angle covered by the detectors associated to the RoI. The elongation of the RoI along the \(z\)-axis to allow for the spread of the interaction point means that the number of hits is higher for RoIs in the barrel region than for RoIs in the end-cap. The detector size is also relevant as it determines the number of hits that will be included from outside the RoI. As a result the number of hits is lowest for the end-cap pixel detectors.

#### 5.3.4 Summary of results

A summary of results is given in table 5.1 both for RoIs in electron \(+\) pile-up and RoIs in jet \(+\) pile-up events. Only RoIs lying within the acceptance of the relevant detector part are considered when calculating these values. Results are given for the mean number of ROBs per RoI that receive a data request (results are only available for the SCT) and for the mean number of modules lying wholly or partially within an RoI. There are a mean of 4.4 SCT ROBs per RoI in the barrel region (jet \(+\) pile-up). Since in the mapping scheme used, each ROB is connected to 16 modules, this figure corresponds to a mean of 70.4 SCT modules read out per RoI. However only an average of 21.2 of these modules lie within the RoI. Corresponding mean values are given for the total number of hits from ROBs receiving a data request and for the mean number of hits accepted by the pre-selection. For the barrel SCT the mean total number of hits read out per RoI is 771, but only 35% of these (an average of 275 hits) are from modules lying within the RoI. The pre-selection thus provides a data reduction of about a factor three10.

Footnote 10: The data reduction factor will be significantly larger in the final design where more modules are connected to a ROB.

\begin{table}
\begin{tabular}{|l|c c|} \hline  & electron \(+\) pile-up RoIs & jet \(+\) pile-up RoIs \\ \hline
**Number of ROBs** & & \\ SCT barrel & 4.4 & 4.4 \\ SCT end-caps & 3.4 & 3.3 \\ SCT total & 5.4 & 5.6 \\
**Number of modules** & & \\ SCT barrel & 20.3 & 21.2 \\ SCT end-caps & 16.6 & 15.7 \\ pixels barrel & 23.3 & 25.3 \\ pixels end-cap & 11.0 & 10.5 \\
**Total number of hits** & & \\ SCT barrel & 690 & 771 \\ SCT end-caps & 451 & 496 \\
**Hits after pre-selection** & & \\ SCT barrel & 245 & 275 \\ SCT end-cap & 164 & 173 \\ pixels barrel & 321 & 395 \\ pixels end-cap & 31 & 32 \\ \hline \end{tabular}
\end{table}
Table 5.1: Mean number of ROBs, modules and hits per LVL1 RoI.

### Pre-selection timing results

The timing results for the pre-selection algorithm are given in table 2. The results for jet + pile-up RoIs and electron + pile-up RoIs are roughly the same. The values presented are based on the assumption that the hits are ordered per module, as is the case for the proposed readout scheme.

#### 5.4.1 Parameterisation of timing results

For modelling studies of the trigger system it is desirable that a simple parameterisation can describe the calculation time. The calculation time versus the number of hits (Pentium II, electron + pile-up RoIs) is given in figure 11 (barrel SCT) and figure 12 (end-cap SCT). From these figures it follows that to very good approximation the calculation time scales linearly with the number of hits. The calculation time is larger than predicted by the linear fit in only a small proportion of cases. The time necessary for initialisation, the overhead of the function calls, and the time necessary for the timing measurements themselves are all included in the value of the intercept. The values for the gradient and intercept are given in table 3.

## 6 Clustering algorithm

### Definition of a cluster

When a charged particle passes through a SCT or pixel detector, the deposited charge can be distributed over several strips or pixels. As the next stage of data preparation, the hits on neighbouring strips or pixels are associated together as **clusters**.

In the current SCTFEX implementation the definition of a cluster is very simple: a continuous group of strips or pixels with a hit. Gaps between these strips or pixels are not allowed. Very big clusters are not split. In the

\begin{table}
\begin{tabular}{|l|c c|} \hline  & barrel SCT & end-cap SCT \\ \hline
**electron + pile-up RoIs** & & \\ PowerPC (1 MB, 315 MHz cache) & 19 & 13 \\ Pentium II & 21 & 19 \\
**jet + pile-up RoIs** & & \\ PowerPC (1 MB, 315 MHz cache) & 21 & 14 \\ Pentium II & 22 & 19 \\ \hline \end{tabular}
\end{table}
Table 3: Mean calculation time of the data selection algorithm [us].

offline pattern recognition program a more complicated algorithm is used for the pixel detectors involving a clustering step followed by a step to split large groups of pixels which may be due to merged clusters.

The definition of a pixel cluster is slightly different from the definition used to produce the LVL2 results presented in the inner detector TDR [3] and in the TPSR [5]. For those studies clusters were allowed to extend without limit in \(\phi\), but were limited to three pixels in \(z\) (barrel) or \(r\) (end-caps). The latter restriction resulted in an artificial splitting of cluster near the end of the B-layer (\(|\eta|\!>\!2\)). Some work is still necessary to integrate the algorithm presented in this section into the ATRIG package.

### Implementation of SCT clustering algorithm

An example of two clusters in a part of a SCT module is given in figure 6.1. The first cluster consists of four strips, the second of two strips. For the SCT, a cluster is described by its (one-dimensional) position \(t\) and size \(s\):

\[\begin{array}{l}t=\nicefrac{{1}}{{2}}(t_{1}+t_{N})\\ s=N\end{array} \tag{6.1}\]

with \(t_{1}\) the integer strip index of the first hit in the cluster, \(t_{N}\) of the last hit in the cluster and \(N\) the number of strips in the cluster. From this equation it follows that the number of potential cluster positions is two times the number of strips. This means that the cluster position can easily be used as index for a LUT for the conversion of clusters into space-points (see section 7).

The PSD for the algorithm implemented in SCTFEX is given in figure 6.2. The implementation consists of a loop over the hits, checking if each hit is adjacent to the next hit or not. The assumption is made that the hits are grouped per detector and that the hits per detector are ordered by increasing (or decreasing) strip number. It may be the case that in the final readout scheme hits are ordered by strip number only within a readout chip (there are three chips per detector). In this case clustering could either be performed on a chip-by-chip basis or a cluster extending from one chip to another would be dealt with in an additional step.

Figure 6.1: An example of ten SCT strips with two clusters.

Figure 6.2: PSD for the SCT clustering algorithm.

### Implementation of pixel detector clustering algorithm

For the pixel detectors a much more complicated cluster finding algorithm is required than for the SCT. Each hit can have up to eight possible neighbours, and the hits within a cluster will not in general be consecutive in the input data. An example of two clusters in a pixel module is given in figure 6.5. For the pixel detectors a cluster is characterised by the local transverse and longitudinal co-ordinates of the cluster centre \((t,l)\), the cluster size in these two co-ordinates \((s_{n},s_{l})\), and the number of pixels forming the cluster \((N)\):

\[t= \frac{1}{N}\sum_{i=1}^{N}t_{i} \tag{6.2}\] \[s_{t}= \max\{{}_{1},\ldots,{}_{T_{N}}\}-\min\{{}_{1},\ldots,{}_{T_{N}}\}\] \[l= \frac{1}{N}\sum_{i=1}^{N}l_{i}\] \[s_{l}= \max\{{}_{1},\ldots,{}_{T_{N}}\}-\min\{{}_{1},\ldots,{}_{T_{N}}\}\]

with \(t_{n}\) and \(l_{i}\) the row and column index of hit \(i\). In the example shown in figure 6.5 the size of the first cluster, according to this definition, is \((5,3)\). The size of the second cluster is \((4,3)\). Due to the large set of potential values, the cluster position is not suited for use as the index to a LUT.

The input to the clustering algorithm consists of a list of hits within a module ordered by pixel row and then by column. The process of assignment of hits to clusters consists of two parts, a **cluster identification algorithm** that identifies and processes isolated hits and a recursive **cluster formation algorithm** that is called by the cluster identification algorithm in the case of non-isolated hits. The input to the cluster formation algorithm is a two-dimensional **pixel map**, with one entry per pixel (implemented as an one-dimensional array), created and filled by the cluster identification algorithm. The PSD for these two algorithms are given in figure 6.3 and figure 6.4.

The cluster identification algorithm takes each hit in turn and enters it in a **hit list**. If the current hit is separated by more than one row from the previous hit, this marks the start of a new cluster. In this case the hit list is processed and reset before the new hit is added to the list. For a hit list with a single entry, processing consists simply of creating a single-pixel cluster. When the hit list contains several entries, they are entered in the pixel-map and the cluster formation process is initiated. As hits are assigned to clusters, the corresponding entry in the pixel-map is zeroed. For each hit in turn with a non-zero entry in the pixel-map, the cluster formation algorithm is called and the created cluster added to the output list.

The cluster formation algorithm is a recursive procedure that first adds the current pixel to the cluster, updating the cluster position and size. It sets the pixel-map entry for the current hit to zero to avoid multiple assignment of hits to clusters. It then loops over the neighbouring pixels, and in the case of a hit, the cluster formation algorithm is called recursively.

All the hits are processed in this way in order to produce as output a list of clusters. Care has been taken to implement the cluster formation algorithm as efficiently as possible by specifying a minimal function interface. As an illustration of how the algorithm proceeds, in figure 6.5 the order in which the cells are checked is indicated by the first number in the cell. Also given by the first number in brackets is the number of the cell that initiated the check of the current cell.

\begin{tabular}{|l|l|l|} \hline \multicolumn{3}{|l|}{Loop over hits in input data} \\ \hline \multicolumn{3}{|l|}{Check if the current hit is in a different module or is more than one row plus one column} \\ \multicolumn{3}{|l|}{away from the last hit} \\ \hline No & Yes \\ \hline \multicolumn{3}{|l|}{Check if only one hit is stored in list} \\ \cline{2-3}  & No & Yes \\ \cline{2-3}  & Loop over hits stored in list & One cluster consisting of one \\ \cline{2-3}  & Set pixel in pixel map (value 1) & pixel found. Update list with \\ \cline{2-3}  & Loop over hits stored in list & clusters. \\ \cline{2-3}  & Check if pixel in pixel map is set (value 1) \\ \cline{2-3}  & No & Yes \\ \cline{2-3}  & Recursive cluster classification algorithm starting from current pixel \\ \cline{2-3}  & (figure 6.4) \\ \cline{2-3}  & Add found cluster to list with clusters \\ \cline{2-3}  & Reset list with hits \\ \cline{2-3}  & Update list with current hit \\ \hline \multicolumn{3}{|l|}{Create last cluster and update list with found clusters} \\ \hline \end{tabular}

_Figure 6.3 PSD for pixel cluster identification algorithm._

Update information about cluster position and size

Reset current pixel (value zero)

Loop over possible neighbour pixels

Check if neighbour cell contains hit

No & Yes

Start recursive search algorithm from neighbour cell

_Figure 6.4 PSD for recursive cluster formation algorithm._

[MISSING_PAGE_EMPTY:16]

[MISSING_PAGE_FAIL:17]

[MISSING_PAGE_EMPTY:18]

## 7 Space-points formation

### Introduction

In this section the steps by which a three-dimensional space-point is formed are described. For the SCT this process consists of two steps. Firstly, for each module, clusters in the "\(\phi\)-layer" and "stereo-layer" are associated to form two-dimensional points in the local co-ordinate system within the plane of the module (**local co-ordinates**). Secondly, using the information on the position and orientation of the module within ATLAS, these two-dimensional points are transformed to a three-dimensional point within the ATLAS co-ordinate system (**global co-ordinates**). The space-points may be represented in either a Cartesian (\(x\), \(y\), \(z\)) or cylindrical (\(\phi\), \(r\), \(z\)) co-ordinate system. The FEX algorithm described in [1] requires the later.

The algorithm presented contrasts with the offline pattern recognition where the \(\phi\) and stereo hits are treated as independent hits throughout the pattern recognition process. The advantage of forming an association at the initial stage is that the points from the pixel detectors, barrel SCT and end-cap SCT can be treated in the same way in the subsequent FEX algorithm. In particular this means that the transition from the barrel to the end-cap geometry is treated automatically. A disadvantage is that in regions of high occupancy, in addition to the correctly reconstructed points, there will be points from ghosts. The ghosts arise from the incorrect association of a cluster on the "\(\phi\)-layer" with a cluster on the "stereo-layer" caused by another track or noise.

The algorithm described is the same as that implemented in ATRIG and used to produce the results presented in the ID TDR and TPSR [3, 5]. However in the implementation described here more care has been taken on the optimisation, using LUTs where practical.

### Barrel SCT space-point formation algorithm

For the barrel SCT, the local co-ordinate system has its origin at the centre of the module with a longitudinal co-ordinate \(L\) (cm), in the direction of the strips; and a transverse co-ordinate \(T\) (cm), perpendicular to \(L\). The cluster position \(t\) can be converted into the corresponding local co-ordinate \(T\) as follows:

\[T=\left(t-t_{centre}\right)\lambda \tag{7.1}\]

where \(\lambda\) is the strip pitch (cm) and \(t_{centre}\) the index of the most central strip. In order to calculate the \(L\) co-ordinate, one needs to combine a cluster from the "\(\phi\)-layer" (\(T_{1}\)) with a corresponding cluster from the "stereo-layer" (\(T_{2}\)).

A \(\phi\)-cluster may be associated with more than one stereo-cluster, for example in the case of two or more nearby tracks, or where there is a cluster due to electronic noise. In such cases, in addition to the true space-point formed from correctly associated clusters, there will be "ghost" points due to incorrect associations. The true and ghost points will have the same transverse co-ordinate, but are separated in the longitudinal co-ordinate. It is only possible to distinguish the true points from ghosts using a three-dimensional track fit. A quantity, the **degree of ambiguity** has been defined as the number of space-points formed from each \(\phi\)-layer cluster.

The local position \((T,L)\) of the space-point is given by (a deviation is given in appendix A):

\[T= T_{1}\] \[L= \frac{T_{2}-T_{1}\cos\alpha}{\sin\alpha} \tag{7.2}\]

where \(\alpha\) is the stereo angle (see also section 3.1). A cluster pair is only accepted if \(L\) is in the allowed range:

\[\left|L\right|\leq\gamma L_{strip} \tag{7.3}\]

where \(L_{strip}\) is the strip length. Clusters from the "\(\phi\)-layer" without an associated cluster from the "stereo-layer" are skipped.

The conversion from local to global co-ordinates is given by:

\[x=x_{mod}+e_{x}\left(T+T_{shift}\right)\] \[y=y_{mod}+e_{y}\left(T+T_{shift}\right) \tag{7.4}\] \[z=z_{mod}+L+z_{shift}\]

with \(e_{x}\) and \(e_{y}\) given by:

\[e_{x}=-\sin\left(\phi_{mod}+\tau\right)\] \[e_{y}=\cos\left(\phi_{mod}+\tau\right) \tag{7.5}\]

where \(\tau\) is the tilt angle of the module. \(T_{shift}\) is a correction for the offset of the measured cluster position with respect to the true position of the track due to the Lorentz effect. A value for \(T_{shift}\) of 0.004 cm is used which is the average displacement due to the Lorentz effect. Additional corrections must be applied to account for finite radial separation of the \(\phi\)-layer and the stereo-layer. This separation means that the \(\phi\) and stereo measurements are not made at exactly the same point on the track. Where the track is perpendicular to the module the local co-ordinate calculated will be correct. However this is not in general the case, due to the fact that the modules are tilted with respect to the tangential direction, and due to the polar angle of the track. The correction for the displacement due to the tilt angle has a constant term and a term that depends on the transverse co-ordinate. The sign of the correction depends on whether the module is \(u\)-\(\phi\) (barrel layers 1 and 3) or \(v\)-\(\phi\) (barrel layers 2 and 4). For barrel layer 1 and 3, \(z_{shift}\) is given by:

\[z_{shift}=0.18+0.03\left(T+T_{shift}\right)+\frac{0.04}{r} \tag{7.6}\]

with all dimensions in cm. For barrel layer 2 and 4, \(z_{shift}\) is given by:

\[z_{shift}=-0.18-0.03\left(T+T_{shift}\right)+\frac{0.04}{r} \tag{7.7}\]

In principle the coefficients (0.18, 0.03 and 0.04) could be calculated. In the current study they were obtained by studying the residuals in the Monte Carlo data.

#### 7.2.1 Implementation

First a list of modules is constructed. This allows the search for potential partner clusters to be made more efficiently. This list contains for each module a pointer to the first and last cluster on the "\(\phi\)-layer" and on the "stee-reo-layer". Modules containing only clusters on the "stereo-layer" are skipped. The other part of the algorithm is based on three nested loops: a loop over the modules in the RoI, a loop over the "\(\phi\)-layer" clusters in the current module and finally a loop over the clusters in the "stereo-layer". If the two clusters form a pair, i.e. condition 7.2 is satisfied, a space-point is created. Clusters on the "\(\phi\)-layer" without a partner on the "stereo-layer" are skipped.

LUTs are used to speed up the calculation of all the quantities with the exception of \(z\). For each module and for each potential value of the local cluster position \(T\), the corresponding values of (\(\phi\), \(r\)), are pre-calculated and stored. The size required for the LUT depends on the degree of symmetry of the detector and the final position resolution required. For ultimate precision, individual entries would be required for each module. In this case the number of entries in the LUT would be \(2\times N_{strip}\times N_{strip}\times N_{planes}\times N_{modules}\), corresponding to about 18 MB us ing a 32 bit floating point representation (including entries for the errors \(\sigma_{r}\), \(\sigma_{\phi}\), \(\sigma_{z}\)). The factor 2 in the expression for the table size arises from the fact that \(T\) is quantised in units of one half strip-pitch.

The current implementation makes use of the symmetry of the detector to reduce the memory usage of the program. There are two types or rings in any plane, differing only in \(r\). The LUT is split into separate tables for \(\phi\) and \(r\). By exploiting the detector symmetry, the size of the \(\phi\) LUT can be reduced by a factor \(N_{ring}\) and the size of the \(r\) LUT by \(N_{ring}/2\). The total size of the two tables is about 3 MB using a 32 bits float implementation.

In the experiment, the symmetry of the detector will not be exact due to the effects of mechanical tolerance. A reduction in LUT size using detector symmetry will only be possible if the resulting degradation of resolution can be tolerated without significant loss of trigger performance. If a given processor were to receive data from only a part of the SCT, an additional reduction of the memory required would be possible without loss of resolution. In this case, only the relevant portion of the LUT need be loaded. The PSDs for the algorithms as implemented are shown in figures 7.1 and 7.2.

### End-cap SCT space-point formation algorithm

For the end-cap SCT the local two-dimensional co-ordinate is measured within a plane perpendicular to the beam-pipe (the \(z\)-axis is the ATLAS co-ordinate system). The strips have a radial geometry with the origin at

Figure 7.2: PSD for barrel SCT space-point formation algorithm.

\begin{table}
\begin{tabular}{|l|l|} \hline \multicolumn{2}{|l|}{Create list of modules (figure 7.1)} \\ \hline \multicolumn{2}{|l|}{Loop over modules in list} \\ \hline \multicolumn{2}{|l|}{Calculate LUT offset for current module} \\ \hline \multicolumn{2}{|l|}{Loop over clusters in “\(\phi\)-layer”} \\ \hline \multicolumn{2}{|l|}{Calculate LUT index for current cluster} \\ \hline \multicolumn{2}{|l|}{Loop over clusters in “stereo-layer”} \\ \hline \multicolumn{2}{|l|}{\multirow{4}{*}{\(\phi\)-layer”}} \\ \cline{2-3} \multicolumn{2}{|l|}{} & \multicolumn{1}{|l|}{Calculate position \(L\) according to eqn.s (7.1) and (7.2)} \\ \cline{2-3} \multicolumn{2}{|l|}{} & \multicolumn{1}{|l|}{Check if position \(L\) in allowed range} \\ \cline{2-3} \multicolumn{2}{|l|}{No} & Yes \\ \cline{2-3} \multicolumn{2}{|l|}{} & \multicolumn{1}{|l|}{Create new space-point} \\ \cline{2-3} \multicolumn{2}{|l|}{} & \multicolumn{1}{|l|}{Calculate (\(\phi\), \(r\)) values via LUT.} \\ \cline{2-3} \multicolumn{2}{|l|}{} & \multicolumn{1}{|l|}{Calculate \(z\)-position using eqn. (7.4)} \\ \hline \end{tabular}
\end{table}
Table 7.2: PSD for barrel SCT space-point formation algorithm.

\(r=0\) for the \(\phi\)-layer. The local transverse angular co-ordinate \(\mathbf{\mathit{\Phi}}\) (mrad) is defined as the angular separation at \(r=0\). The longitudinal co-ordinate \(P\) (cm) is defined as the difference in radius between the space-point and the centre of the module. For each cluster on the "\(\phi\)-layer" one can directly calculate the local co-ordinate \(\mathbf{\mathit{\Phi}}\):

\[\mathbf{\mathit{\Phi}}=\big{(}t-t_{centre}\big{)}\lambda_{ang} \tag{7.8}\]

where \(\lambda_{ang}\) is the angular strip pitch in mrad and \(t_{centre}\) the index of the most central strip. For calculating the local co-ordinate \(P\) one needs to combine a cluster from the "\(\phi\)-layer" (\(\mathbf{\mathit{\Phi}}_{i}\)) with a cluster from the "stereo-layer" (\(\mathbf{\mathit{\Phi}}_{2}\)). The local co-ordinates of the created space-point are given by (a deviation is given in appendix A):

\[\begin{split}\mathbf{\mathit{\Phi}}&=\mathbf{\mathit{\Phi }}_{1}\\ P&=r_{mod}\,\frac{\big{(}\sin\mathbf{\mathit{\Phi}}_{2}- \sin\big{(}\mathbf{\mathit{\Phi}}_{2}+\alpha\big{)}\big{)}}{\sin\big{(}\mathbf{\mathit{ \Phi}}_{1}-\big{(}\mathbf{\mathit{\Phi}}_{2}+\alpha\big{)}\big{)}}-r_{mod}\end{split} \tag{7.9}\]

where \(\alpha\) is the stereo angle.

The conversion from local to global co-ordinates is given by:

\[\begin{split}\phi&=\mathbf{\mathit{\phi}}_{mod}+\mathbf{ \mathit{\Phi}}_{1}\\ r&=r_{mod}+P+r_{shift}\\ z&=z_{mod}\end{split} \tag{7.10}\]

where \(r_{shift}\) is a correction for the offset due to the effects of the finite separation of the \(\phi\)-layer and stereo-layer. The sign of this correction depends on the sign of the stereo angle. For odd wheels (\(v\)-layer), \(r_{shift}\) is given by:

\[r_{shift} = -0\,.17\ -\ 0\,.008\ P \tag{7.11}\]

with all dimensions in cm. For even wheels (\(u\)-layer), \(r_{shift}\) is given by:

\[r_{shift} = 0.22+0.008P \tag{7.12}\]

#### 7.3.1 Implementation

The implementation is similar to that used for the barrel SCT. The calculation is somewhat simpler since the SCT end-cap directly measures \(\phi\). A LUT is used to speed up the calculation of \(P\), which can be written as follows:

\[P=r_{mod}\,\frac{\sin\mathbf{\mathit{\Phi}}_{2}-\sin\mathbf{\mathit{\Phi}}_{2}\cos \alpha-\cos\mathbf{\mathit{\Phi}}_{2}\sin\alpha}{\sin\mathbf{\mathit{\Phi}}_{1}\big{(} \cos\mathbf{\mathit{\Phi}}_{2}\cos\alpha-\sin\mathbf{\mathit{\Phi}}_{2}\sin\alpha \big{)}-\cos\mathbf{\mathit{\Phi}}_{1}\big{(}\sin\mathbf{\mathit{\Phi}}_{2}\cos\alpha+ \cos\mathbf{\mathit{\Phi}}_{2}\sin\alpha\big{)}}-r_{mod} \tag{7.13}\]

For each possible cluster position \(T\), the corresponding values of \(\mathbf{\mathit{\Phi}}\), \(\cos\mathbf{\mathit{\Phi}}\) and \(\sin\mathbf{\mathit{\Phi}}\) are pre-calculated and stored. The number of entries in the LUT is equal to \(2\times N_{sing}\times N_{plane}\times N_{strip}\). The memory requirement is about 100 KB. The factor 2 in the expression for the table sizes from the fact that there are twice as many potential cluster positions as strips.

### Pixel detector space-point formation algorithm

#### 7.4.1 Barrel pixel detector

The pixel detector directly measures a local two-dimensional co-ordinate (\(t,l\)). This is converted to the appropriate units (cm) using the readout pitches (\(\lambda_{1},\lambda_{2}\)) in the transverse and longitudinal directions respectively as follows:

\[\begin{split} T&=\big{(}t-t_{centre}\big{)}\, \lambda_{1}\\ L&=\big{(}l-l_{centre}\big{)}\,\lambda_{2}\end{split} \tag{7.14}\]

with (\(t_{centre}\), \(l_{centre}\)) the position of the most central pixel.

The point \((T,L)\) is transformed to the ATLAS co-ordinate system using information on the position of the module (\(x_{mod}\), \(y_{mod}\), \(z_{mod}\)) and its orientation (\(e_{x}\), \(e_{y}\)) as follows:

\[\begin{split} x&=x_{mod}-e_{x}\big{(}T+T_{shift} \big{)}\\ y&=y_{mod}+e_{y}\big{(}T+T_{shift}\big{)}\\ z&=z_{mod}+L\end{split} \tag{7.15}\]where \(T_{ship}\) is a correction for the Lorentz angle (fixed value 0.002 cm). The terms \(e_{x}\) and \(e_{y}\) are given by:

\[e_{x} = \sin\!\left(\phi_{mod}+\tau\right) \tag{7.16}\] \[e_{y} = \cos\!\left(\phi_{mod}+\tau\right)\]

where \(\tau\)is the tilt angle of the module.

#### 7.4.2 End-cap pixel detector

For the end-cap pixel detector, the conversion from local (\(T,L\)) to global (\(x,y,z\)) co-ordinates is given by:

\[x = x_{mod}-e_{x}\left(T+T_{ship}\right)+e_{y}\left(L+L_{ship}\right)\] \[y = y_{mod}+e_{y}\left(T+T_{ship}\right)+e_{x}\left(L+L_{ship}\right) \tag{7.17}\] \[z = z_{mod}\]

where the definitions of the variables \(e_{x}\) and \(e_{y}\) are the same as for the barrel pixel detector. The parameters \(T_{ship}\) and \(L_{ship}\) were introduced as there were small offsets in the module positions stored in the geometry table used for this study. \(L_{ship}\) has a value of -0.01 cm. The value of \(T_{ship}\) is -0.0023 cm for odd numbered modules and 0.0023 cm for even numbered modules.

#### 7.4.3 Implementation

The implementations of the algorithms for the pixel detectors are simpler than those for the SCT since no cluster association step is required. The implementations are based on a loop over the clusters, converting each cluster into a local (\(L,T\)) co-ordinate and then into a (\(x,y,z\)) space-point using equations (7.15) and (7.17) respectively. The points are then transformed to cylindrical co-ordinates (\(\phi,r,z\)). The information on the position (\(x_{mod},y_{mod}\), \(z_{mod}\)) and orientation (\(e_{x},e_{y}\)) of each module is stored in a geometry table. However, in the current implementation, LUTs have not been used for the calculation of the global co-ordinate or for the transformation from Cartesian to cylindrical co-ordinates. The use of LUTs is more complicated than for the SCT, due to the almost infinite number of possible cluster positions. The corresponding PSD is given in figure 7.3.

### Performance results for space-point formation

#### 7.5.1 Degree of ambiguity

The distributions of the degree of ambiguity (number of space-points, real points plus ghosts, formed from a single cluster in the "\(\phi\)-layer") are shown for the barrel SCT in figure 7.4 for electron + pile-up RoIs and in figure 7.5 for jet + pile-up RoIs. The corresponding plots for the end-cap part are shown in figure 7.6 for electron + pile-up RoIs and in figure 7.7 for jet + pile-up RoIs.

In about 20% of the cases the degree of ambiguity is greater than one indicating that one or more ghost points have been formed. The degree of ambiguity is about the same for single electron events with pile-up as for jets with pile-up. In about 9% of the cases there is no associated stereo-point (degree of ambiguity equals 0). Stereo information may be missing due to one of three effects: detector inefficiency, the partner cluster is in an adjacent module or the \(\phi\)-cluster is due to noise.

Figure 7.3: PSD for pixel data preparation algorithm.

#### 7.5.2 Average number of space-points per RoI

The mean numbers of space-points reconstructed per RoI are given for the various detector parts in table 7.1, both for RoIs in single electron events with pile-up and for jet events with pile-up. There are about 15% more space-points in the RoIs in jet events due to the higher particle densities. The mean number of space-points for the different detector parts depends on the number of detection planes (four for the SCT, three for the barrel pixel detector and two for the end-cap pixel detector) and on the solid angle covered by the detectors from which the points are derived.

The mean number of space-points is greatest for the barrel pixel detector. Since this detector is closest to the beam-pipe, the solid angle coverage of each detector is relatively large. In addition the shape of the RoI is defined so as to allow for the finite length of the interaction region in \(z\). This means that an RoI covers a greater solid angle at low radius than at higher radii.

The distribution of the total number of space-points per RoI is shown in figure 7.8.

Figure 7.8: Total number of space-points in an RoI, electron + pile-up RoIs.

[MISSING_PAGE_FAIL:25]

#### 7.6.1 Parameterisation of timing results

The distributions of execution times (Pentium II) as a function of the number of clusters are shown for the different detector parts in figures 7.13 to 7.16 (electron + pile-up RoIs). Lines have been fitted to these distributions in order to obtain a parameterisation of the dependence of execution time on the number of clusters.

The SCT algorithm contains two nested loops over clusters for the association of \(\phi\) and stereo clusters and hence the execution time contains a quadratic term. The execution time for the pixel algorithm scales linearly with the number of clusters. The results of the parameterisation are shown in table 7.3.

Figure 7.13: Calculation time space-point formation algorithm versus number of clusters, barrel SCT, Pentium II, electron + pile-up RoIs. Figure 7.14: Calculation time space-point formation algorithm versus number of clusters, end-cap SCT, Pentium II, electron + pile-up RoIs.

## 8 Post-selection algorithm

### Implementation of post-selection algorithm

As an optional final stage of data preparation, the subset of points that lie within the RoI may be selected. For this purpose, the RoI is defined as a truncated cone for which the \(z\) dimension takes into account the length of the interaction region (see figure 10). This selection step may reduce the size of the data sample to be transported through the switching network and reduces the calculation time of the FEX algorithm. The selection algorithm presented has been optimised for RoIs from high-\(p_{T}\) electrons.

#### Range in \(z\) barrel

In the (\(r\), \(z\)) plane the RoI is a cone bounded by the lines joining the pairs of (\(r\), \(z\)) points (0, \(\Delta z\)), (\(r_{cal}\), \(z_{cal}\),\(z_{cal}\)) and (0, -\(\Delta z\)), (\(r_{cal}\), \(z_{cal}\),\(z_{cal}\)). The allowed range in \(z\) is a function of \(r\) and given by:

\[\frac{r}{r_{cal}}\big{(}z_{cal}\!\!\!_{Min}+\Delta z\big{)}\!-\!\Delta z \leq z \leq \Delta z+\frac{r}{r_{cal}}\big{(}z_{cal}\!\!\!_{Max}-\Delta z\big{)} \tag{10}\]

with \(r_{cal}\) the radial position of the calorimeter and (\(z_{cal}\!\!\!_{Min}\),\(z_{cal}\!\!\!_{Max}\)) the range in \(z\) spanned by the RoI for \(r=r_{cal}\). For \(r=0\), the allowed \(z\)-range is equal to (-\(\Delta z\), \(\Delta z\)), where \(\Delta z\) is the 2\(\sigma\) value of the spread of the interaction region along \(z\).

#### Range in \(r\) end-cap

For the end-cap detectors, the selected space-points lie within a cone bounded by the lines joining the pairs of (\(z\), \(r\)) points (\(\Delta z\), 0), (\(z_{cut}\), \(r_{calitn}\)) and (-\(\Delta z\), 0), (\(z_{cut}\), \(r_{calitn}\)) (forward region). The allowed range in \(r\) is a function of \(z\) and given by:

\[r_{calitn}\frac{\left|z\right|-\Delta z}{z_{calitn}-\Delta z}\ \ \leq\ \ r\ \ \leq\ \ r_{calitn}\frac{\left|z\right|+\Delta z}{z_{caln}+\Delta z} \tag{8.2}\]

The radial range at the calorimeter is given by (\(r_{calitn}\), \(r_{calitn}\)).

#### Range in \(\phi\)

For both the barrel and end-cap detectors space-points are selected which have a \(\phi\)-value compatible with the RoI width at the calorimeter (\(\phi_{RoI}\), \(\phi_{RoIMax}\)) for tracks with transverse momentum \(p_{T}\) above some threshold value. The \(p_{T}\)-threshold corresponds to the gradient \(\alpha_{Max}\), of a line in the (\(r\), \(\phi\)) plane or (\(z\), \(\phi\)) plane for barrel and end-cap respectively. For the barrel, points are selected lying within a cone in the (\(r\), \(\phi\)) plane bounded by the (\(r\), \(\phi\)) points (0, \(\phi_{RoIMax}-\alpha_{Max}r_{caln}\)), (\(r_{cal}\), \(\phi_{RoIMax}\)) and (0, \(\phi_{RoIMax}+\alpha_{Max}r_{caln}\)), (\(r_{caln}\), \(\phi_{RoIMax}\)). Points are selected satisfying the requirements:

\[\phi_{RoIMin}-\alpha_{rMax}(r_{caln}-r)\ \ \leq\ \ \phi\leq\ \ \phi_{RoIMax}+\alpha_{Max}(r_{caln}-r) \tag{8.3}\]

with \(\alpha_{Max}\) the maximum allowed slope in the (\(\phi\), \(r\)) plane (based on the minimum \(p_{T}\)-value).

For the end-cap part a similar expression is valid with \(r\) replaced by \(z\), and \(\alpha_{Max}\) replaced by \(\alpha_{max}\) (maximum slope in the (\(\phi\), \(z\)) plane).

### Performance results for post-selection algorithm

The performance of the space-point selection has been determined by exploiting information contained in the data files on the particle that caused any given hit. For the single \(p_{T}\) = 30 GeV electron events with pile-up the RoI will in general have been triggered by the electron and the RoI position will be defined by the position of the calorimeter cluster due to the electron. The selection criteria should have good efficiency for the space-points due to the electron, whilst rejecting space-points due to minimum bias, noise and ghost points due to the incorrect association of \(\phi\) and stereo information.

Distributions of the residuals, \(\Delta z\), with respect to a line from the origin to the calorimeter cluster are shown in figure 8.2 for space-points due to the electron and in figure 8.3 for the other points in the RoI (barrel part). The corresponding distributions of the residual \(\Delta r\) for the end-cap region are given in figure 8.4 and figure 8.5. It can be seen that a cut on this quantity can reduce the number of points passed on to the FEX stage whilst maintaining a good efficiency for the trigger particle.

The mean fractions of space-points, passing the selection cuts (8.1) to (8.3), are given in table 8.1. The data volume can be reduced by about 45%, for a 3% loss of efficiency for the space-points due to the trigger electron. However, more detailed studies are required to optimise the cuts and to determine their influence on the speed and efficiency of the FEX algorithm. This selection step has been incorporated as an option into the space-point formation algorithms and so no separate timing measurements are given.

## 9 Summary and conclusions

### Total data preparation time

The total time taken for all steps of the data preparation are given in table 1 for RoI in single electron events with pile-up and RoI in jet events with pile-up. Separate times are given for the SCT algorithms alone and the SCT plus pixels. The corresponding distributions of data preparation time are shown in figure 1 and figure 1 for the timing measurements made on a Pentium II. Also shown on these plots are curves for the fraction of RoIs with a data preparation time below a given value.

The mean data preparation time is 199 \(\upmu\)s for the SCT with 90% of the RoIs taking less than 225 \(\upmu\)s. When the pixel data is included, the mean time rises to 545 \(\upmu\)s with 90% of the RoIs taking less than 650 \(\upmu\)s. The significant increase in execution time when the pixel data are included is due to the fact that the data are selected from a larger solid angle in the pixel detector due to the effect of detector modularity and the size of the interaction region along \(z\). In addition LUTs have not been exploited as fully in the implementation of the pixel algorithms as for the SCT. By using a LUT for the calculation of the space-point in cylindrical co-ordinates, the execution time of the pixel algorithm could be significantly reduced (by about 50 \(\upmu\)s on a Pentium II). The effect of the resulting loss of precision has yet to be quantified.

### Influence of cache size and speed on PowerPC performance

The total data preparation times are shown in table 2 for several different combinations of cache memory size and speed. Whilst the smallest execution times are obtained with a 1 MB cache with the same speed as the CPU (315 MHz), the performance is only slightly degraded for configurations with smaller or slower cache. With no cache memory, however, the execution times increase significantly.

### Implementation of data preparation algorithms

The data preparation algorithms process the data from one module11 at a time. This means that they may be implemented on the processors of the ROBs, the **ROB** to **Switch Interface (RSI)**, the **Switch** to **Farm Interface (SFI)**, the FEX farm or in processors dedicated to data preparation (e.g. FPGA). The total CPU requirement for the data preparation is significant (the mean execution time is about 550 us per RoI) and, in the current design, the processors of the ROB complex are already fully occupied. Therefore implementation in the FEX farm or on dedicated processors is the most attractive solution if the data preparation is to be implemented in one place. However, it would also be possible to split the implementation of the various stages of the data preparation across a combination of these processors. An advantage of performing some processing at the ROB is that this data could be added to the event thus avoiding the need for recalculation at the event filter.

\begin{table}
\begin{tabular}{|l|c c|} \hline PowerPC configuration & SCT + pixel detector & SCT \\ \hline
1 MB, 315 MHz cache & 650 & 173 \\
1 MB, 105 MHz cache & 656 & 174 \\
256 kB, 315 MHz cache & 659 & 172 \\ no cache & 691 & 179 \\ \hline \end{tabular}
\end{table}
Table 2: Mean total calculation time [\(\mu\)s]

Figure 1: Total calculation time of the data preparation, Figure 2: Total calculation time of the data preparation, Pentium II, SCT + pixel detector, electron + pile-up RoIs. Pentium II, SCT, electron + pile-up RoIs.

The initial data selection step is relatively fast (the mean processing time is about 20 us) and results in a reduction of data volume by about a factor of three. It is therefore a strong candidate for implementation on or close to the ROBs.

The clustering stage is also relatively fast for the SCT and results in some reduction of data size. The SCT clusters contain the full information and could replace the raw data in the ROB, thus removing the need for this stage to be repeated at the event filter. For the pixel detectors, the data size is larger for clusters than for the raw hits due to the number of words that are required to store the cluster information. Despite this increase in size, there is some loss of information (on cluster shape) and the hit data must be retained to allow re-clustering to be performed in the event filter. The execution time for the end-cap pixel clustering algorithm is relatively fast (about 25 us), but the clustering stage is about 8 times slower for the barrel pixel algorithm.

The space-point formation stages have somewhat longer execution times (mean execution time 150 us) and are most likely to be implemented in the FEX farm or possibly in dedicated processors. Some reduction in data size is possible if only the subset of the space-points lying within the RoI is selected for output. Space-point information is not used in the offline software, and is thus less likely to be required at the event filter.

## References

* [1] J.T.M. Baines, R.J. Dankers, S. Sivoklokov, _Performance of a LVL2 Trigger Feature Extraction Algorithm for the Precision Tracker_, ATLAS DAQ note in preparation.
* [2] PowerLogix R&D Inc., _PowerForce G3 Installation Guide_, [http://www.powerlogic.com](http://www.powerlogic.com).
* [3] ATLAS Inner Detector Community, _Inner Detector Technical Design Report Volume 1_, ATLAS TDR-4, CERN/LHCC 97-16 (1997).
* [4] A. Dell'Aqua and al., _1997 ATLAS Jet Production_, ATLAS note PHYS-NO-102 (1997).
* [5] ATLAS Trigger Performance Group, _ATLAS Trigger Performance Status Report_, CERN/LHCC 98-15 (1998).
* [6] F.J. Wickens, _Proposed Data Formats for T2 Demonstrator Program_, (1996).
* [7] R. Bock and P. LeDu, _Detector and Readout Specifications and Buffer-RoI Relations for the Level-2 Trigger Demonstrator Program_, ATLAS DAQ-NO-62 (1997).
* [8] V.A. Charlton, _Optimising the Grouping of Wafers in SCT Readout Buffers Using Simulated Annealing Methods_, ATLAS DAQ-NO-52 (1996).
* [9] ATLAS Inner Detector Community, _ATLAS Inner Detector Technical Design Report Volume 2_, ATLAS TDR-5, CERN/LHCC 97-17 (1997).
* [10] S.J. Haywood, _Helix Fits with Stereo Measurements_, ATLAS INDET-NO-095 (1995).
* [11] S. George, J.R. Hubbard and J.C. Vermeulen, _Input Parameters for Modelling of the ATLAS Second Level Trigger_, ATLAS DAQ-NO-070 (1997).
* [12] ATLAS Inner Detector Community: _ATLAS Pixel Detector Technical Design Report_, CERN/LHCC 98-13 (1998).

## Appendix A Calculation of spa c e-points

In this appendix the derivations are given for the longitudinal co-ordinate measured by barrel and end-cap SCT modules. A module consists of two detectors, a "\(\phi\)-layer" and a "stereo-layer". The "stereo-layer" is rotated about the module centre by an angle \(\alpha\) with respect to the "\(\phi\)-layer". Each detector has strips which measure a local transverse co-ordinate, \(T\). By combining a transverse measurement in the "\(\phi\)-layer" with a measurement in the "stereo-layer", a longitudinal co-ordinate, \(L\), can be determined. In the barrel SCT the detector strips are parallel, in the end-cap the strips have a radial geometry.

### Barrel SCT

The local co-ordinate system of the module is defined with its origin at the centre of the module, an \(L\)-axis along the \(\phi\)-strips direction and a \(T\)-axis in the plane of the module perpendicular to the \(L\)-axis. The co-ordinate system