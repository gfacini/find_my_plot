**Towards a Software Development Process for Atlas.**

S. M. Fisher, _Rutherford Appleton Laboratory_

and K. Bos, _Nikhef_

11 January 1996

## 1 Introduction

A software development process is a recipe for producing software. Following the recipe does not guarantee good results but it does encourage consistency. A process defines steps and deliverables associated with each step.

Writers of particle physics software have learned to used various techniques but have not adopted a complete set of procedures to produce software.

Having a software process which has defined deliverables means that it is possible to measure and manage the software development process. The ESA standards of PSS-05 have been presented at CERN. They define a set of deliverables and a rather simple process for going from the first deliverable to the last. These standards do not appear to be a very good starting point. Because they were designed before Object Orientation became the accepted standard, they have an old fashioned feel to them and they demand a lot of report generation. The ESA standards are oriented towards externally contracted software production whereas we expect to write our own software.

John Deacon presented to Moose1 an outline of a _Software Development Process Template_ which is being designed for OO development with a conventional OO language such as C++, Eiffel or Smalltalk.

Footnote 1: Moose is CERN RD41 which is studying OO in the offline. The majority of its members are from Atlas, and are developing code for Atlas

We have also been exposed during a recent course to the ideas of John Daniels, who, with Steve Cook wrote a book: _Designing Object Systems: object-oriented modelling with Syntropy_. The course and the book both contain some very interesting ideas on the process of software development.

In this document we present John Deacon's Software Development Process Template, and some ideas from Syntropy, then explain how far it corresponds to what Moose has been trying to do, and finally we suggest how we should make modifications for our ownuse and get started defining an Atlas Software Process.

The process will lead to a number of new roles to be filled and can be expected to have a major impact upon the way we work together.

It is anticipated that it will be possible for us to co-operate to improve the software in a consistent way, and that we will know exactly when the next release will be available and what we expect to be in it.

We are making quite a large step and do not expect to get the software process definition just right first time, but because it will be clearly defined in writing (and maybe also as diagrams) we will be in a good position to refine it according to our needs.

## 2 A Software Development Process Template

A template2 is described because no single process will suit everyone.

OO development is iterative and the only way to control an iterative development is to have a linear schedule of iteratively developed deliverables.

Footnote 2: The whole of section 2 is a summary of a presentation to Moose by John Deacon

Finding the right granularity of deliverable is important as is good version and configurationcontrol. Tools will be needed to support the process.

The template defines a number of phases. There will be a lot of iteration, however a phase should not be started before an earlier one has begun.

Note that there is _no global specification_.

### Phase 1: Inception

A statement of purpose is formulated and a feasibility study is carried out. Deliverables are very short documents of no more than one page: a "statement of purpose", "constraints and risks" and "key requirements" along with a "feasibility assessment" which will often be a substantial document.

#### 2.1.1 Capture key requirements

First capture of the (sometimes) most obvious requirements. These will be included later in the more detailed requirements.

#### 2.1.2 Statement of purpose

Here we ask why the system is being built and what difference it will make. If the statement of purpose is longer than half a page it indicates that thinking is poorly focused on the problem to be solved or that the problem is actually several problems and should be split.

#### 2.1.3 Identify architectural constraints

There may be none. But often hardware or software constraints are imposed for example the Atlas decision to standardise on Unix.

#### 2.1.4 Carry out a feasibility study

This involves some global planning to see if it is feasible, technically, financially and culturally, to produce the desired system. Excessive optimism is to be avoided. Estimates should be made of the time needed, the number of people and the likely volume of code. A cost/benefit analysis should be included in the study.

### Phase 2: Recurring and continuous tasks

This phase is going on all the time after the inception phase. It includes refining the template for the software development process, risk analysis, estimates, planning and reviews.

#### 2.2.1 Customise and refine this template

An essential part of the process is improving the process itself. This is not an easy task: only at level 4-5 on the SEI scale are you supposed to be able to control the process in this way.

#### 2.2.2 Carry out risk analysis

Risks are all factors which could endanger the project. All risks should be quantitative. For many projects, only the path to success is considered; the potential threats to success, however, should also be carefully studied. We must find out what to measure to ensure that we are on the right course.

#### 2.2.3 Make estimates

Estimation should be used for all parts of the work. Someone must look after this job. Restimating should be seen as an opportunity, rather than as an admission of failure.

#### 2.2.4 Planning and control

This includes work breakdown, time and effort estimation, dependency and critical path analysis, publication of plans and collection of statistics.

#### 2.2.5 Reviews

These can range from informal developer driven walk-throughs to more formal inspections so that some piece of work can be approved. Informal inspections or walk-throughs are developer driven. It needs a good "culture" such that developers want their code to be studied by someone else. A walk-through is managed by a "moderator", and discrepancies will be discussed and may be left undecided. Formal inspections are control driven. Here the management requires code to be inspected before going into production. An inspection is driven by an "inspector general" and discrepancies will have to be sorted out.

#### 2.2.6 "What-if" testing

Here one considers likely changes, and assesses the impact of accommodating them. Software should be designed with change in mind. You must ask "what if, this change happened to the system?" The result should be documented, typically one page on each scenario thrown at the "what-if" case. What-ifs can also be exercised on the project itself: "What if key people leave?" or "What if the budget is reduced by 50%?"

### Phase 3: Initial planning

Here personnel are assigned to the project, a training plan is formulated, and tools, standards and style options are chosen. This normally only occurs once during a project.

#### 2.3.1 Allocate key personnel

People are needed to fill various roles. In some cases more than one person will be needed, and in others a person may fulfil more than one role. The roles include:

**architect**: should to be able to overlook the whole problem domain, be able to partition it in sub-domains and know about the relationships between them. The architects overall vision continues throughout all phases of the project. Booch claims that you might still fail with a good architect, but you will almost certainly fail without an architect.
**class**: **librarian**: authorises a new class, and approves its interface. The librarian is not the person who maintains the libraries, he is primarily concerned with class interfaces.
**standards**: **monitor**: ensures that standards are being followed.
**project**: **documentation**: **librarian**: is responsible that all documentation is available and up to date. These documents include those describing the process. Note that this is quite distinct form the role of the class librarian.
**change**: **control**: **authority**: is in charge of allowing changes to the system, based on an analysis of their impact. A strict scheme for change is to be followed for all changes to any part of the system.
**statistician**: **or metrics collector**: responsible for defining a useful set of metrics and making sure that the information is collected.
**toolsmith**: **is responsible for making sure that we have the tools we need, and that they work together.
**method**: **(formalism)**: **champion makes sure the method is followed. The method again comprise the method for process control as well as the class design method.
**object**: **(class)**: **wizards**: are experienced designers who are able to pass on their knowledge to others.

**"The management"** is needed to provide inspiration, to obtain money, people, office space and coffee machines, and to ensure that the work is properly focused.

#### 2.3.2 Consider tools and notation

Tools must be selected and notation agreed upon. Items to be selected include: methods, CASE tools, languages, databases, configuration management tools and graphics packages.

#### 2.3.3 Plan training

Plan to provide sufficient trained people to fill all jobs for the project. Some retraining during the project will be required as will training for new people as they come in.

#### 2.3.4 Standards and styles

Evaluate standards and style options and make initial choices. This effects all activities, but becomes particularly important during design and coding.

### Phase 4: Requirements capture

This should define the boundaries of the system to be built: what goes in and what comes out but not the internals.

#### 2.4.1 Requirements

The job is not to build a model but just to list, probably in simple English, what the system must do, what it should do, and what it would be nice for it to do. One should avoid drifting into analysis at this time. Requirements must be measurable and there should be a priority scheme to show the relative importance of different requirements. A document should be produced with typically a short paragraph for each requirement.

#### 2.4.2 Implementation requirements

If there are implementation requirements--choice of language for example--they should be kept separate from, and not confused with, the "true", i.e. external, requirements.

### Phase 5: Analysis

Problem domain analysis and existing solution analysis. This is real analysis and not problem domain driven design which will be described in section 2.6. It is not necessarily object oriented as much of the world doesn't behave like objects sending messages to each other. There are two aspects to analysis:

#### 2.5.1 Problem domain analysis

We have to understand how our part of the world works--the context of the system-to-be. Most worlds are object based and JSD describes a subset of object-orientation that is applicable to the real world. occasionally, something non-object-based might be clearer--DFDs for example. It is not possible to prescribe a particular type of deliverable but the deliverables should include references. Analysis is strongly coupled to requirements capture and it is likely that the two activities may benefit from each other and should be worked on in parallel.

#### 2.5.2 Existing solution analysis

This is the only activity where the phrase "systems analysis" is truly accurate. It should be done by a different team from that looking at the problem domain and in many cases it is not necessary or even feasible. Early structured analysis suggestions made this mandatory but given the time it takes and the difficulty of doing it, especially for existing computer solutions, we won't always do it.

### Phase 6: Problem-driven modelling

The main activities are problem space (domain) partitioning and the production of a first type-relationship-attribute model. Use Cases and CRCs may also be developed.

Note that this phase is often referred to as analysis--but the process described here involves _invention_ so it is design.

It is difficult at this stage to stay with the problem and not work on the implementation. Generally we have a much better knowledge of the problem than of the implementation and so it is worth exploiting this advantage before going on to implementation-driven modelling. A good way of distinguishing this specification model from the implementation model is to realise that the specification model doesn't change from solution to solution and that it is "fact-based".

#### 2.6.1 Problem space (domain) partitioning

This involves breaking the problem down into sub-problems. Once the interfaces between the problem partitions have been established they can be worked on in parallel with little coupling between them. It is also important in this step to define the boundary of the problem domain. Deliverables are:

* list of types belonging to each domain
* dependency graph with the domains and their essential interactions

#### 2.6.2 Find counterparts

Here we relate the real-world agents (objects) to the solution objects. Some objects will have counterparts3 in the other domain but others will not.

Footnote 3: JSD supports the notion of counterparts

#### 2.6.3 First pass type-relationship-attribute model

First some definitions so we know exactly what is meant. Two objects are of the same _type_ if they have the same interface, i.e. if they can be interchanged. Two objects are of the same _class_ if they are of the same type (same interface) and have the same implementation. The notion of type is stressed to make it implementation independent. Types can be thought of as classes, however in the solution driven modelling of phase 8 some adjustment will normally be needed.

Our notion of an _attribute_ is ODMG based, an attribute does not necessarily correspond to an instance variable. An attribute is anything that can be queried without changing the state of the object (no visible side effects). An attribute can therefore be an instance variable or a method which only returns a value.

An essential part of this stage is to draw up the relationships between the types in the model. The inheritance relationship or subtype/super-type relationship is between types. Any other relationship (aggregations and associations) are between objects. It is therefore important to get the sub-type/super-type relationships right in the beginning because they are difficult to change. Aggregations and associations can more easily be modified because they are behind the object's interface. Deliverables are:

* Type-relationship diagrams showing: sub-type/super-type relationships, associations, aggregations and cardinalities.

Note: Avoid putting too much information in one diagram, but draw several with different purposes.

#### 2.6.4 Use Cases

Use Cases should explore the critical requirements to be met by the system. Use Cases aresimply text and might have been prepared before this phase. In more complex systems the number of all possible use cases can be very large and ones should concentrate on the most illustrative or critical ones, for example those suggested by the requirements. Each Use Case should not take more than 1 or 2 sides of paper. It'simportant to know which event triggers the Use Case and what information is carried by this event. Another important question to ask in the study of a Use Case is what goes in and what comes out and how has the state of the type changed. Deliverables are:

* Use Case descriptions

#### 2.6.5 CRC workshops

CRC workshops introduce the concept of services into the model. It's not enough to look at types in isolation. They are driven by the Use Cases and again one should limit oneself to the most critical ones. Deliverables are:

* updated type list
* updated type-relationship diagram
* an OIG for each Use Case studied

#### 2.6.6 Modal types identification, prioritisation and modelling

At this stage the types which are sufficiently complex or modal that they require a state machine inside them are identified. State machines are hard to produce and to check and so should be avoided when not necessary.

### Phase 7: Initial planning of delivery staging

It is good to realise that it is difficult to build a big and complicated system at the start. Complicated systems should be built in stages and more functionality added at every step. A staged delivery is useful for early identification of critical aspects in the project. They are also very good for communication with the end-user who can give input before the complete system has been built. Deliverables are:

* a staging plan
* recurrent progress reports

### Phase 8: Solution-driven modelling

At this stage we go from types to classes and carry out internal class design. In going from types to classes we must also go from inter-type relationships to inter-class relationships and decide how to implement each one. In the implementation we don't worry any more about the analogy with the real world for what we are doing. The deliverables of this phase will be the class interface definitions and working code.

#### 2.8.1 Sub-system planning

This step is very much like the problem space partitioning in the problem driven modelling phase (see section 2.6.1) and follows on from there. The deliverables are similar but are now for the implementation:

* architectural model showing class domains and their dependencies
* class domain interface definitions

#### 2.8.2 Class categorisation

Here we find the categories of classes which share a mission or a technology. Deliverables are:

* lists of classes by category
* a graph showing the dependencies between the categories

#### 2.8.3 Class definition

Types are replaced by one or more classes and their interfaces are fully defined. There is no need to put everything in diagrams any more at this stage. The deliverable is:

* class interface definitions

#### 2.8.4 Object linkage design

Some of the object linkages will have been identified in the type-relationships of section 2.6.3. With the move from types to classes other object linkages will be necessary. Normally sub/super-type relationships will be implemented by inheritance, but this need not be the case. Other questions to be decided for each association are: to use value or reference, to have exclusive or shared possession, and for the association to be dependent or independent. In addition a choice has to be made for a deletion strategy and how to implement associations (especially for the symmetric cases). Deliverables are:

* class relationship diagram
* full specification of all relationships

#### 2.8.5 Coupling, cohesion, elegance, necessity etc

In this phase, which is recurrent, the quality of the design is assessed against criteria, many of which date from SA-SD. The design might be too inflexible or unnecessarily complicated. The use of design patterns should be considered. One may partly redesign and ask for informal walk-throughs. Classes may come and go or have their interfaces modified. Deliverables are:

* revised versions of deliverables from this solution driven modelling phase
* results from inspected designs

#### 2.8.6 Internal class design

Input for this phase (in addition to the deliverables from this solution driven modelling phase) are the object interaction diagrams from section 2.6.5. All services specified in diagrams and text must now be implemented in code, which should include preconditions and postconditions. Deliverables are:

* full class implementations--i.e. code

#### 2.8.7 Re-assessment and refinement

This is another recurrent task. Walk-throughs and inspections will help as will the assistance of the class librarian. The inheritance structure will have to be critically revisited. Names for classes and their services have to be looked at again. Names should where possible need no documentation. Similar names should be used for similar services and different services must have distinct names.

## 3 Sputropy

A number of Moose attended a course given by John Daniels a co-author of the book: _Designing Object Systems: object-oriented modelling with Sputropy_. The course and the book (part five) both contain some very interesting ideas on the software development. It is only about 20 pages in the book and is well worth reading. They consider a software system to be the product of craftsmen rather than of engineers. During the Sputropy course ideas were presented which were a development of those in the book, so if you read the book you will find some differences from what we describe below.

### Design process

This starts with obtaining the user requirements, then defining a software architecture and building an abstract specification model.

Then from these two ingredients the detailed design is carried out and the implementation model constructed and the code written.

### Evolutionary Delivery

Develop in a number of cycles of _fixed duration_ where each cycle build on previous work to deliver a new working system of _production quality_. This way risk can be managed because at the end of each cycle any problems are very apparent. The software is built incrementally with milestones measuring completion of demonstrable software, not designs.

### Development Cycles

They point out the importance of separating the design process from the management process and suggest that the management process should be formal, cyclic and evolutionary, whereas the development process should be informal and with the minimum of constraints.

There is an initial preparation stage which is launched by the project manager and carried out by the core team as defined below. This includes some level of project definition, a feasibility study, some modelling and identification of domains, definition of an overall system architecture, selection of tools and techniques, the allocation of responsibilities, the specification of deliverables and detailed planning of the first cycle and a sketch of the next cycle.

After this the objectives for the first cycle are defined and then agreed with the developers who then go into their first cycle. They design the software to meet the objectives, write the code and integrate and test it then offer their new system up for review. If it is accepted then they agree upon the objectives for the next cycle and go round again.

Cycles should be planned to allow progress within each domain. Do not delay in starting work on some domain. That might turn out to be the one which is hard, and you will not get a complete system at an early stage.

### The core team

A core team should be constructed, made up of:

Project Manager responsible for development planning, reporting and coordination.

Systems/Software Architect responsible for making the thing work and must understand every aspect of the system.

Problem domain specialist

User representative ensures that the project goes the right way for the users Project Administrator ensures that project procedures are followed, gathers metrics, collates and indexes documents.

They, with assistance from others as necessary will carry out the initial preparation as defined in the previous subsection, will ensure compliance with requirements, take or approver crucial design decisions, monitor and update development team cycle plans, accept or reject a cycle and keep documentation under control.

### The development team

A development team will typically be responsible for a domain. It will have a leader and if it is very large a part-time project manager. The team may choose to build throw away prototypes from time to time to try things out. The team is responsible for the complete life-cycle of that domain (specification, design, code and testing)

### Deliverables

These will probably include (in addition to the code):

* Requirements specification (both functional and otherwise)
* Architecture guide (which explains the overall system structure and why it is that way.) This is _very_ important.
* Domain specifications (both internal and external)
* Test plans and results
* The project diary which records all important decisions along with an explanation.
* User documentation

Most of these deliverables are updated through the lifetime of the project.

## 4 What Moose has done so far

Here we summarise any accidental correspondence between what Moose have been doing and the template of John Deacon.

### Inception

We have a "problem statement" corresponding to sections 2.1.2 and 2.1.1. Architectural constraints were not identified nor was a feasibility study carried out.

### Recurring tasks

We did make some small attempt to define and subsequently refine a process (section 2.2.1 with the code inspections--but we have a long way to go. We have made some estimates but not based on any real appreciation of the problem, nor have we recorded them and tried to improve our estimations. We have done many of the things for section 2.2.4, planning and control. We have carried out both reviews and inspections, though the inspection procedure also had some aspects of a review. "What-if" testing was not done in a formal way, though we have considered from time to time how easy it would be to add to the work we have done.

### Initial planning

It would be hard to link many of the roles in the list (section 2.3.1) to people. We did not have an architect not did we have a class librarian to worry about class interfaces so it was at times difficult to persuade people to adopt a common style. As we had no standards monitor we did veer from standards when it suited us. A few people have tried to produce some low level of project documentation, but no-one feels that this is his particular responsibility. We did have a change control authority but no mechanism to approve changes. We had no metrics. A number of us were interested in the tools. As we were investigating different methods, a method champion would have been inappropriate. Many of us learned how to design for and code in Eiffel--probably a little of this expertise was shared in the code inspection process, though a more informal walk through might have been better for this. For the purpose of the pilot project we made choices for tools and notation, arranged training and devised coding rules for Eiffel.

### Requirements capture

We had few requirements, and it is not clear which belong as key requirements (section 2.1.1) and which come down in section 2.4. We did not identify implementation requirements, though of course the choice of Eiffel was one.

### Analysis

The problem domain analysis and the existing solution analysis were done together by the same people. It involved reading the FORTRAN and talking to its author, and resulted in a short document describing the original algorithm.

### Problem-driven modelling

Most of these steps were followed but we were already working on the solution and thinking about real classes rather than more abstract types. We had no deliverables other than OIGs and class diagrams. We found no need for any state machines.

### Initial planning of delivery staging

We did not consider staging delivery. This was perhaps not too unreasonable for a small pilot project.

### Solution-driven modelling

All this had been merged in with the problem-driven modelling.

## 5 Where should Atlas be going

Here we discuss how we would like to change John Deacon's template and the procedures outlined in the Syntropy course and book to become the Atlas Software Process.

### Influences from John Deacon

Here are the sort of changes we would expect to make to John Deacon's template in producing the definition of the Atlas Software Process.

#### 5.1.1 Changes to Phase 1: Inception

A statement of purpose (section 2.1.2) should be a short piece of text. It might only be a sentence or two. Key requirements (section 2.1.1) should be stored as a list of points, again as simple text. The two documents should be separate, though the "statement of purpose" might be expected to be very small, so that they can be approved and managed separately. A list of architectural constraints--or perhaps more generally implementation constraints should be prepared in a third document. It is not clear that a formal feasibility study is useful for most of what we do, though in some cases simulation of a complex system may be desirable.

#### 5.1.2 Changes to Phase 2: Reurring tasks

The document describing the software process will be treated like any other document of the process. It will be regarded as part of the process and not part of some larger organisation, so that two projects within the same organisation may have a slightly different software process. Naturally those concerned for the process within a project will watch the evolution of the processes of other projects--which is easy if they are documented.

Risk analysis sounds like a good thing but we have little or no experience of it. It seems easy to identify risks but not to quantify them so we suggest that a document should be maintained listing risks which we have identified and if possible quantifying that risk.

We may not be much good at making estimates, but at least if they are recorded and we re-estimate as necessary then we should get better at it. In some cases the cycle period may oblige us to say how much we will do in a certain period rather than how long a task will take.

The planning documents should be subject to the same version and change control mechanisms as the rest of the software.

We already have an effective procedure for reviews, though we need to test it out on designs.

What-if testing should be tried as soon as possible. A document should be produced listing the thought experiments which have been carried out and the results.

#### 5.1.3 Changes to Phase 3: Initial planning

It is not clear that Phase 3 of "Initial planning" might not be merged with Phase 1 of "Inception", unless the idea was that phase 1 would never be revisited. We would prefer to merge Phases 1 and 3 and call then just "Preparation" and take Phase 2 out of the list of phases and into the introduction. For each role to be filled we need a job description. In addition to the list of roles on John Deacon's list we need a chief tester--someone who takes a delight in breaking things, and a "language lawyer" to ensure that only code which is standard _and_ swallowed by most compilers is accepted.

#### 5.1.4 Changes to Phase 4: Requirements capture

We would prefer to abandon this phase and leave all requirements capture to phase 1. More requirements might come out of the analysis phases and so require an update to the requirements document.

#### 5.1.5 Changes to Phase 5: Analysis

This seems fine.

#### 5.1.6 Changes to Phase 6: Problem-driven modelling

This seems fine--but see phase 8.

#### 5.1.7 Changes to Phase 7: Initial planning of delivery staging

It is not clear where this phase should go. It is a refinement of the planning of phase 2 and could result in similar deliverables except that the planning stages can be better defined and the coding and acceptance procedures may be included.

#### 5.1.8 Changes to Phase 8: Solution-driven modelling

A lot of iteration can be expected between phases 6 and 8.

### Influences from Syntropy

This encourages us to prevent the management process unduly constraining the development process, to adopt evolutionary deliverables and to build up the right teams. Also if we look at the rest of the Syntropy material we see whereas John Deacon does his best to avoid state machines (because he believes that people can't or won't get them right) Syntropy favours them.

#### 5.2.1 Changes from Design Process

The interesting characteristic of the design process is the emphasis on separate specification and implementation models.

#### 5.2.2 Changes from Evolutionary Delivery and Development Cycles

We should use short cycles (8 working weeks, or maybe less for each cycle down to a fully documented though incomplete system), and then improve things later.

A mechanism needs to be invented for what happens when one development team has their work rejected.

Testing releases and porting to other platforms might go on in parallel, but this is probably after the next cycle has started. Cook and Daniels seem to suggest that not every cycle will be released.

#### 5.2.3 Changes from the Core Team and the Development Team

Perhaps the core team should be augmented by one member of each development team. This might produce rather a large core team, which would then need an executive to get things done but will ensure good communication.

If we assume that the other roles defined by John Deacon must be filled we need to work them into the structure somehow.

#### 5.2.4 Changes to deliverables

The list seems rather short--though this depends on how one interprets "Internal Domain Specifications". It is clear that the deliverables (other than the code and user documentation) serve not only to allow development teams to define their interfaces cleanly but also to act as internal documentation which is especially useful when someone is new to a domain. The definition of the deliverable in conjunction with the definition of the review process must ensure that deliverables are useful.

### The next step

With this background we now feel confident to have a first go at defining an Atlas Software Process. We like the dynamics of the Syntropy process but we probably need some of the detail provided by John Deacon.

The process and its deliverables will probably be described by text but based on an essential or specification model of the process.