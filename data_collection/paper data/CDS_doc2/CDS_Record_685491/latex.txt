# H8 ATLAS pixel test beam analysis program User Guide

A. Andreazza, T.Lari, C. Meroni, F. Ragusa, C. Troncon

_Dipartimento di Fisica, Universita di Milano and I.N.F.N., via Celoria 16, I-20133 Milano, Italy_

12th May 2003

###### Abstract

This note describes the use of the program h8 developed for the analysis of test beam data by the ATLAS pixel group. The program has been already used for several years of interesting and successful analyses.

## 1 Availability and installation

Information where to locate the sources for the package are available from the test beam analysis home page:

[http://home.cern.ch/troncon/testbeamhome.html](http://home.cern.ch/troncon/testbeamhome.html).

At present two versions are available1:

Footnote 1: The presence of the v01, v02,... suffix after the date indicates a bug-fix to the release. Details are available in the README file distributed with the program.

* h8-03.04.03.v01, to be used for data taken with the Bonn telescope (\(\geq\) 2001);
* h8-10.07.00, to be used for data taken with the CPPM Marseille telescope (\(\leq\) 2000).

The 03.04.03 version contains the decoding for the data taken with the Bonn telescope, both with the Bonn acquisition system and with DAQ-1. It contains also an updated treatment of the pixel orientation and the hardcoded cut at column 9 for FEB-like chips has been removed to allow use with FED/I chips. Thisnote refers to the latest version of the program, even if most of the suggestions will work with the older one also.

To install the program first untar the distribution file. Then you need to compile and build the analysis program h8 and the run database administration utility db.

In the root directory of the distribution give the commands:

> cd devel/h8.src > gmake all > cd../db.src > gmake all > cd../../prod This will compile and build h8 and db and copy the executable in the directory prod. The compilation should work on linux (with g77 compiler) and HPUX 10.2. To port to other platforms check:

1. in the Makefiles, the relevant switches for the native fortran compiler. Be sure you have some gnu tools used (gmake, gcc, gsed, cpp).
2. in the source code there are few conditionals (#ifdef... #endif) to be defined for the used OS/compiler.

Finally, in the prod directory, create links to two directories where you store the testbeam input data files and the output ZEBRA [2] files, containing PAW [3] histograms and ntuples:

> ln -s _dataDirectoryName_ data > ln -s _ntupleDirectoryName_ ntl

Only for the 10.07.00 version, you have to create a fifo to allow for on-line decompression of data files:

> mkfifo PIPE If you work in AFS, you have to create the PIPE fifo in a local filesystem (since AFS does not support fifos). and then provide a link to the actual fifo location.

## 2 Test beam setup and information

The actual test beam setup (Bonn telescope, [4]) consists of four planes of double sided microstrip detectors and supports for devices under test, while the previous telescope (provided by CPPM Marseille and operating until June 2001) consisted of four pairs of single sided microstrip detectors[5]. The microstrip detectors, set perpendicular to the beam, form a telescope which acts as the reference detector for all the studies.

he reference system is defined having the \(z\)-axis along the beam direction and the \(y\)-axis pointing upwards. The origin of the reference system is the crossing point of the first strip laying along \(y\) and of the first strip laying along \(x\) in the first telescope plane. The other planes are positioned at positive values of \(z\). The supports for the devices under tests are labelled _demonstrator 1, 2..._ in order of growing \(z\).

For the program purposes the four strips planes are considered as four planes measuring the \(x\) coordinate (numbered from 1 to 4) and four planes measuring the \(y\) coordinates (numbered from 6 to 9). The pixel device under test is also formally splitted in two planes, plane number 5 is the \(x\) measurement and plane number 10 is the \(y\) measurement.

The devices under test are also placed perpendicular to the beam, but the supports may allow for a rotation of the device around the \(y\)-axis.

The telescope can be placed within a magnet generating a dipolar field oriented along the \(y\) direction. Since the size of the magnet is comparable with the telescope extension, the field is not uniform along the telescope. Details on the magnetic field and its use in data analysis are discussed in [6].

## 3 The run database

The information about the devices, noisy (hot) strips, alignment constant and so on is stored in a database that can be managed using the db program db -innnn|-pnnnn|-s|-dnnnn|-h [-fname -tnn -mn -on -annnnn -nnnn -snnnn] [_file_]

Figure 1: Values to be provided to the -o flag for different single chip orientation, modules have the value corresponding to orientation of chip #0.

The first option defines the main operation to be performed:

**-innnn**: insert a new record for run nnnn into the database;
**-pnnnnn**: print the content of the record for run nnnn (Fig.2);
**-s**: list the runs contained into the database (require also the -f switch);
**-dnnnnn**: dump the align data for the record of run nnnn;
**-h**: print a help text.

The other options have the following functions:

**-cn**: select the database containing information related to the devise located in the position \(n\) in the setup (so called demonstrator _n_), default is 1.
**-fname**: set the database file name. If not provided, a default name is automatically generated, based on the run number and the demonstrator position.
**-t\(\pm\)nn**: pixel detector rotation angle in degrees (default is no rotation).
**-m_n_: magnetic field flag:

\begin{tabular}{l l}
0 & magnetic field is off (default) \\
1 & magnetic field is on \\ \end{tabular}
**-on**: orientation flag: the value to be used depends on how the pixel sensor was placed on the beam. The available orientation are described in fig. 1.
**-gn**: front end data type:

\begin{tabular}{l l l}
1 & FE-A & 101 & Module FE-A \\
2 & FE-B & 102 & Module FE-B \\
3 & FE-C & 103 & Module FE-C \\
4 & FE-D & 104 & Module FE-D \\
5 & FE-I (default) & 105 & Module FE-I \\ \end{tabular}
**-rn**: data acquisition system type:

**1865d1.txt** & Page 17.

opening db for demonstrator 1 h8dbiaug02.dat

alignment data for run 1865

alignment run 1865

atan run 1865

magnetic field flag 0

front end type 5

pixel orientation 0

pixel angle 30.

hot strips per plane 1 0 0 0 0 0 0 0

8
alignment data for x planes

pl. dx dz psi omega

1 0.0000 0.0000 0.0000

2 0.2557 37.9268 -0.0084 0.0003

3 -0.6509 67.0117 0.0064 0.0004

4 -1.7063 0.0000 -0.0121 0.0006

alignment data for y planes

pl. dy dz psi omega

1 0.0000 0.0000 0.0000

2 0.0896 9.9268 -0.0084 0.0033

3 -1.6401 67.0117 0.0064 0.0035

4 -0.2937 0.0000 -0.0121 0.0025

alignment data for pixel detector

dx dy dz psi omega theta

5.9635 12.6273 240.3156 -0.0098 0.0035 0.0085

1 CPPM telescope with Sirocco read-out (default for 10.07.00 version)

2 BAT readout

3 DAQ-1 (default)

**-_annnn_** get alignment data from run _nnnn_.

**-_ennn_** get the \(\eta\) calibration from run _nnnn_.

**-_bnnn_** get the list of hot strips from run _nnnn_.

The optional argument _file_ is a text file containing alignment data, which can be obtained from a dump performed with the option -d.

The database record for a given run and a given demonstrator has to be initialized before use of h8 analysis program on that run and that demonstrator.

Options -e, -b and (with much more care) -a can be used to skip the first steps of the data reconstruction and analysis procedure described in section 4.

A printout of a record of the database is reported in Fig. 2.

## 4 Analysis procedure

The analysis of a run requires several steps:

Figure 2: Printout of a record of the database. dx, dy and dz are the differences with the nominal positions in mm. The definitions of psi, omega and theta are given in section 5.4.

1. the run must be declared to the database, providing information about the DAQ system, front-end electronics, detector orientation, its rotation angle, its support position and the presence of the magnetic field (flags -r, -g, -o,-t,-c and -m respectively, see sec. 3);
2. a mask file has to be provided, containing a) the directives to be used to build a (strip and pixel) cluster and b) a list of noisy or dead channels that should not be used in the analysis (sec. 4.1);
3. when possible, a _Time over Threshold_ calibration file (as from PixelDAQ [1]) has to be provided, to allow translation of raw ToT to collected charge (sec. 4.2);
4. noisy strips and pixels (specific of this run (sec. 5.1)) have to be identified and the corresponding list provided;
5. the \(\eta\) distribution to be used for the analog interpolation between strips (sec. 5.3) has to be calibrated;
6. the alignment (sec. 5.4) has to be performed;
7. finally ntuples with full event information (sec. 5.5) are produced.

Step 3 is optional. Step 4 and 5 can be avoided if there is another run in the database which is sufficiently similar in telescope performance. In such a case it is usually possible to use the same hot strip and \(\eta\) distribution of the other run. If during the data taking there was no physical access to the beam line between two runs (and obviously no remote change of position), also step 6 may be avoided, but it is a good rule to keep it.

The rest of this section describes the format of the files. Section 5 describes the h8 options to be used for performing the above steps.

### Mask file format

A sample mask file is shown in figure 3. The name convention of the file is maskdn_run_xxxz.dat, where \(\pi\) is the demonstrator position and _xxxz_ is the run number of four digits with leading zeros when needed. The file is looked for in the directory prod/masks.

The first three lines specify the set of thresholds to be used in the cluster search procedure, for each of the eight strip planes.

The first line specifies the minimal pulse height (in ADC counts) needed on a strip to start a cluster search.

The second line specifies the minimal value of total pulse heigth (sum of strips pulse heights) of a strip cluster in order to be accepted.

The third line specifies the minimal pulse height for a strip to be included in a cluster.

The fourth line contains a set of flags to define the pixel clustering policy, they correspond respectively to the variables idrdef, idcdef, idran, idcan, minln in the program:

idrdef is the maximum row difference for two pixel hits to be merged to form a cluster in the alignment steps;

idcdef is the maximum column difference for two pixel hits to be merged to form a cluster in the alignment steps;

idran is the maximum row difference for two pixel hits to be merged to form a cluster in the ntuple production step;

idcan is the maximum column difference for two pixel hits to be merged to form a cluster in the ntuple production step;

minln is used to define the minimum cluster size in terms on rows to be used in the alignment step: given the orientation, rotation and thickness of the pixel sensor, an expected maximum cluster size nmhexp is defined; clusters are considered for the alignment if they have a size between nmhexp+1 and nmhexp-minln.

The lines beyond the fourth line provide the list of the pixel regions not to be considered in the analysis. The fifth line contains a single number indicating the number of the following lines that have to be taken into account. The following lines contain the mask description. Each of them consist of six integers. Their meaning is:

1. first chip number (between 0 and 15) for which the line is to be used, for single chip device, only chip 0 is relevant;
2. last chip number for which the line is to be used;
3. column number of the lower-left corner of a rectangular region to be masked;
4. row number of the lower-left corner of a rectangular region to be masked;
5. column number of the upper-right corner of a rectangular region to be masked;
6. row number of the upper-right corner of a rectangular region to be masked.

In the example in fig. 3, the first mask line ( 0 15 0 153 17 159) disables the upper 8 rows (rows from 153 to 159 inclusive) of all the columns ( from 0 to 17) of all the chips (from 0 to 15) of the module, the second line disables the last 8 columns of all the chips. These two lines provide a "typical" mask for FEB modules, with the upper rows masked since the program does not currently manage ganged pixels. The subsequent two lines disable all chips but number 10, which was the one the beam was pointing at.

_Note this file is scanned by formatted read instructions, therefore the exact formatting and alignment of the items is important!_

### ToT calibration file format

For each pixel the measured _ToT_ can be related to a collected charge \(Q\) by the phenomenological relationship

\[Q=\frac{B}{ToT-A}-C\]

where \(A\), \(B\) and \(C\) are calibration constants.

The calibration constant may be read from a calibration file. The name convention of the file is caldn_run_zzxx.dat, where n is the demonstrator position 1 or 2 and _xxxx_ is the run number of four digits with leading zeros when needed. The file is looked for in the directory prod/calibrations.

Each line of the file contains the calibration constants of one pixel cell. There are two possible formats for the calibration file. The suggested one is the present PixelDAQ ToT calibration format in which each line contains nine fields:

\[chip\#\quad column\#\quad row\#\quad not\,used\quad A\quad B\quad C\quad \chi^{2}\quad flag.\]

The calibration constants are used if \(flag\) is equal to zero, any other value meaning the fit for the calibration constants determination encountered some problem and the data are not reliable. If a single pixel has no calibration, the one from one of its neighbours is used.

Figure 3: Mask file for a module on _dem1_ position during the 201 run.

## 5 Operation of h8

Once a run has been declared to the database and the relative files have been created, all the other analysis steps, as described in section 4, are carried out by the h8 program.

The general syntax is: h8 -ssl-p|-e|-a0|-d [-cd] [-rn] [-nzxxxx] -- nnnn where the first option describes the type of operation requested to the program, -c allows to specify the demonstrator position (default is 1), -r specifies the DA Q system as in the db program (default is 3), -n defines the number of events to read for that step of the analysis (default is to read the whole file) and nnnn is the run number to be analysed.

### -s: hot strip search

The hot strip search is used to look for noisy strips. After this step a set of strips is written into the database. Hits on such strips are ignored in the subsequent steps.

The default threshold for masking a strip is to ask it to be present in more that 5% of the events or that its occupancy is 4 times the average occupancy of its neighbours. These parameters can be modified in the file hotstrip.F.

At the end of the run, a file rund_nnnn_hotpixels.dat is written and contains the number of hits collected in each pixels in order of decreasing occupancy. A file rund_nnnn_mask.dat, masking pixels with occupancy >1%, is also written in the proper format to be pasted into the mask file. It can be used to derive a pixel mask for subsequent steps. If running this step again, these file should be deleted beforehand.

Hot pixels can also be searched and masked automatically using the -p option as described in the next section.

#### Histograms to look at.

The histogram file for the -s option is ntpl/rund_nnnn.rz and must be opened providing 4096 as lrecl value in the PAW command hi/file.

Histograms from 11 to 18 contains the hit distributions on the strips and can be used to cross check with the hot strips found by the algorithm (Fig.4).

Hitmaps for the device under test are on histogram 5003 for single chips and 6903 for modules. This is another way to look for noisy hits. That the proper orientation (-o flag of db) is set, can be checked looking at the raw correlation between strips and pixels in histograms 5001 and 5002 (single chips) or 6901 and 6902 (modules).

An example of histograms 5001, 5002 and 5003 is reported in Fig.5Figure 4: Hitmap for one of the microstrip detector planes. The noisy strips are clearly visible as spikes. The cutoff of the beam shape around strip 120 is due to the acceptance of the scintillator trigger.

Figure 5: Upper picture: correlation between the row of the pixel hits and the strip number of the hits in the first microstrip detector plane. Medium picture: the same with the pixel column. Lower picture: hitmap for the pixel detector.

### -p: hot pixel search

This step allows to search for noisy pixels and mask them. As an alternative, the user can look for noisy pixels "by hand", using the hitmaps or the file rund_d_run_nnnn.dat written at the end of the hot strip search step, and write the mask file.

To run h8 with the -p option, an initial mask file must be provided, with the set of flags and the lines of masked pixels (section 4.1). Note that the number of lines of the mask must be always specified, even if there are zero lines.

At the end of the hot pixel search a new mask file is written out. This is named masks/newmd_d_run_nnnn.dat and must be renamed by hand as masks/mask_d_run_nnnn.dat to be used in the subsequent steps of the analysis. It contains the pixels specified as in the initial mask file, plus the noisy pixels found by the program.

The algorithm of the hot pixel search works as follow: first it determines the most probable value of the level 1 trigger distribution \(l1_{0}\), and events with a level 1 far from the most probable value ( \(|\,l1-l1_{0}\) |\(<\) 7) are selected. If a pixel is active in a number of these off-time events larger than 32 it is flagged as noisy and masked. The parameters of the algorithms are contained in hot_pixel.inc and the algorithm itself in hot_pixel1.F and hot_pixel2.F.

Footnote 2: or a fraction 10\({}^{-5}\)of the total number of events, which is larger

### -e: \(\eta\) distribution

In this run, for all clusters with more than one strip, histograms are filled for the distribution of the variable

\[\eta=\frac{PH_{2}}{PH_{1}+PH_{2}},\]

where \(PH_{i}\) are the pulse heights of the highest strip in the cluster and of the highest of its neighbours. The observed distribution (Fig. 6) is then integrated to get the exact (not linear) relationship between \(\eta\) and the cluster position[7].

#### Histograms to look at

The histogram file for the -e option is ntpl/rund_nnn_eta.rz and must be opened providing 4096 as lrecl value in the PAW command hi/file.

There are many histograms to check the quality of the strip planes. These histograms have ID of the type offset+i, where i is the telescope plane identifier and ranges from 1 to 8 (1-4 are the \(x\) measurements, 5-8 the \(y\) measurements):

**20+i:** hit map on the strips.

Figure 6: Distribution of the \(\eta\) variable for one of the microstrip detectors planes.

**140**+i: highest pulse height in the plane, use this histograms to tune the cuts for the minimum pulse height to start clustering as described in section 4.1.
**120**+i: total pulse height for the cluster on the plane; use this histograms to tune the cuts for the minimum cluster pulse height as described in section 4.1.
**130**+i: \(\eta\) distribution for the plane.
**51**: bitted word for the hit pattern in the \(x\)-projection:

bits 1, 4, 16 and 64 are set if there is exactly one hit in plane 1, 2, 3 and 4 respectively;

bits 2, 8, 32 and 128 are set if there is more than one hit in plane 1, 2, 3 and 4 respectively.

Therefore a normal event has value 85. Events in which only one plane has no hits have values of 84, 81, 69 and 21. Events in which one plane has multiple clusters have values of 85, 99, 101 and 149. Other values correspond to more than one ambiguos or missing plane. In such cases there is no attempt to reconstruct a track.
**52**: bitted word for the hit pattern in the \(y\) projection, same meaning as for histogram 51.

Hitmaps for the device under test are on histogram 5003 for single chips and 6903 for modules. That the proper orientation (-o flag of db) is set, can be checked looking at the raw correlation between strips and pixels in histograms 5001 and 5002 (single chips) or 6901 and 6902 (modules).

### - a0: alignment

In the alignment step corrections to the nominal coordinates for strip and pixel planes are computed. This is by far the critical point in the running of h8.

#### 5.4.1 Alignment philosophy

The reference system for the alignment is given by the first microstrip plane. The distance between the first and last strip plane is fixed.

For the strips the raw point coordinates, \(x_{\mbox{loc}}\) and \(y_{\mbox{loc}}\), are simply obtained by multiplying the strip number times the 50 \(\mu\)m pitch and applying the \(\eta\) correction.

For the pixels, the conversion from the pixel hit column and row number to coordinates is not trivial, because there are different pixel sizes and orientations of the device. This information is available in the header of file transform.F.

Anyhow, the transformation from the not-aligned to the aligned coordinates is given by

\[x =(1-\Omega_{x})x_{|\text{{\sc loc}}}\,+\Delta x+\psi y_{|\text{{\sc loc }}}\,,\] \[y =(1-\Omega_{y})y_{|\text{{\sc loc}}}\,+\Delta y-\psi x_{|\text{{ \sc loc}}}\,,\] \[z=z_{\text{nominal}}\,+\Delta z\]

The \(\psi\) parameter describes a rotation around the \(z\) axis, the \(\Omega\) parameter describes a rotation around the axis parallel to the strip direction.

The alignment is performed iteratively comparing the point on the detector plane with the extrapolated track and narrowing the acceptance window for the residues at each iteration.

For each iteration the vector of parameters \(\overrightarrow{p}\) is determined as

\(\overrightarrow{p}=M^{-1}\overrightarrow{\nabla}\chi^{2}\)

with

\(\chi^{2}=\frac{1}{N}\sum_{i}\,\left(\frac{\Delta x_{i}^{2}}{\sigma_{x}^{2}}+ \frac{\Delta y_{i}^{2}}{\sigma_{y}^{2}}\right)\)

\(M_{ij}=\frac{\partial x^{2}}{\partial p_{i}\partial p_{j}}\)

\(\overrightarrow{\nabla}\chi^{2}=\frac{\partial\chi^{2}}{\partial p_{i}}\)

where \(\Delta x_{i}\) and \(\Delta y_{i}\) are the residuals between the track and the measured coordinates, computed with the current values of the alignment parameters \(\vec{p}\). The algorithm is terminated when the correction to all the parameters is smaller than the tolerance (usually a few iterations suffice) or when the maximum number of iterations is reached. At each iteration the value of the parameters and their error is written on the standard output.

In a first step, only the parameters \(\Delta x,\ \Delta y\) and \(\psi\) are fitted. This makes a rough determination of the trasversal position of the detector, bringing it "on beam". In a second step all the parameters (\(\Delta x,\ \Delta y\,,\,\psi,\ \Omega_{x}\,,\ \Omega_{y}\,,\) and \(\Delta z\)) are considered at once. The alignment procedure is performed first for the strip modules and then for the pixel detector.

To increase the alignment reliability, only events without ambiguities are used. That means only events with one and only one cluster per plane (of strips and pixel) are used.

When a nominal tilt angle \(\theta_{0}\) has been set for the pixel detector (with the option -t of db) the alignment parameters are applied on top of the nominal tilt.

The tilt angle can be computed from the final alignment parameters as

\[\cos\theta=(1-\Omega_{x})\,\cos\theta_{0}\]

In practice the formula is useful only when the tilt angle is different from zero. The alignment is not sensitive to the value of the angle at normal incidence, because the cosine is too flat a function near the origin.

#### 5.4.2 Format of the alignment record

At every iteration of the alignment a record with the status of the alignment parameters is written on the standard output. Here we describe the format of the printout record. The record looks like:

```
iteration7mode63655aligningplanes5-5withmode63
```

The mode number is a bitted word which specify which parameters must be fitted. The meaning of the bits is explained in align_planes.F.

n is the iteration number, p the plane number, from 1 to 4 for the strips and 5 for the pixels, v the view (1 for \(x\)-view and 2 for \(y\)-view). The parameters and their errors follow. Hence the two records reported above contain the alignment information for the pixel detector in the two views, after the seventh iteration.

\(\varepsilon\) is a measure of how much the parameters have changed since the last iteration and is used by the program to decide wether to stop the iterative procedure. N is the number of events used.

#### 5.4.3 Tips and tricks

Always check in the alignment print-out if everything went fine and if the final parameters make sense, especially the \(z\) alignment.

Main reason for a failure is the presence of noisy pixels or strips which bias the first steps in the alignment, forcing a convergence in a wrong position. Therefore having a good mask is fundamental. You can at first start without any mask and then disable the noisiest pixels until the alignment converges.

It is also adviced to exclude from the alignment the not standard pixels (long and ganged ones). A mask like that should fulfill the job:

3 0 15 0 0 0 159  0 15 17 0 17 159  0 15 0 150 17 159 Since the alignment is an iterative process, to avoid reading several times the full data file, the program writes information about the good events in a temporary skim file. If you have to analyse again the same run, remember to delete the skim file (skim_nnnn.dat).

The second main reason for failure in the alignment is that too few events are written into the skim file. Try to understand the reason, correct it and, if needed, tweak the code.

#### Histograms to look at

The histogram file for the -a0 option is ntpl/rund_d_nnnn_al.rz and must be opened without providing a lrcl value in the PAW command hi/file.

Histograms 10\(i\)1 contains the residue distribution for the different planes: \(1\leq i\leq 4\) for the strips \(x\) projection and \(6\leq i\leq 9\) for the strips \(y\) projection. they should have averages compatible with 0 and a r.m.s. of 5-6 \(\mu\)m (Fig.7).

Histograms 1051 to 1057 show the residues on the pixel plane along the short pixel direction, as a function of some track parameters. The projection should be centered around 0 and have a r.m.s. of about 14 \(\mu\)m (Fig.8). Profile and 2D histograms should not show any systematic behaviour.

Histograms 1101 to 1107 are the same, but along the long pixel direction (Fig. 9). In this case the projection should be a uniform distribution between \(\pm 200\)\(\mu\)m.

### -d: producing analysis ntuples

If all of the previous steps are successful, running h8 for the last time using the option -d produces the PAW ntuple for the analysis.

If masks were used in the previous steps, it may be useful to un-mask all pixels, if you plan to make studies of noise, for example, or to make some analysis on the "special" pixels.

#### Histograms to look at

The histogram file for the -d option is ntpl/rund_nnnn.rz and must be opened providing 4096 as lrcl value in the PAW command hi/file.

The ntuple 10 contains all the information about each event. It consists of three blocks. In block track the information about the reconstructed telescope track is stored. Block hits keeps the list of all pixel detector hits and clusters contains the information about the clusters built from the pixel detector hits. The detailed contents of each block is described in tables 1, 2, and 3

## 6 H8 needs you!

In this note the guidelines for the use of the h8 program to perform analysis of the test beam data have been sketched. The program has already been used for several years to perform interesting and successful analyses [8, 9, 10, 11, 12].

The authors hope this information will be useful and encourage everybody to use the program and report problem, improvements in the code and in the documentation which could make their analysis easier.

Figure 7: Residuals between the strip clusters and the tracks for the \(x\) projection. The picture show the residuals distribution (upper left), the residuals vs \(x\) (upper right), the residuals vs \(y\) (lower left) and the residuals vs slope (lower right).

Figure 8: Residuals between the pixel clusters and the tracks for the \(x\) projection. The picture show the residuals distribution (upper left), the residuals vs \(x\) (upper right), the residuals vs \(y\) (lower left) and the residuals vs slope (lower right).

Figure 9: Residuals between the pixel clusters and the tracks for the \(y\) projection. The picture show the residuals distribution (upper left), the residuals vs \(x\) (upper right), the residuals vs \(y\) (lower left) and the residuals vs slope (lower right).

\begin{table}
\begin{tabular}{l l} \hline  & **Block**hits \\ \hline nphit & number of pixel hits \\ phit(1,1:nphit) & \(x\) coordinate of the hit \\ phit(2,1:nphit) & \(y\) coordinate of the hit \\ phit(3,1:nphit) & Time over Threshold or charge of the hit \\  & (depending wether a calibration file has been used) \\ phit(4,1:nphit) & level 1 counter of the hit \\ phit(5,1:nphit) & row number \\ phit(6,1:nphit) & column number \\ \hline
**The following variables are meaningful for modules only:** \\ \hline idchip(1:nphit) & chip ID \\ irowcol(1,1:nphit) & row number within chip \\ irowcol(2,1:nphit) & column number within chip \\ \hline \end{tabular}
\end{table}
Table 2: Description of content of block hits.

\begin{table}
\begin{tabular}{l l} \hline  & **Block**track \\ \hline xs1, xs2, xs3, xs4 & \(x\) coordinates of the track points in the strip planes. \\ ys1, ys2, ys3, ys4 & \(y\) coordinates of the track points in the strip planes. \\ ax,bx,cx & parameterization of the trajectory in the \(x\) coordinate: \\  & \(x=\text{ax}+\text{bx}\times z+\text{cx}\ \times z^{2}\); \\  & cx is different from zero if there is a magnetic field. \\ ay,by,cy & parameterization of the trajectory in the \(y\) coordinate: \\  & \(y=\text{ay}+\text{by}\times z+\text{cy}\ \times z^{2}\); \\ cy is always zero (no magnetic bending in the \(yz\) plane). \\ ipatx,ipaty & Pattern of hits used for the track fitting in the \(x\) and \(y\) coordinates: \\ ipat\(=0\), normal case: each plane has one and only one point; \\ ipat\(=1-4\), double hits: there are two hits in plane ipat; \\ ipat\(=5-8\), missing hit: hit is missing in plane ipat\(-4\); \\ no track is built if there is more than one bad plane. \\ chi2x,chi2y & \(\chi^{2}\) of the track fit in the \(x\) and \(y\) coordinates. \\ prbx,prby & Probability of getting a \(\chi^{2}\) greater than the observed one. \\ tdc & Raw time from the TDC unit. \\ xepi,yepi & Coordinates entrance point on the pixel detector. \\ xepo,yepo & Coordinates exit point from the pixel detector. \\ icoli,irowi & Expected column and row at the entrance. \\ icolo,irowo & Expected column and row at the exit. \\ xloc,yloc & Expected coordinates with respect to the center of the pixel cell. \\ \hline \end{tabular}
\end{table}
Table 1: Description of content of block track.

## References

* [1] J. Richardson, PixelDAQ User Manual
* [2] ZEBRA User's Guide, Program Library Q100, CERN, 1993
* [3] PAW User's Guide, Program Library Q121, CERN, 1993.
* [4] J. Treis et al., Nucl. Instr. and Meth. A490 (2002) 112.
* [5] ATLAS Pixel Collaboration, _Pixel Detector Technical Design Report_, CERN/LHCC 98-13.
* [6] T. Lari, _Study of silicon pixel sensors for the ATLAS detector_, CERN-THESIS-2001-028.
* [7] E. Belau et al., Nucl. Instr. and Meth. A214 (1983) 214.
* [8] C. Troncon, IEEE Trans. on Nucl. Sci. 47 (2000) 125.
* [9] F. Ragusa, Nucl. Instr. and Meth. A447 (2000) 184.
* [10] I. Gorelov et al., Nucl. Instr. and Meth. A481 (2002) 204.
* [11] T. Lari, _Test Beam results of ATLAS Pixel sensors_, arXiv:hep-ex/0210045.
* [12] A. Andreazza, _Performance of the ATLAS Pixel Detectors prototype modules_, to be published in the proceedings of the 6th International Conference on Position Sensitive Detectors, Leicester (UK), September 2002.

\begin{table}
\begin{tabular}{l l} \hline  & **Block clusters** \\ \hline nclu & number of reconstructed clusters \\ cphit(1,1:nclu) & \(x\) coordinate of the cluster \\ cphit(2,1:nclu) & \(y\) coordinate of the cluster \\ cphit(3,1:nclu) & number of pixel hit in this cluster \\ cphit(4:23,1:nclu) & for each hit in the cluster (max 20), \\  & its position in the arrays of block hits \\ \hline \end{tabular}
\end{table}
Table 3: Description of content of block clusters.