**User's Guide to Software Development for ATLAS**

## 1 Introduction

This guide gives an overview of the way in which software is developed in the ATLAS collaboration. It is intended to help new programmers find their way round what may, at first sight, seem a rather complicated process of software development. The main intention is to provide some signposts, rather than to fill in all the details (which can, in any case, be found elsewhere on the Web), so this guide is written very much from the point of view of an individual joining the collaboration. It outlines the way in which software is produced and checked, working practices, and management procedures as they affect the individual. These are based on the proposals in the _Computing Technical Proposal_[1] and codified in the _ATLAS Software Process_, usually known as the ASP [2].

The ASP assumes that software development will be object-oriented (OO). The system will therefore be made up of a set of _classes_, each of which implements a number of _methods_ providing services to objects of other classes. The classes have to be designed so that together they can provide the desired functionality of the Atlas system, as specified in a list of _requirements_.

## 2 Documentation

You can find a lot of information about the organization of Atlas software, and the various people involved, on the Web at

[http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/](http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/)

It starts with some general information of interest to all developers, and then splits into pages for each _domain_ (see section 5.1). You can also access the documents cited in the bibliography from these pages.

You can find information about the following topics:

* supported computing platforms,languages and compilers
* software engineering tools
* list of domains and their architects, and detailed domain information such as: members, deliverables and work plans
* Domain Interface Group (DIG) and support team members and their functions,* schedule of Atlas software workshops, agendas and minutes
* links to the ASP and other documents.

## 3 How to get involved

The best kind of person is suggested here. You can find the actual person by looking at the Web pages.

The work is organized into domains, each with an architect. The Domain Coordinator is the person who makes sure that all the domains fit together. A fuller description is given in section 5.1.

You may belong to one of several categories.

* You are already (or shortly will be) a member of a team concerned with one of the domains into which the work is organized, but you have not yet produced any software. Contact your domain architect.
* You would like to participate, but don't have a link to any particular domain. Contact the Domain Coordinator to see where you would be most useful.
* You already have some software which is useful but has not been produced according to the ASP. Contact your domain architect to see if it might be eligible for a "ramp-up" to bring it into compliance with the ASP (see section 11).
* You would like to get involved in the review process (see section 7). Contact the Domain Coordinator: you are likely to be warmly received. Acting as a reviewer is an excellent way of finding out what is going on, and getting integrated. Don't worry if you feel inexperienced: there should be enough experienced reviewers at any time to ensure that the evaluation doesn't depend too much on one person. Obviously you must be familiar with the notations, if you are to participate in a design or code review, but you don't necessarily have to belong to the domain conducting the review, since it is a matter of principle to have some reviewers from outside the domain.

## 4 Environments and tools

The most important thing from the point of view of reading this guide is to understand that we shall be following an object-oriented design method and that our programming language will be C++. The design process is supported by the tool StP (Software Through Pictures [4]).

Organization of Work

### Domains

The work is organized according to _domains_, each of which contains the classes needed to implement a well-defined aspect of the total system. We use the word "domain" in two senses here: technically, it refers to a set of related classes, but we also use it informally to mean the group of people working on those classes. Many of our domains refer to physical subsystems (individual detector systems), but others refer to processes. like reconstruction, or to utilities, like user interface.

Each domain has a _domain architect_ who is responsible for coordinating a team of programmers working on the design and implementation of the classes in the domain. Once the external interfaces of the domain have been determined, the domain teams can get on more or less independently with their work. Defining the external interfaces is the responsibility of the whole set of domain architects working with the _domain coordinator_. The _domain interface group_, consisting of the architects, the domain coordinator and the _project manager_ keeps an eye on the system as a whole, and ensures that its development proceeds in a coherent way.

The list of domains, the names of their architects and information about work in progress can be seen on the Web.

### Development Cycles

Development is "evolutionary". The aim is to get a system with minimal functionality up and running as quickly as possible. Thereafter, development proceeds in regular cycles, each of which extends the functionality of the system or improves its performance.

Our cycles are based on the scheduling of the ATLAS software workshop, which takes place four times a year and lasts for five days. During this time, there are both plenary sessions to discuss general points and domain working group meetings. The domain interface group meets to evaluate progress during the last cycle and to set targets for the next. The meeting provides an opportunity for sorting out problems that are best dealt with face-to-face, as well as for reviewing progress.

### Deliverables

Deliverables are the tangible products of the development process. They are documents which one is obliged to produce in a certain format at various stages, and which contain the "official" description of the system as it currently exists. In fact, the project generates a substantial amount of documentation, much of it available on the Web, but only three sets of documents count as the official deliverables: the statement of _requirements_ that the system must satisfy, _designs_ in terms of class relations and object interactions, and the _source code_ corresponding to each of these designs. The content and layout of each of these types of document are defined in the ASP, and each is reviewed formally to ensure that it complies with the appropriate ASP rules. In addition, deliverables are checked for consistency with one another. Thus designs must be compatible with requirements and code with designs.

You can find more information about what goes into each of these deliverables in the ASP document. A list of the current deliverables for the Atlas software (requirements, design documents and source code) can be found on the Web.

### Project Management

The people who will be most important to you as a domain team member have already been mentioned. The person of the most immediate relevance is the domain architect, who has the responsibility for ensuring that work is allocated sensibly to the various members of the domain team, and that it is completed on schedule. At the beginning of each cycle, he will circulate information about the work plan, so that everybody in the domain knows what to do, and can see how the various bits fit into the overall plan.

The domain coordinator has similar responsibilities with respect to the whole set of domains. He must ensure that the order in which classes are developed in different domains is consistent with the dependencies between classes. He will identify commonality between classes in different domains that could result in simplification. He will also, in an informal way, encourage a common stylistic approach to design across domains, so that the system as a whole presents a coherent picture.

The project manager has overall responsibility for resources of all kinds, including people. He will not usually be concerned with the detailed organization of the work, but will set broad milestones, and ensure that they are met. He is the "interface" from the project to the rest of the Atlas collaboration and to the CERN management.

In addition to the people mentioned above, there are the members of the _support team_. They fulfil a number of specialized roles in the project, which they may combine with each other or with membership of a domain team. In general, the functions they perform are concerned with providing infrastructure for the project (eg tools support and documentation) or with supporting project management (eg collecting metrics and monitoring the ASP itself). Although you will be working in an environment set up by the support team, you may not have much direct contact with most of them. The exception is the _software librarian_ You will have to contact her when you have code ready to check into the repository.

## 6 Ensuring Quality

### Standards

Standards have been defined for all the deliverables, but the most important from your point of view are probably the design standards and the coding standards. The latter include conventions for identifier names, layout of text and features of C++ to be encouraged or avoided. In general, the aim of the coding standards is to encourage straightforward code that other people can understand and that is easy to maintain. Many of the coding rules can be checked automatically by the tool _codecheck_.

There is a similar set of rules for design documents. Some of these rules are essentially the same as those in the coding standards, since choices of names for classes and methods must be made at the design stage. There are also more subjective rules that are guidelines to good practice. For example, we suggest that a class should not have too many methods, or a method too many arguments. The actual numbers are for guidance, and what is appropriate in each case obviously depends on the role that the class will play. Again, the rules have been drawn up with a view to making designs understandable and aiding future maintenance.

You can find both the design rules and the coding rules in the ASP, and you should be familiar with these two sets of rules before you start any development work.

### Reviews

Reviews have two purposes: to help you produce working software more quickly and, from the point of view of the collaboration, to ensure that your software is of satisfactory quality. Peer review is a useful means of keeping control of software quality. Since reviews will be very important to you as a producer of software, some practical details are given in the next section.

## 7 What happens in a review

Reviews are of two kinds: the informal and the formal. In both cases, designs are checked against requirements and code against designs, but there are no set procedures for an informal review, whereas the rules for a formal review are quite strict and laid down in the ASP.

### Informal Reviews

An informal review is primarily to provide feedback to you and as soon as you have a rough design, you should ask two or three colleagues to look at your work. Documentation does not have to be in any particular format, but it shouldexplain the principles underlying the design clearly. Subsequently, frequent, quick informal reviews are to be strongly encouraged so that your work can be checked for any obvious faults or inconsistencies, The review itself may be face-to-face or by email, and should be completed within a day or two.

### Formal Reviews

#### 7.2.1 The Design and Code Reports

For a formal review, you must supply your document in a defined format. The design report can be produced automatically from your design in StP by the _design report generator_. The code report also has a defined format and must include the source code and the test results.

#### 7.2.2 The purpose of each type of review

The ASP defines rules for three types of review: of the requirements, of the design and of the code. The idea is to check the requirements against what the system actually has to be capable of doing, to check designs against the requirements document and to check code against the relevant design document. So apart from the first case, a reviewer always checks a new deliverable against an already existing document.

You will probably be involved in design and code reviews as a producer, but are less likely to be involved in formulating requirements, since this will probably have already been done previously. However, the requirements are the most difficult deliverable to review because of the lack of any input document to check against, and it is to be expected that they will have to change as time goes on. You may find that some stated requirements are unnecessary or unacceptable when you come to work on a design, and should raise the issue explicitly when you submit your design for review. Similarly, if you are working on code for an already reviewed design and have some criticism of the design, you should raise the issue at the code review.

#### 7.2.3 How a review is organized

Reviews are usually concerned with the design or coding of a package of classes forming a well-defined part of the system. The package may cover the entire domain, or for domains with a large number of classes, just a certain aspect of the domain. Unless there is a large amount of material to review, the review team will probably consist of about three reviewers and a moderator. The latter runs the review process, but does not himself review your submission. He will choose the reviewers and make sure that they have the relevant input document (the one that you worked from to develop your deliverable), the deliverable itself, and instructions on how to do the review. The review will be conducted entirely by email, so that it can be done at any time and with the reviewers in any place. The reviewers pass their comments to the moderator, who combines their reports into a single list. Each comment identiies an "issue" where, in the reviewer's opinion, you have failed to be consistent with the general rules for your type of product (eg the coding conventions) or with the constraints imposed by the input document. You may agree that there is indeed an error, in which case you say that you "accept" the issue, or you may wish to argue that it is the reviewer who is wrong. The moderator will try and resolve outstanding disagreements, but if differences of opinion remain, the issue will be thrown open to the whole group of reviewers for decision.

At the end of this process you will have a list of changes to make. If you can satisfy the moderator that you have carried them out satisfactorily, he will "pass" your product. It is then up to the domain architect to take it on to the next stage.

## 8 Testing

### The Test Plan

Each design submitted to a review must be accompanied by a test plan. This says what aspects of the system are to be tested and when, but it does not necessarily say how the tests are to be carried out, since it may not be possible to define an appropriate test until the implementation is known. Tests should check that all relevant requirements can be satisfied. They will obviously seek to check the correctness of the programming logic and, where appropriate, accuracy of numerical results and acceptable performance.

You should specify adequate tests (exhaustive testing will rarely be possible) for all non-trivial methods in your classes, particularly where a method in one class makes use of another class in its implementation. If you are responsible for the complete package, you should also specify the tests that are to be carried out on the package as a whole.

### Testing the Implementation

It is your responsibility to devise appropriate test inputs and test harnesses for the part of the system that you implement. You must be able to show that you cover all the relevant tests in the test plan, and you may also need to define additional tests to check out particular features of your code. Details of your tests and their results must be submitted with your code to the code review.

There are two kinds of tests for correctness of code, which are traditionally called "black box" and "white box". In the first, you just check that you get the right outputs from a method for given inputs, whereas in white box testing you check that the code implementing the method is executed as it should be. You are expected to carry out thorough white box testing before submitting your code for review, but no rules are laid down for what you do and your tests are not reviewed. You should however submit the results of your black box tests to the review, and the reviewers will check that your tests give reasonable coverage of the range of possible inputs and specifically check any special cases.

If the code produces numerical results that can be compared with experimental data or results from other versions of the computation, you should run tests to show that your output is in agreement to within the specified accuracy. Similarly, if there are performance constraints on certain operations, you should submit test results to show that you can comply with them. These tests are usually only required for complex operations, and may in any case have to be postponed until the code is actually in use.

## 9 Software Management

The software repository is under the control of the Software Librarian. You can check your code into the repository while you work on it, but it will not form part of an official release. After it has been successfully reviewed, it will be tagged with a version number and will then form part of the next official release. If you produce a new version subsequently, the old version will be retained, but the new version will be that incorporated in the current release.

There is a description of the configuration management system in [5]. You should consult the Software Librarian about the procedure for putting your code in the repository.

## 10 Maintenance

Users report bugs using the Gnats system, so if you find a problem, you send in a report, which subsequently finds its way to to the best person to fix it. You will be notified when this is done.

Each domain will nominate a person to be responsible for maintenance. When a bug report or a request for an upgrade comes in, it will be passed to this person, who will decide what to do next. If he thinks that the problem is in one of your classes, he will get you, as the original implementer, to fix the bug or implement the requested change.

There may be quite extensive consequences of your repair, although hopefully it will only be rarely that a class interface needs to be changed. If there are changes at the design level, you must bring the design document into conformity with the new version of the code.

It may be that the apparent failure of your code is actually a consequence of an error elsewhere. In this case, you should inform the person responsible for domain maintenance.

## 11 Ramp-up

This term refers to the procedure whereby we can incorporate existing software into the ASP-compliant "official" system. It may happen that you wish to use software developed elsewhere for your applications and want it to be formally recognized as an acceptable product, or you may have developed a program before the ASP was fully defined. In both cases, you have a working program with an associated group of users. "Ramp-up" is the process of evaluating the product and, if the evaluation is positive, bringing into it compliance with the ASP.

It is worth pointing out two cases where a product is not eligible for ramp-up. The first is external software, where we do not have responsibility for the source code, but where the product has been exhaustively tested by a large user community and may therefore be judged to be of acceptable quality. The second is new software that you can't be bothered to develop according to the ASP! Ramp-up is more expensive in terms of people's time than straightforward reviews of designs and code, and is intended for exceptional cases.

If you have a product that you think is likely to be generally useful, you should discuss the possibility of ramp-up with your domain architect. You must have a working program with the right to amend the source code. There must also be reasonably complete documentation (no-one is going to ramp-up an un-commented, monolithic program). If your architect thinks that the product has possibilities, he will call on a small group to do a quick evaluation to see whether it is worth ramping-up, and, if so, to estimate how long it will take to bring it into compliance with the ASP. This evaluation will go back to the domain, who will decide whether to continue with the ramp-up.

The ramp-up period will not normally be longer than a year, and will usually be of the order of 3 or 6 months. If you are the original author you will be heavily involved in upgrading the product, with help from two or three others. If little progress is shown in successive cycles, or if the product is still far from compliance at the end of the set period, the ramp-up will be terminated. As you can see, a ramp-up detracts seriously from other activities and will only be attempted where the pay-off looks worthwhile.

## 12 Software development from the individual's point of view

This section gives an indication of the way in which an individual developer may experience the Atlas Software Process. The exact sequence of events dependswhat contribution you are going to make, and you may join in at any stage in the sequence below (for example, you may be asked to code some classes in an existing design). The story here is written from the point of view of new developer who is going to develop a design for a set of classes and carry the design through to coding and testing.

1. You will have joined a domain team and found the domain's Web page. This will include a "work in progress" chart, listing the various activities and the people involved. This will bring you up-to-date on the work that has been done and is currently going on during the present cycle of development. Discuss with your domain architect what you personally have to complete by the end of the current cycle. In the first instance, this may be to produce a design for all or a part of a package in terms of a set of classes. With the other members of the team, you must work out the services that these classes will supply. Look at the requirements document for the domain and identify the specific requirements that your part of the system has to satisfy.
2. Now work on your design, using St P. It is probably easiest to work directly in St P, but it is in fact possible to input class declarations in C++ and generate the correct internal form of the design from C++ source files (this permits reverse engineering, though there are restrictions on some features of C++). This can be a useful facility if you have already done some preliminary, explorative implementation. When you have got a design that satisfies the requirements as far as you can see, get some colleagues to review it informally. You should do this early in the design process so as to get feedback on whether your design is likely to be generally acceptable. When your design is complete, you must work out the test plan for your classes, If you have been given responsibility for the package, you must also design tests to check out the package interface.
3. If you are responsible for the package, generate the design report in the ASP-defined format and ask the domain architect to set up a formal review. The domain architect has overall responsibility for the design and will decide when to submit it for review. It is desirable to get the design cleared before you start coding, but if there is likely to be a delay, you may want to get on with your implementation. However, you should be aware that there is a certain risk in going ahead without waiting! You may have to make substantial changes to your design and throw away parts of your code.

4. Arrange with your domain architect which classes you will implement during the next cycle. Some classes may be very straightforward to code, but for complicated computations, there may be a number of ways that you can implement methods. In this case, you should go through the informal review process, and discuss your proposed implementations with colleagues before starting serious coding. Devise tests to comply with the the test plan, run them and check your results.
5. Generate the code report in the ASP format and ask your domain architect for a code review. If this is succesful, your code will be added to the next official release by the software librarian.
6. There may be remaining bugs that only show up in sustained use. You will be notified if this happens, if you are still responsible. You must correct the bug and make any necessary changes in the supporting documentation.

## References

* [1] Atlas CTP Working Group, _The Atlas Computing Technical Proposal_
* [2] S.M.Fisher, K.Bos and R.Candlin, _The Atlas Software Process_
* [3] K.Bos, Moose interim and final reports
* [4] Aonix, Software Through Pictures
* [5] L.Tuura, _The Software Release Tools_