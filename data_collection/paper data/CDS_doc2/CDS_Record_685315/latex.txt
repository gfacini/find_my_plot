ATLAS Quality Assurance Group

ATLAS C++ Coding Standard

Specification

\begin{tabular}{l l} Version: & 1.2 \\ Issue: & 1 \\ Status: & FINAL \\ ID: & ATL-SOFT-2002-001 \\ Date: & 2003-07-11 \\ \end{tabular}

European Laboratory for Particle Physics

Laboratoire Europeen pour la Physique des Particules

CH-1211 Geneve 23 - Suisse

[MISSING_PAGE_EMPTY:2]

## Abstract

This document defines the ATLAS C++ coding standard, that should be adhered to when writing C++ code.

It has been adapted from the original "PST Coding Standard" document ([http://pst.cern.ch/HandBookWorkBook/Handbook/Programming/programming.html](http://pst.cern.ch/HandBookWorkBook/Handbook/Programming/programming.html)) CERN-UCO/1999/207.

The "ATLAS standard" comprises modifications, further justification and examples for some of the rules in the original PST document. All changes were discussed in the ATLAS Offline Software Quality Assurance Group (formerly known as the Quality Control Group) and feedback from the collaboration is taken into account in the final version.

## Document Control Sheet

\begin{tabular}{|l|l l l|} \hline
**Document** & **Title:** & \multicolumn{1}{c}{ATLAS C++ Coding Standard Specification} \\  & **Version:** & 1.2 & ID: & ATL-SOFT-2002-001 \\  & **Issue:** & 1 & **Status:** & FINAL \\  & & & **Created:** & 2000-01-05 \\  & & & **Date:** & 2003-06-16 \\  & **Available at:** & [http://documents.cern.ch/](http://documents.cern.ch/) & \\  & **Keywords:** & ATLAS coding standard, C++ & \\ \hline
**Tool** & **Name:** & **Adobe FrameMaker** & **Version:** & 6.0p405 \\  & **Template:** & **Software Doc Layout Templates** & **Version:** & Vb1 - 16 \\  & & & **November 1998** \\ \hline
**Authorship** & **Written by:** & **The former Spider group and ATLAS QC group** \\  & **Contributors:** & **M. Asai, D. Barberis, M. Bosman, B. Jones, J.-F. Laporte,** & **M. Stavrianakou, C. Arnault, D. Candlin, R. Candlin, S.M. Fisher,** & **E. Frank, T. Hansl-Kozanecka, D. Malon, S. Qian, D. Quarrie,** \\  & **ROD Schaffer, P. Calafiura, M. Marino.** & **Coordinator** & **S. Albrand (from 2001-09-01)** \\  & **Reviewed by:** & **Approved by:** & \\ \hline \end{tabular}

## Document Status Sheet

## Document Change Record

## Table of Contents

* Abstract
* Document Control Sheet.
* Document Status Sheet.
* Document Change Record.
* Table of Contents

* 1 Introduction
	* 1.1 Purpose
	* 1.2 Authors
	* 1.3 Evolution and updating responsibility
		* 1.3.1 Motivations for the evolution of the document
	* 1.4 Organization of this document and approach
		* 1.4.1 Naming
		* 1.4.2 Coding
		* 1.4.3 Style
		* 1.4.4 Item Numbering
		* 1.4.5 Item Information
	* 1.5 References
	* 1.6 Definitions and Acronyms
* 2 Naming
	* 2.1 Naming of files (NF)
	* 2.2 Meaningful Names (NM)
	* 2.3 Illegal or Non-recommended Naming (NI)
	* 2.4 Naming Conventions (NC)
* 3 Coding
	* 3.1 Organizing the Code (CO)
	* 3.2 Control Flow (CF)
	* 3.3 Object Life Cycle (CL)
		* 3.3.1 Initialization of Variables and Constants
		* 3.3.2 Constructor Initializer Lists
		* 3.3.3 Copying of Objects
	* 3.4 Conversions (CC)
	* 3.5 The Class Interface (CI)
		* 3.5.1 Inline Functions
		* 3.5.2 Argument Passing and Return Values
		* 3.5.3 const Correctness
		* 3.5.4 Overloading and Default Arguments
3.6 new and delete (CN)

3.7 Static and Global Objects (CS)

3.8 Object-Oriented Programming (CB)

3.9 Assertions and error conditions (CE)

3.10 Error Handling (CH)

3.11 Parts of C++ to Avoid (CA)

3.12 Readability and maintainability (CR)

3.13 Portability (CP)

3.14 C++ Templates (CT)

4 Style

4.1 General aspects of style (SG)

4.2 Comments (SC)

A Terminology

B List of the items of the standard 

## 1 Introduction

### Purpose

The purpose of this document is to define a C++ coding standard that ATLAS offline software developers should adhere to. The standard provides indications aimed at helping C++ programmers to meet the following requirements on a program:

* be free of common types of errors
* be maintainable by different programmers
* be portable to other operating systems
* be easy to read and understand
* have a consistent style

Questions of design are beyond the scope of this document. It is also assumed that the code is hand-written and not generated; otherwise a different standard would be needed for the input to the code generator.

**Disclaimer:** This document does not substitute in any way the study of a book on C++ programming.

### Authors

This document has been adapted from the original "PST Coding Standard" document ([http://pst.cern.ch/HandBookWorkBook/Handbook/Programming/programming.html](http://pst.cern.ch/HandBookWorkBook/Handbook/Programming/programming.html)).

The "ATLAS standard" comprises modifications, further justification and examples for some of the rules in the original PST document. All changes were discussed in the ATLAS Offline Software Quality Control Group and feedback from the collaboration was taken into account in the "final" version.

The original "PST Coding Standard" document originated in the context of the SPIDER project, where representatives from different experiments (ALICE, ATLAS, LHCb, CMS and COMPASS) led by the IT/IPT group established and propose a common standard across experiments/projects.

### Evolution and updating responsibility

Changes to this standard will be implemented when necessary, following a procedure established by the ATLAS Offline Software Quality Assurance Group, formerly known as theATLAS Offline Software Quality Control Group, which is responsible for the maintenance of the document.

#### Motivations for the evolution of the document

The tool "rulechecker"-1 has been in use for Atlas code since December 2002. Also human review of Atlas code has started and is expected to increase.

Experience with applying the Atlas coding rules both with tools and by reviewers has lead us to rewrite several rules to make them clearer. In several cases the wording of the rule was not sufficiently unambiguous for the implementation of an automatic check.

Rules checked by rulechecker are marked with "RC" in the left hand margin.

### Organization of this document and approach

This document is organized as follows:

* this chapter
* list of all items on naming, with explanation and examples
* list of all items on coding, with explanation and examples
* list of all items on style, with explanation and examples
* Appendix A: Terminology
* Appendix B: List of the items in the standard

#### Naming

This section contains indications on how to choose names for all entities over which the programmer has control, e.g. classes, typedefs, functions, variables, namespaces, files.

#### Coding

Indications in this section regard the syntax and related semantic of the code. Organization of code, control flow, object life cycle, conversions, object-oriented programming, error handling, parts of C++ to avoid, portability, are all examples of issues that are covered here. This section is organized in different paragraphs, each one grouping items addressing the same subject.

1. The tool is produced by the Istituto Trentino di Cultura, Trento, Italy [http://www.itc.lt/](http://www.itc.lt/)

#### Style

Code is always written in a particular style. This section contains indications aimed at defining one, that should allow a common and consistent look and feel of the code. Style relates to matters which do not affect the output of the compiler.

#### Item Numbering

Each item comprises at least two entities, an identifier and an item title. The identifier is formed by two letters and a number (e.g. NF3); the first letter (N, C or S) indicates to which section (Naming, Coding or Style) the item belongs, the second letter indicates the subsection, while the number represents the order within the subsection. This kind of identification should allow a minimal impact on the item numbering during the maintenance of the standard, that is in the cases where items are added or removed.

\begin{table}
\begin{tabular}{|l|l|} \hline
**Identifier** & **Type of rule** \\ \hline NF & File naming \\ \hline NM & General naming \\ \hline NI & Illegal naming \\ \hline NC & Naming conventions \\ \hline CO & Code organization \\ \hline CF & Control flow \\ \hline CL & Object life cycle \\ \hline CC & Conversions \\ \hline CI & Class interface \\ \hline CN & new and delete \\ \hline CS & Static and global objects \\ \hline CB & Object oriented programming \\ \hline CE & Assertions and errors \\ \hline CH & Error handling \\ \hline CA & Parts of C++ to avoid \\ \hline CR & Readability and maintenance \\ \hline \end{tabular}
\end{table}
Table 1: List of Item Identifiers

#### 1.4.5 Item Information

Whenever possible and appropriate, a statement and an example have been added to the individual item; the statement is an explanation that expands the item and clarifies its meaning and scope.

Items have been marked with the attribute REQUIRED or RECOMMENDED. This is an attempt to indicate to developers and to reviewers, what their attitude should be to each item of the standard. An item marked "recommended" is not to be considered as obligatory. It is used to mark an item which is "desirable", or "should be avoided", for example, in the interests of a coherent style or of readability. An item which is marked as "required" is something that all developers MUST try to follow. This does not mean that a reviewer should never allow an exception, indeed possible exceptions are sometimes mentioned in the text, but that if a developer wishes to "transgress" one of these items, he or she must be prepared to justify to the reviewer, and to copiously comment within the code, that there was no other way both possible and acceptable, to obtain the desired result.

### 1.5 References

* Specification, S. Paoli, P. Binko, D. Burckhart, S.M. Fisher, I. Hrivnacova, M. Lamanna, M. Stavrianakou, H.-P. Wellisch CERN-UCO/1999/207, 20 October 1999.
* [2] Standard for the Programming Language C++, ISO/IEC 14882.
* [3] Effective C++, 2nd Edition, S. Meyers, Addison-Wesley.
* [4] Design Patterns, Elements of Reusable Object-Oriented Software, Erich Gamma, Richard Helm, Ralph Johnson, John Vlassides, Addison-Wesley.
* [5] Effective STL, 2nd Edition, S. Meyers, Addison-Wesley 2001 ISBN 0-201-74962-9

### 1.6 Definitions and Acronyms

SPIDERSoftware Process Improvement for Documentation, Engineering, and Reuse of LHC and HEP Software Systems, Applications and Components

\begin{table}
\begin{tabular}{|p{42.7pt}|p{284.5pt}|} \hline
**Identifier** & **Type of rule** \\ \hline CP & Portability \\ \hline CT & Templates \\ \hline SG & General style \\ \hline SC & Comments \\ \hline \end{tabular}
\end{table}
Table 1: List of Item Identifiers* [14]4 

## 2 Naming

This section contains a set of conventions on how to choose, write and administer names for all entities over which the programmer has control.

### Naming of files (NF)

**NF1**: The name of the header file must be the same as the name of the class it defines, with a suffix ".h" appended. _(REQUINED)_

Example:

The header file for the class CalorimeterCluster would have the name CalorimeterCluster.h

In the presence of name space, the file name should not include the name space prefix (e.g. for a class Emc::Track, the name of its header file should be Track.h).
**NF2**: The name of the implementation file must be the same as the name of the class it implements, with a suffix ".cxx" appended. _(REQUINED)_

Example:

The implementation file for the class CalorimeterCluster would have the name CalorimeterCluster.cxx

### Meaningful Names (NM)

**NM1**: **Use pronounceable English words or acronyms widely used in the experiment to compose all lexical entities except for local loop variables and array indices. _(RECOMMENDED)_

They aid discussion, and are helpful for newcomers.

Example:

Use nameLength instead of Ln.

Use names that are English and self-descriptive. If abbreviations and/or acronyms cannot be avoided, then they are better to be agreed upon by the communities concerned and be meaningful, uniform and documented.

This is very important for everyone to understand the meaning of the declared entities and to make the code easy to be read and used.

### Illegal or Non-recommended Naming (NI)

**NI1**: **Do not create very similar names. _(RECOMMENDED)_
**RC**: **Very similar names might cause confusion in reading the code.**

**In particular do not create names that differ only by case.**

**Example:**

**track, Track, TRACK**

**cmlower, clower**
**NI2**: **Do not use identifiers that begin with an underscore. _(REQURED)_
**RC**: **Names starting with an underscore are used in C and C++ compiler implementation. To allow users to use such names introduces a needless confusion.**

### Naming Conventions (NC)**

**NC1**: **Use prefix "m_" for private attributes (i.e. data members) in each class. _(REQURED)_
**RC**: **Start names of variables and functions with a lowercase letter after the prefix "m_"**

**NC2**: **Use prefix "s_" for private static attributes (i.e. class data members). _(RECOMMENDED)_
**RC**: **Start names of variables and functions with a lowercase letter after the prefix "s_"**

**NC3**: **The choice of prefixes for package names and the choice of name for namespaces should be agreed upon by the communities concerned and should, where appropriate, correspond to the Product Breakdown Structure (PBS). _(RECOMMENDED)_
**NC4**: **Use namespace to avoid name conflicts between classes. _(REQURED)_.**

**A name clash occurs when a name is defined in more than one place. For example, two different class libraries could give two different classes the same name. If you try to use many class libraries at the same time, there is a fair chance that you will be unable to compile and link the program because of name clashes. To solve the problem you can use a namespace.**Example of the declaration of a namespace:

namespace Emc { class Track {... }; //... }

A namespace is a declarative region in which classes, functions, types and templates can be defined. A namespace should be defined at the package level to put in common what is necessary for classes of the package, and to render these common elements accessible for client packages. Thus a good name for the namespace is the name of the package to which it belongs. (see rule NC3)

A name qualified with a namespace name refers to a member of the namespace.

Emc::Track electronTrack;

A using declaration makes it possible to use a name from a namespace without the scope operator.

using Emc::Track; // using declaration

Track electronTrack;

Recommendations for the use of namespaces based on proposals by L. Tuura

Using directives (e.g. 'using namespace std;') can be used only in **function** scope or to import names from one named namespace to another named namespace.

Examples of allowed usage:

void MyClass::MyMethod() { using clhep::units::mm; // function scope // do something } namespace foo { using bar::foobar; // import to named namespace }

"using" directives are forbidden everywhere else.

Examples of forbidden usage:

using std::operator!=; // at filescope namespace { using foo::bar; // import to anonymous namespace } Note: "using" declarations cannot be used in classes, where they have a completely different interpretation anyway (for example to access from a derived class a same name member of a base class or to restore public accessibility of a base class method when private inheritance is used - for further details see References [1] and [2]).

Whatever the conventions adopted (depending on project policies and practices), it is essential that the style be consistent and documented (especially if it does not follow the "official" rules).

**NC5**: **Start class names, typedefs and enum types with an uppercase letter. _(REQURED)_
**RC**: **Example:**

class Track: typedef vector<MCParticleKinematics*> TrackVector; enum State { green, yellow, red };
**NC6**: **Start names of variables and functions with a lowercase letter. _(REQURED)_
**RC**: **Example:**

double energy; void extrapolate();

In the cases of NC1 and NC2 (i.e. for the private attributes), start names of variables and functions with a lowercase letter after the prefix ("s_" or "m_").
**NC7**: **In names that consist of more than one word, write the words together, and start each word that follows the first one with an upper case letter. _(RECOMMENDED)_
**RC**: **Example:**

class OuterTrackerDigit; double depositedEnergy; void findTrack();

This is a change from the previous Atlas coding rules which recommended a different convention (i.e. using the underscore between words). This new rule is based on the STL style. Existing code may not need to be changed; however, when a package has a serious overhaul, you should switch to this new rule. Clearly, when using other classes (including STL) one has to accept the name of the classes and methods which are provided. More suggestions are