Proposal for a Database for the ATLAS SCT Construction

Joe Foster and Steve Snow

Department of Physics and Astronomy

Manchester University

October 8, 1996

## 1 Introduction

We propose the creation of a database for the construction and testing of the ATLAS Silicon Central tracker. The database would have three main uses:

* It would aid construction of the SCT, by recording the location and status of important parts. A database could also help optimise the combination of parts in a module in a such a way as to minimise the number of dead channels.
* It would provide an essential tool for quality control by making it possible to track a component from delivery, through testing and to its ultimate position in the detector. With a database query one could determine whether a set of detector wafers, say, all came from the same manufacturer, or had all been glued to their substrates with a particular glue batch. Database records of test results would facilitate setting of rejection levels for some parameters, and allow statistical investigation of failure rates.
* It would feed information such as dead/noisy channel maps through to the simulation and reconstruction programs.

The large volumes of structured, dynamically changing data that would be stored and the ways in which users would access that data require consideration.

## 2 Architecture

Our proposed architecture would be based on the client-server model, with CERN ORACLE acting as the master server. Access would be fomclient machines communicating over the network, either by means of special data-entry applications or World Wide Web pages.

### Servers

The CERN ORACLE server provides the ability to store large amounts of structured data, with concurrent access possible by many clients. Data is retrieved or updated very flexibly by means of the SQL language. There is built in security by means of data integrity rules, user privileges, and SQL views.

Unless network performance improves substantially it will be necessary for institutes which are routinely entering data to run a local server with a cached subset of the database in order to avoid delays. In this case the local cache would be merged with the CERN master database overnight.

### Clients

There are several possibilities for clients.

#### 2.2.1 Omnis

A commercial 4th Generation Language (4GL) package such as Omnis from Blyth Software makes it easy to develop client applications for Macintosh or PC platforms. Menus and windows can be built with sophisticated features like pushbutions, dropdown lists, and data validation at point of entry. In addition users can generate their own _ad hoc_ queries and reports.

Omnis has good connectivity to ORACLE, but can also use its own local SQL server.

#### 2.2.2 Www

It should be possible to set up World Wide Web pages which use JAVA or HTML forms to assemble SQL commands and forward them to ORACLE. The advantage of this approach would be that Web pages can be viewed from any platform with an appropriate browser: no other software would be required by the remote client. Assuming that the pages all resided on a single Web server, only this machine would communicate directly with ORACLE, and only a single copy of the software to generate the SQL would be needed.

Response for queries via WWW pages would be bound to be slower than for a 4GL application, especially one with a local server, and it would be difficult to provide all of the same features for data entry.

Developments in this field are continuing rapidly: for example, the suppliers aim to provide a WWW interface to Omnis, including the ability to generate JAVA code in the near future.

## 3 Views of the Database

It is useful to distinguish the views of the database as seen by different people.

### Internal View

The 'internal view' of the database refers to the structure as seen by the database developer, and reflects the way the data would be stored on the server. This would follow the relational model. Tables ('relations') would be chosen so as to optimise efficiency of storage, data integrity and flexibility against changing requirements. Details of some tables are given in a later section.

### User Views

Most end users would see an 'external view' of the database through the medium of windows and menus presented by a client which would often combine information from different tables and present them in a more useable form.

There would be several broad classes of database use, each with different requirements, and different access privileges. Most of the time users need not have access to the whole database, but to a view which is relevant to the immediate task. This would be implemented by special SQL _views_, which restrict access of groups of users to certain tables.

#### 3.2.1 Routine Data Entry

A large amount of useful data like test results or assembly and alignment information would be routinely entered by hand. A specially designed client interface can allow this to be done quickly and efficiently, without the need of special knowledge of database software. In our experience, if the database is at all cumbersome to use, there is a risk that important data will left out by people working under pressure, or that mistakes will be made.

It would be possible to import blocks of data created by other applications, such as spreadsheets, or LabView programs.

Routine dataentry can be made more secure as well as more efficient by providing a view of the database which is restricted to only the necessary tables, and possibly only to those entries in the tables which are relevant to that institute.

#### 3.2.2 Design Specification

Certain information like descriptions of detector parts or the order and types of components in an assembly would need to be entered just once. Some care should be taken against accidental modification of this information, so access to this view would be restricted by special password. Convenient interfaces would still be useful here.

Users with access to this view might also specify new table formats to hold information like test results specialised for a particular detector, or specify or create specialised data entry forms.

#### 3.2.3 Quality Control

Anyone in ATLAS interested in quality control could have read access to the whole database. A repository of standard queries which had been found useful, perhaps on a Web page, would be available. Some users might find it useful to learn some SQL to enable them to formulate more complex queries, though.

#### 3.2.4. Database Maintainance

Someone should have the responsibility of defining the overall structure of the database, including table formats, views, and access levels. Ideally, they should not have to be experts on all of the detectors as well.

Someone, preferably at CERN, should act as database administrator, looking after backups, assigning priviledges to users, and generally worrying about the continuing integrity and availability of the master database.

## 4. Structure.

We give here an outline of the proposed database structure, with examples of how some of the tables and data entry windows would work together.

### Principal Entities

There would be three main entities: _items_, _assemblies_ and _tests_. Some other entities are needed in addition, but will not be described here: _Person_, _Location_, _Shipment_, _Manufacturer_.

#### 4.1.1. Items

An _item_ is any object which has some sort of individuality which makes it worth recording in the database, either because it will be tested in some way, or because it has a manufacturer's serial number or batch number which one wants to record. For example a detector or a pipeline chip or a hybrid board would be an item, and so would a batch of glue. Some components will not qualify as items because they are anonymous and interchangeable, for example a screw or a piece of cable.

An important consideration is that every physical item in the SCT would have to have a serial number marked on it somewhere in order for this scheme to work.

#### 4.1.2. Assemblies

An _assembly_ is something built up from more than one component, which may be either simple items or other assemblies (plus any number of anonymous parts). For example a populated hybrid, a module, or a group of modules on a stave would be typical assemblies, as would the whole SCT. Of course one could define assemblies at various levels in the build-up but only those which are going to be tested will be recorded separately.

Any _assembly_ or _component_ is also an _item_.

#### 4.1.3. Tests

All results from tests on simple items or assemblies will be stored, including multiple tests on the same item.

### Tables

We propose that all items be uniquely identifiable within ATLAS by a combination of two attributes: _item type_ and _serial number_. The _item type_ would be a short (8 character) name assigned according to some convention (to be agreed), and the _serial number_ would be a 32 bit integer. In order to avoid clashes, each institute working on the SCT will be allocated a two digit number which will be encoded in the high order bits of all serial numbers created at that institute. During data entry the interface program will automatically generate the next available serial number for a given item type and institute.

#### 4.2.1. Item

All items can be stored in a single table with a common structure:

* Item Type. Each item type has an associated general description in a separate table ('Item Description').
* ATLAS serial number.
* Manufacturer's serial number.
* Name of manufacturer.
* Date the item was entered into database.

* Last recorded location of the item. When the item is shipped from one institute to another this field is updated.

Additionally, any item can have an optional comment associated with it. This would be a block of text up to 5 lines long.

#### 4.2.2 Assembly

We aim not to have a different table for each kind of assembly, but rather to have just two standard tables ('Assembly' and 'Assembly Description') which, together with the 'Item' and 'Item Description' tables, allow one to store a general description of each type of assembly, as well as a record of which component items are mounted in any particular assembly. Although this method may seem rather obscure at first sight, it is actually quite powerful, and the complications can be hidden from the user by the interface.

An example of how these tables work is given in the appendix.

#### 4.2.3 Test Results

One of the main purposes of the database is to store test results and allow quality control.

It is not efficient to define a completely general structure for the test tables as we have done for the assembly tables above. This is because the number and type of test data which may be associated with each tested item will vary from a simple boolean pass/fail to a string of 128 ( or 1536? ) floating point numbers.

We suggest that initially we set up a 'Generic Test' table which would record basic information about the time and place of the test as well as a single boolean result (TRUE if the item passed the test unconditionally). An example is shown in the appendix.

More complex tests which produce several numbers all refering to the same item will probably each need a special table in order to enter and save the data efficiently; these tables can be defined when the need arises. Whenever one of these special tests is entered in the database it would be associated with a new generic test entry.

A description of any problem arising can optionally be associated with a generic test entry.

### Data Entry Window

We illustrate the kind of client user interface we expect to produce using the Omnis 4GL package with an example of a window which would be used for routine entry of information about items as they are received at one of the test centres, prior to the initial acceptance test.

#### 4.3.1 Item Window

When the client program first starts up, it prompts for the name of the current location, so that it can assign ATLAS serial numbers in the correct range. From a menu of possibilities the user may then choose to enter data about some new items. He will then be presented with the 'Item' window.

Corresponding to each column in the 'Item' table there is a field - a slot for entering data - on the 'Item' window. These can be of the traditional sort where the user types in the data or more sophisticated, where the user makes a selection from a drop-down list, for example.

* Item Type. Two fields are visible here: one for the 8-character item type, and another for the description associated with this item type in the 'Item Description' table. Initially this field contains the last value entered. A mouse click in the item type field causes a drop-down list of recognised item types and descriptions to appear, from which the user can make a selection.
* ATLAS serial number. If the user is entering data about a new item, the next valid serial number will appear in this field automatically. A feature which may be useful for detectors is a set of aluminium scratch pads on a corner of the detector which can be marked with a pattern of scratches coding the ATLAS serial number. The window displays the correct pattern for the current serial number.
* The manufacturer's serial number (if any) will be typed in by hand, with the option of just editing the previous value.
* The name of manufacturer can be selected from a list in the same manner as the item type.
* The date is automatic.
* The location is automatic.

The 'Item' window also contains a set of pushbutton controls which allow the user to navigate easily around the 'Item' table.

## Appendix A Appendix: Example Item and Assembly Tables

This describes the proposed internal structure of the database by means ofan example. The example is a simplified barrel module consisting of four detectors and two hybrids, where each hybrid is made of four chips mounted on a substrate. The average user will not need to know anything about this internal structure, but we present it here so that anyone who is interested can check that their favorite piece ofdata will indeed fit into our proposed structure.

Most of the information is stored in just four tables. The first two tables ('Item Description' and 'Assembly Description') describe the structure of the SCT; only a few people will have the passwords necessary to modify them. The next two tables ('Item' and 'Assembly') describe the details of every item and its position in the SCT, anyone who is working on the SCT will be able to add records to these tables.

### Item Descriptions. (Table 1)

Each type of item has a unique short name (up to 8 characters). The flag shows whether the item is a unique object which can only be used in one place in the assembly, or whether it is a divisible item such as a batch of glue which can be used in several different modules. The components are non-zero for items which are assembled from a number of other items appearing in the database; this serves as an internal cross check with the number of entries in the following table.

### Assembly Descriptions. (Table 2)

This table describes how items of different types are combined into assemblies in the SCT. In the example, a database query searching for all rows with Assembly Item Type = 'barhyb' would yield a list of all the components which make up a barrel hybrid assembly.

### Items. (Table 3)

The combination of item type and Atlas serial number uniquely identify any part of the SCT. The item location is a code for each institution in Atlas. When the item is built into a larger assembly its location code is set to zero; this is a cross check of the information stored in the following table.

### Assemblies. (Table 4)

This table maps individual component items into their assemblies. Here are some examples of the information that quite simple database queries could give from this table:

* 14009900 end up in the SCT?
* Which barrel silicon detectors were used in module 45000001?
* Which barrel modules were glued with epoxy batch 45000010?
* Which barrel hybrids assembled into modules at institute number 45 came from institute number 11?

Slightly more complex queries, linking this table with the 'Item' table, could give information about batches of components from particular manufacturers, while linking with the 'Location' table would allow institutes to be accessed by name as well as number.

### Other Tables

In addition to the four main tables, at least a couple of others are planned: One table ('Location')will relate the institute codes to the full name, address, etc. of the institutes. Another pair of tables to describe shipments of items from one institute to another will be useful in order to keep track of their history and update the present location column of the items table.

\begin{table}
\begin{tabular}{|c|c|c|c|} \hline Item & Uniqueness & Number of & Description \\ Type & Flag & Components & \\ \hline \hline sibarl & T & 0 & Silicon detector for the barrel \\ epoxth & F & 0 & Thermally conductive epoxy for modules \\ barhyb & T & 5 & Fully populated barrel hybrid \\ bphysub & T & 0 & Bare hybrid card for the barrel \\ fechip & T & 0 & Front end readout chip \\ barmou & T & 7 & Complete barrel module, phi-u type \\ \hline \end{tabular}
\end{table}
Table 1: Item Description.

\begin{table}
\begin{tabular}{|c|c|c|c|c|} \hline Assembly & Component & Component & Description \\ Item Type & Item Type & Position & of Position \\ \hline \hline barhyb & bhysub & 1 & \\ barhyb & fechip & 1 & channels 1-128 \\ barhyb & fechip & 2 & channels 129-256 \\ barhyb & fechip & 3 & channels 257-384 \\ barhyb & fechip & 4 & channels 385-512 \\ barmou & barhyb & 1 & u side \\ barmou & barhyb & 2 & phi side \\ barmou & sibarl & 1 & u side near hybrid \\ barmou & sibarl & 2 & u side far from hybrid \\ barmou & sibarl & 3 & phi side near hybrid \\ barmou & sibarl & 4 & phi side far from hybrid \\ barmou & epoxth & 0 & \\ \hline \end{tabular}
\end{table}
Table 2: Assembly Description.

\begin{table}
\begin{tabular}{|c|c|c|c|c|c|} \hline Item & Atlas & Manufacturerâ€™s & Name of & Date & Present \\ Type & Serial No. & Serial No. & Manufacturer & of Entry & Location \\ \hline \hline sibarl & 23000001 & JS8864 & SiliCo & 1/8/97 & 45 \\ sibarl & 23000002 & JS8547 & SiliCo & 1/8/97 & 45 \\ sibarl & 23000003 & JS8755 & SiliCo & 1/8/97 & 45 \\ sibarl & 23000004 & JS8754 & SiliCo & 1/8/97 & 45 \\ epoxth & 45000010 & 9877 & Gummers & 10/10/98 & 45 \\ barhyb & 11000001 & XXI & Hybrid T & 5/10/98 & 45 \\ barhyb & 11000002 & XXII & Hybrid T & 5/10/98 & 45 \\ bphysub & 11000067 & ZZZ56 & Chunky PCBs & 4/4/98 & 0 \\ bphysub & 11000068 & ZZZ57 & Chunky PCBs & 4/4/98 & 0 \\ fechip & 14009874 & U8564 & DeepFry & 1/4/98 & 0 \\ fechip & 14009875 & U8564 & DeepFry & 1/4/98 & 0 \\ fechip & 14009876 & U8564 & DeepFry & 1/4/98 & 0 \\ fechip & 14009877 & U8564 & DeepFry & 1/4/98 & 0 \\ fechip & 14009878 & U8564 & DeepFry & 1/4/98 & 0 \\ fechip & 14009879 & U8564 & DeepFry & 1/4/98 & 0 \\ fechip & 14009880 & U8565 & DeepFry & 2/4/98 & 0 \\ fechip & 14009881 & U8565 & DeepFry & 2/4/98 & 0 \\ fechip & 14009881 & U8565 & DeepFry & 2/4/98 & 0 \\ barmou & 45000001 & RHAA & 1/12/98 & 45 \\ \hline \end{tabular}
\end{table}
Table 3: Items.

## Appendix B Appendix: Example Test Tables

### Test Definitions (Table 5)

This table lists the types of test that can be carried out on each item. Each test is given a number and a short description in words. If the test produces more results than just a pass/fail then there is a pointer here to the table which stores the results.

### General test results (Table 6)

The basic details about the time and place, etc, of any test carried out on an item would be recorded in this table, together with a boolean to indicate whether it passed the test unconditionally. Each test is given a serial number, allocated from a range appropriate to the institute doing the test. In addition to encoding the institute this number can relate a row in this table to a row in a special results table such as the following.

### Special test results (Table 7)

Continuing the example, here are some additional test results on some silicon barrel detectors recorded in a table which was created for the purpose. Data could be entered in this and the 'generic' test table at the same time by means of a special client window.

\begin{table}
\begin{tabular}{|c|c|c|c|c|} \hline
**Assembly** & **Assembly** & **Component** & **Component** \\
**Item Type** & **Serial No.** & **Item Type** & **Serial No.** & **Position** \\ \hline \hline barhyb & 11000001 & bhysub & 11000067 & 1 \\ barhyb & 11000001 & fechip & 14 009878 & 1 \\ barhyb & 11000001 & fechip & 14 009879 & 2 \\ barhyb & 11000001 & fechip & 14 009880 & 3 \\ barhyb & 11000001 & fechip & 14 009881 & 4 \\ barhyb & 11000002 & bhysub & 11 000068 & 1 \\ barhyb & 11000002 & fechip & 14 009874 & 1 \\ barhyb & 11000002 & fechip & 14 009875 & 2 \\ barhyb & 11000002 & fechip & 14 009876 & 3 \\ barhyb & 11000002 & fechip & 14 009877 & 4 \\ barmou & 4 5000001 & barhyb & 11 000001 & 2 \\ barmou & 4 5000001 & barhyb & 11 000002 & 1 \\ barmou & 4 5000001 & sibarl & 23000001 & 3 \\ barmou & 4 5000001 & sibarl & 23000002 & 4 \\ barmou & 4 5000001 & sibarl & 23000003 & 1 \\ barmou & 4 5000001 & sibarl & 23000004 & 2 \\ barmou & 4 5000001 & epoxth & 45000010 & 1 \\ \hline \end{tabular}
\end{table}
Table 4: Assemblies.

\begin{table}
\begin{tabular}{|c|c|c|c|} \hline
**Item** & **Test** & **Special results** & **Description of test** \\
**Type** & **Type** & **table name** & \\ \hline \hline
**sibarl** & 1 & & \\
**sibarl** & 2 & **SIBCUR** & **Reverse leakage currents at 100,200,300 V** \\
**barmou** & 1 & **BTHERM** & **Thermal tests on barrel U module** \\
**barmof** & 1 & **BTHERM** & **Thermal tests on barrel phi module** \\ \hline \end{tabular}
\end{table}
Table 5: Test definitions.

\begin{table}
\begin{tabular}{|c|c|c|c|c|c|c|c|} \hline Item & Serial & Test & Test & Tester & Date & Time & Pass? \\ Type & Number & Type & Number & Initials & & T/F \\ \hline \hline sibarl & 23000001 & 1 & 23000354 & XYZ & 1/4/98 & 18.03 & T \\ sibarl & 23000001 & 1 & 23000355 & XYZ & 1/4/98 & 18.09 & T \\ sibarl & 23000002 & 1 & 23000356 & XYZ & 1/4/98 & 18.20 & F \\ sibarl & 23000001 & 2 & 23000357 & XYZ & 1/4/98 & 19.01 & T \\ barmou & 4500001 & 1 & 45000017 & ANON & 1/12/98 & 14.55 & T \\ \hline \end{tabular}
\end{table}
Table 6: Generic test results.

\begin{table}
\begin{tabular}{|c|c|c|c|c|c|c|} \hline Test & Strip curr & Guard curr & Strip curr & Guard curr & Strip curr & guard curr \\ Number & at 100V & at 100V & at 200V & at 200V & at 300V & at 300V \\ \hline \hline
23000357 & 2.1 & 1.2 & 2.5 & 1.7 & 3.0 & 3.1 \\
41009876 & 1.3 & 0.7 & 2.0 & 1.6 & 2.3 & 2.2 \\ \hline \end{tabular}
\end{table}
Table 7: Special test results (SIBCUR).