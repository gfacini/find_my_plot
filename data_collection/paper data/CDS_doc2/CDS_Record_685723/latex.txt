ATLAS Internal Note

DAQ -No- 008

CERN/EAST note 92-28

19 November 1992

**Pattern recognition algorithms for triggering with a silicon tracker**

Adrian Gheorghe, Werner Krischer

**Abstract**

Detection of high-p\({}_{\rm t}\) tracks in a silicon tracker is an important contribution to second-level triggering on electrons, in conjunction with calorimeter and preshower algorithms [1]. Silicon detectors transmit thresholded (zero-suppressed) data because of the low occupancy of the devices even at high accelerator luminosity. This way of presenting data in lists does not a priori lend itself to implementation in image processing devices. Also the variable-length data lists result in data-dependent execution times.

Using the programmability of several image processors we are familiar with (MaxVideo, DataWave), we present in this note algorithm formulations that can be implementated in these image processors, so that an average decision frequency of 100 KHz can be maintained easily even at high luminosity. Semi-custom implementations of these algorithms in field-programmable gate arrays are also possible.

We use data generated by the RD-2 collaboration, based on the ATLAS-A SIT geometry. Data are restricted to a region of interest (RoI) assumed to be extracted by an external 'Router' under control of a first-level trigger definition of that RoI.

Introduction

In [1] about the second-level electron triggering in the ATLAS-A detector, a Region-of-Interest (RoI) trigger algorithm for the outer silicon tracker has been described. Input to this algorithm is a list of pairs of numbers (\(m\),\(n\) )'s, where \(m\) is an index of a silicon strip layer and \(n\) a measure of the arclength. From this the original 256 * 4 image had been recreated. The result of a least squares (LSQ) fit through 3 or 4 points had been stored in 16 - bit look up tables (LUTs) for \(\mathrm{p_{t}}\) and goodness of fit. The method used was to move a mask through all the 256 positions and to look for a matching pattern.

Before looking for a fast way of implementing this particular algorithm, we tried out several other techniques on the test data generated by RD-2. The most obvious ones are the least squares fit as in [1] or a combinatorial method, where we picked the two outmost pixels (of 3 or 4), defined through them a narrow road and counted how many hits fell into it. This "road" method proved as reliable as a least squares fit through 3 or 4 points. Another equally successful algorithm is a variable slope histogram ("Hough" transform). We also experimented with various variations of histograms of dy/dx and/or of intersections of the straight lines defined by pairs of points with a middle line with somewhat worse results. Fig.1 shows an example where all these techniques gave the same result. Fig 1b) shows the plot of a Hough - transform with the corresponding parameter space in Fig. 1c). In Fig. 1a) one sees to the left the histogram of dy/dx, in the middle the intersections of straight lines of all pairs of points with a middle line and to the right the corresponding histogram.

Three methods had roughly the same success rate from the pattern recognition point of view, the LSQ fit, the road method and the Hough - transform. Although compute-intensive, the implementation of a Hough - transform working with lists of points can be mastered with special hardware [2], that has part of the analysis of the Hough parameter space built in ( e.g. outputting per angle the maximum and its position and returning the coordinates inside the peak for further processing). For more general implementation, the best methods seem to be the road method and the LSQ - fit. For comparison reasons with [1] we restrict ourselves in this note to the LSQ - method.

We attempt to avoid to recreate the original 256*4 image, because this requires an additional computational step, and in particular because pipelined computer architectures have an execution time directly proportional to the image size. We therefore use the (\(m\),\(n\) ) - list directly. Processing the data'symbolically' rather than 'iconically' we gained a factor of more than 30 in execution time producing identical results. In chapter 2 we will now describe in more detail the LSQ - algorithm and in chapter 3 its implementation on the DATAWAVE - processor and on some pipelined system. In chapter 3b) we will describe an implementation of a similar algorithm with a wider range, in both directions and with relatively short LUTs in a pipelined system (custom designed or off the shelf, like MaxVideo). We will summarize our results in chapter 4.

2. LSQ - algorithm for the ATLAS - silicon tracker

a)   Geometry

The geometry of the SIT is described in more detail in [1]. We would like to emphasize a few geometrical features of the SIT which are useful for a better understanding of the following algorithms. We shall only consider the (r,\(\Phi\)) - plane perpendicular to the beam (z axis) as in Fig. 2a) In this plane the SIT consists of four concentric silicon layers with the radii \(\mathbf{r}=\left[\begin{array}{cc}\mathrm{ra}&\mathrm{rb}&\mathrm{rc}& \mathrm{rd}\end{array}\right]^{T}=\left[\begin{array}{cc}\mathrm{70}&\mathrm{ 80}&\mathrm{90}&\mathrm{100}\end{array}\right]^{T}\mathrm{cm}\). In the \(\Phi\) direction each layer is divided into small detector elements of 0.01875 cm. Because the SIT is in a magnetic field the projected tracks will have a circular shape in a cartesian system, and to a good approximation a straight line in the (r,\(\Phi\)) space. If a particle crosses the layers it has a high probability to hit each layer. In the best case a particle will hit each layer of radii \(\mathbf{r}=\left[\begin{array}{cc}\mathrm{ra}&\mathrm{rb}&\mathrm{rc}& \mathrm{rd}\end{array}\right]^{T}\mathrm{once}\) in certain positions a,b,c,d, combined later in the vector \(\mathbf{y}=\left[\begin{array}{cc}\mathrm{a}&\mathrm{b}&\mathrm{c}&\mathrm{ d}\end{array}\right]^{T}\). In general we will have a few background hits around like in Fig. 2c) which represents data from single electrons with \(\mathrm{p_{t}>40}\) at high luminosity in the space ( r,n ) ( radius, position of hit ). We frequently simply speak e.g. of the "point" b, if we mean the point (rb,b). The task is to find four or three points in different layers which correspond to a track. Tracks of interest for triggering are the ones with high \(\mathrm{p_{t}}\), i.e. with a curvature \(\mathrm{R>25m}\), they can thus be considered in first approximation as straight.( see Appendix 1 )

b)   Mathematical formulation

To fit a straight line we have to solve the following overdetermined system of linear equations

\[\mathbf{A}\mathbf{x}=\mathbf{y}\]

with the vector \(\mathbf{x}\) of the 2 unknowns, \(\mathbf{y}=\left[\begin{array}{cc}\mathrm{a}&\mathrm{b}&\mathrm{c}&\mathrm{ d}\end{array}\right]^{T}\mathrm{and}\ \mathbf{A}=\left[\begin{array}{cc}\mathbf{r}&\mathbf{u}\end{array}\right]\), where \(\mathbf{r}=\left[\begin{array}{cc}\mathrm{ra}&\mathrm{rb}&\mathrm{rc}& \mathrm{rd}\end{array}\right]^{T}\mathrm{and}\ \mathbf{u}=\left[\begin{array}{cc}\mathrm{1}&\mathrm{1}&\mathrm{1}& \mathrm{1}\end{array}\right]^{T}\). We used the method of orthogonal triangularization \(\mathbf{A}=\mathbf{Q}\mathbf{R}\) with the solution \(\mathbf{x}=\mathbf{R}^{-1}\ \mathbf{Q}^{T}\ \mathbf{y}\ =\mathbf{T}\ \mathbf{y}\). Of course we had to compute altogether 5 of these transformation matrices \(\mathbf{T}\) in advance for all the cases abcd, abcM, abMd, aMcd and Mbcd, where the M stands for a missing layer.

In the following implementations we first looked for the minimum residual, expressed as a function of the y-s :

\[\mathrm{res2}=\parallel\mathbf{A}\mathbf{x}\ \mathrm{-}\ \mathbf{y}\parallel ^{2}=\parallel\mathbf{A}\mathbf{T}\mathbf{y}\ \mathrm{-}\ \mathbf{y}\parallel^{2}=\parallel\left(\mathbf{A}\mathbf{T}\mathbf{-}\ \mathbf{E}\ \right)\ \mathbf{y}\parallel^{2}=\mathbf{y}^{T}\ \mathbf{C}\ \mathbf{y} \tag{1}\]

where \(\mathbf{E}\) is the 4*4 identity matrix and

\[\mathbf{C}=\left(\mathbf{A}\mathbf{T}\mathbf{-}\ \mathbf{E}

To use small numbers in the implementation we used the fact that if \(\mathbf{y}\,=\mathbf{z}+\mathbf{w}\), the sum of a vector \(\mathbf{z}\) with \(\mathbf{z}^{\mathrm{T}}\,\mathbf{C}\,\,\mathbf{z}=0\) and a vector \(\mathbf{w}\), then

\[\mathrm{res2}=\mathbf{y}^{\mathrm{T}}\,\mathbf{C}\,\,\mathbf{y}=\mathbf{w}^{ \mathrm{T}}\,\mathbf{C}\,\,\mathbf{w} \tag{3}\]

To fit a straight line through the four points (ra,a),...,(rd,d) we shall consider :

\[\mathbf{y}=\begin{bmatrix}\mathrm{a}\\ \mathrm{b}\\ \mathrm{c}\\ \mathrm{d}\end{bmatrix}\qquad\mathbf{z}=\begin{bmatrix}\mathrm{a}\\ \mathrm{b}\,1\\ \mathrm{c}_{1}\\ \mathrm{d}\end{bmatrix}\qquad\text{and}\qquad\mathbf{w}=\Delta\mathbf{y}\,= \mathbf{y}\,-\,\mathbf{z}=\begin{bmatrix}0\\ \mathrm{b}\mathrm{-}\mathrm{b}\,1\\ \mathrm{c}\mathrm{-}\mathrm{c}_{1}\\ 0\end{bmatrix}\]

\[\mathbf{y}\,=\,\mathbf{z}\,+\,\Delta\mathbf{y}\]

where \(\{\,\mathrm{a}\,\,\,\mathrm{b}_{1}\,\,\,\mathrm{c}_{1}\,\,\,\mathrm{d}\}\) are collinear points ( Fig. 3b). Then applying formula (3) one obtains :

\[\begin{array}{rl}\mathbf{res2}=\mathbf{y}^{\mathrm{T}}\,\mathbf{C}&\mathbf{y }=\left(\mathbf{z}+\Delta\mathbf{y}\right)^{\mathrm{T}}\,\mathbf{C}\,\,( \mathbf{z}+\Delta\mathbf{y})=\\ &=\mathbf{z}^{\mathrm{T}}\,\mathbf{C}\,\,\mathbf{z}+\mathbf{z}^{\mathrm{T}}\, \mathbf{C}\,\,\Delta\mathbf{y}+\Delta\mathbf{y}^{\mathrm{T}}\,\mathbf{C}\,\, \mathbf{z}+\Delta\mathbf{y}^{\mathrm{T}}\,\mathbf{C}\,\,\Delta\mathbf{y}= \Delta\mathbf{y}^{\mathrm{T}}\,\mathbf{C}\,\,\Delta\mathbf{y},\end{array}\]

i.e. the residual of a line fit through the four points \(\{\,\mathrm{a}\,\,\mathrm{b}\,\,\mathrm{c}\,\,\mathrm{d}\}\) is identical to the residual of a fit through the points \(\{\,\mathrm{0}\,\mathrm{b}\mathrm{-}\mathrm{b}\,\,\mathrm{c}\mathrm{-}\mathrm{c }_{1}\,\,\mathrm{0}\}\) ( Fig. 3c).

Fig. 3Implementations

a)   Datawave processor

We assume the input lists have been read and the vectors \(\mathbf{y}=[\text{a b c d}]^{\text{T}}\) have already been created. Fig. 5 shows the essential part of the Datawave implementation. \(\mathbf{y}\) - vectors arrive in cell (5,0). Columns 1 and 2 compute res2 corresponding to the 5 cases

\[\text{abcd, abc, ab d, a cd, bcd}\]

in rows 5, 4, 3, 2, 1, respectively. abcd is transmitted via column 0 and row 0 until cell (0,3). The res2 arrive in column 3, where their minimum is chosen and passed on to the north cell ( in this implementation we did not give preference to the case without missing layers ).

Cell (0,3) compares the old with the new minimum, updates the new minimum and keeps the corresponding \(\mathbf{y}\) for further computations.

The timing corresponds roughly to 30 cycles per \(\mathbf{y,}\) i.e. 120 or 240 nanoseconds per 5 least square fits. By parallelizing one easily can build up a system that runs at the desired 100 kHz speed for the second level trigger. To gain higher performance figures we could use some of the ideas we developed later, e.g. in chapter 3 c.

b)   Pipelined system 1

Here we would like to describe a hardware implementation of a similar algorithm as in [1]. We shall describe only the time critical part, the computation of the residual and the choice of the best fit. The input part which creates the quadruples is common to all our implementations and is only a small piece of hardware which we shall not describe here. (see Fig. 6)

This implementation uses the fact that the \(\Delta\mathbf{n_{i}}=\mathbf{n_{i}}\) - \(\mathbf{n_{ia}}=\frac{\mathbf{r_{i}}(\mathbf{r_{i}}\) - \(\mathbf{r_{a}})}{2\text{Rd}}\) i{{a,b,c,d} is only a function of the curvature R and the layer radius \(\mathbf{r_{i}}\) ( see Appendix 1 ). On the other hand for high \(\mathbf{p_{t}}\) ( \(\mathbf{p_{t}}>15\) GeV/c \(\mathbf{\ ->R>25m}\)) \(\Delta\mathbf{n_{i}}\) has small values (\(\Delta\mathbf{n_{i}}<30\)).

Having a quadruple \(\mathbf{y}=[\text{a b c d}]^{\text{T}}\) we can compute:

1)  \(\Delta\mathbf{n_{a}}=\text{a - a}\frac{\mathbf{r_{a}}}{\mathbf{r_{a}}}=0\)

2)  \(\Delta\mathbf{n_{b}}=\text{b - a}\frac{\mathbf{r_{b}}}{\mathbf{r_{a}}}\) (LUT-b, ALU-B)

3)  \(\Delta\mathbf{n_{c}}=\text{c - a}\frac{\mathbf{r_{c}}}{\mathbf{r_{a}}}\) (LUT-c, ALU-C)

4)  \(\Delta\mathbf{n_{d}}=\text{d - a}\frac{\mathbf{r_{d}}}{\mathbf{r_{a}}}\) (LUT-d, ALU-D)

5)   check if the differences are in the accepted range ( in the mask)

 (LUT-B, LUT-C, LUD-D)

6)   read the residual (pt,.....) from LUT-R and choose the best fit.

At the corresponding address of \(\mathbf{y=[a\ b\ c\ d]^{T}}\) LUT-R keeps the best fit of the combinations of three or all four points

This system solves the problem of fitting four points in less than T\({}_{\mathbf{f}}\) = 40ns assuming we use pipeline registers between stages. If one used the MAXVIDEO 20 system, which is very feasible, the time would be T\({}_{\mathbf{f}}\) = 50ns.

If n\({}_{\mathbf{a}}\), n\({}_{\mathbf{b}}\), n\({}_{\mathbf{c}}\), n\({}_{\mathbf{d}}\) are the numbers of hits per corresponding layer the total computing time for one RoI would be :

\[\text{T}\approx\text{(n${}_{\mathbf{a}}$+1)}\ n_{\mathbf{b}}\text{n${}_{\mathbf{ c}}$n${}_{\mathbf{d}}$}\,T_{\mathbf{f}}\]

For example in the MAXVIDEO case T\({}_{\mathbf{f}}\) = 50ns, if n\({}_{\mathbf{a}}\) = n\({}_{\mathbf{b}}\) = n\({}_{\mathbf{c}}\) = n\({}_{\mathbf{d}}\)= 3 the total computing time for one event is T = 5.4\(\mu\)s.

Of course we would only implement such an algorithm in this serial way, if the numbers of hits per layer are relatively small as in the present RD-2 data. Otherwise we would only have to parallelize just a few stages. More realistic simulation is being done.

#### c)

Pipelined system 2

Fig 7 shows the block diagram of that implementation.

The main part in the hardware implementation is computing the residual for a combination of four points. To find the residual for the five fits ( abcd, abc, ab d, a cd, bcd ) one has to compute ( see Appendix 2 ) :

1) type023 = mod((d-a),3) in ALU0, LUT0 type1 type0((c-a),2) in XOR1 type4 = mod((d-b),2) in XOR4 (ALU0, LUT0, XOR1, XOR4)
2) [b - a - \(\frac{\text{d-a}}{3}\)], [c - a - 2\(\frac{\text{d-a}}{3}\)], [b - \(\frac{\text{c}+\text{a}}{2}\)], [c - \(\frac{\text{d}+\text{b}}{2}\)] ( ALU2, ALU3, ALU1,ALU4)
3) four select signals for the five LUTs depending on whether the four above values are in the accepted range (-4,4) or not ( AND-OR2, AND-OR3, AND-OR1, AND-OR4). In a real implementation the five LUTs can be combined in two without any penalty.
4) reading the residuals from LUTs and choose the best fit. (LUT1234, LUT12x4, LUT1x34, LUT123x, LUTx234)

For all these five fits the time can be less than 40ns assuming we use pipeline registers between stages or using MAXVIDEO 20 system, T\({}_{\mathbf{f}}\) = 50ns.

The same comments about the total time T as in the previous example apply also to this implementation.

Conclusions

We described in this note some silicon strip tracker algorithms and several implementations. Because of the low occupancy of a silicon tracker we only work with lists of points ( symbolically ) and not on images ( iconically ). The performance will depend on the choice of the algorithm, which in turn depends on the way the data will be input, the role of a router, the number of hits in total and / or per layer, the degree of parallelism, the availability of processors ( e.g. DAVIS ), at which frequency, etc.

We have shown that second level silicon strip tracking algorithms can be implemented easily at the desired 100 kHz rate with today's technology.

5. Acknowledgements

We gratefully acknowledge the help and suggestions from Rudolf Bock and the discussions we had with Richard Hawkings and Tony Weidberg from Oxford University, who supplied us with the simulated data.

6 References

[1] R.J. Hawkings, A.R. Weidberg, N.N. Ellis and A.T.Watson : Second Level Electron Triggering in the ATLAS-A Detector, ATLAS Internal Note INDET-NO-013

[2] Y. Ermolin and C. Ljusin : Hough Transform Processor, CERN - LAA RT/88-06