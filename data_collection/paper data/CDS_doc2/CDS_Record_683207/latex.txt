**C++ coding standards for Atlas**

S. M. Fisher, _RAL_ and L. Tuura, _CERN_

28th August 1996

###### Abstract

Over the last few months, the ATLAS OO group has managed to come to a decision on what it would like to see as C++ coding standards to be adopted by ATLAS. This document attempts to present these standards in areadable manner--with some explanation and examples. The standards are then collected together at the end as a checklist for reviewers. This checklist will also be maintained as an appendix of the 'Atlas Software Process' document.

$Date: 1996/08/28 14:54:25 $

$Revision: 1.4 $

###### Contents

* 1 Introduction
	* 1.1 Why have standards?
	* 1.2 Document structure
* 2 The standard
	* 2.1 Layout on the page
	* 2.2 Header files
	* 2.3 Implementation files
	* 2.4 Argument passing
	* 2.5 Initialisation
	* 2.6 Constructors, destructors and memory management
	* 2.7 User defined operators
	* 2.8 Inheritance
	* 2.9 Names of things
* 2.10 Use of the pre-processor
* 2.11 Portability issues
* 2.12 Control structures
* 2.13 Dangerous or superfluous constructs
* 3 Design issues
* 4 Summary of the rule set

[MISSING_PAGE_EMPTY:2]

Introduction

### Why have standards?

The purpose of this document is to collect together a list of standards which should be followed when writing C++ code. It assumes that the code is hand-written and not 'generated' otherwise a different set of standards would be needed for the input to the code generator.

Standards are needed for different purposes. Some things which are permissible in C++ are relics of C which most people would consider to be best avoided. Some standards relate just to the appearance (and so the readability) of the code, but have no effect upon the output of the compiler. These are here because the code has to to be reviewed and should last a long time--long after some programmers have left particle physics to get a real job.

These standards should cause no problem to new programmers, but they might be perceived as a nuisance for established C and C++ programmers. These standards were arrived at by a long process within the ATLAS-OO group. In most cases some kind of consensus was reached, but in others a vote was needed. Some of the decisions are somewhat arbitrary, however some things do not matter (e.g. which side of the road we drive on) provided that we all do it the same. The standards comprise a set of rules which are to be followed for all code which is to to be reviewed; this should include all code which has any impact upon a published physics result. None of these rules is absolute. A rule can be waived, but only by prior agreement, following a procedure defined in the 'Atlas Software Process' (ASP). Some of the rules could be checked by a program but others will require a human being--a reviewer.

We imagine that these rules will be modified a little in the future, either to restrict practices which prove to be dangerous, or to allow things which had been banned. Relaxing or removing a rule has no impact upon existing code, but strengthening a rule, or adding a new rule, will upset programmers because it may invalidate existing code. For this reason we propose to start with this rather detailed set of rules.

### Document structure

After this introduction comes the main body of the standards. Each rule is followed by its source (in parentheses), which is one of:

**B&N Barton and Nackman**, _Scientific and Engineering C++_, Addison-Wesley, 1994, ISBN: 0-201-53393-6
**Gamma**: Gamma et al., _Design Patterns_, Addison-Wesley, 1995, ISBN: 0-201-63361-2

###### Abstract

We present a new method for computing the number of events in a number of test books, though it cannot be said to be the 'best' on any objective grounds. We show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds. We also show that the number of events in a number of test books is at most \(100\), which is the best on any objective grounds grounds grounds grounds grounds grounds.

**CXX-3**: Long statements should be arranged on multiple lines in a way which maximises readability. (Atlas)

This is subjective, however a reviewer should be able to spot what is not easy to read.
**CXX-4**: For control structures, layout code with the bracestarting a compound statement on the end of the line introducing the control structure, then indent the components of the compound statement by 4 spaces (each starting on a new line) and align the closing brace (also the case and default keywords for a switch statement) with the start of the control structure. The closing brace will be on a line of its own except if the next keywords else. If tabs are used they are assumed to be every 8 columns. (Based on CMS)

Example of a simple for loop:

for (int i = 0; i < size; i++) {

sum += something(i); }

Example of an if statement:

if (x < 0) {

y = -x;

cout << "x was negative" << endl;

} else {

y = x;

}

Example of nested if:

if (c == 'a') {

cout << "It was an a" << endl;

a++;

} else if (c == 'z') {

cout << "It was a z" << endl;

z++;

} else {

cout << "It was neither a nor z" << endl;

}

The same logic with a switch statement:

switch (c) {

case 'a':cout << "It was an a" << endl;  a++;  break;  case 'z':  cout << "It was a z" << endl;  z++;  break;  default:  cout << "It was neither a nor z" << endl;  break;  }
**CXX-5**: Uesparentheses and spacing to make expressions easier to read. (B&N p30)  This is also subjective, and so relies upon the good judgement of the reviewer.
**CXX-6**: If a control structure (if, for, door while) does not use a compound statement it must be coded on one line. (Based on B&N p32)  For example:

 if (x < 0) x = -x;  Which might also have been coded:

 if (x < 0)  x = -x;  }

 but _not_

 if (x < 0)  x = -x;

### Header files

**CXX-7**: Name the header file after the class, using the same case. (Based on Taligent)  This is the simplest convention possible. So a class _Track_ has a header  file called _Track.h_
**CXX-8**: C++ header files use the suffix '.h'. (CMS)  There are other conventions which distinguish between C header files  and C++ headers. However we should have very few C headers except in a few wrapper classes hiding old C code, so we have selected the most popular suffix: '.h'. For example a class _Track_ will have a header file called _Track.h_.
**CXX-9**: Header files should begin and end with multiple-inclusion protection, as follows:

#ifndef FILENAME_H  #define FILENAME_H  // The text of the header goes in here...  #endif // FILENAME_H

 The symbol, FILENAME_H, is constructed by taking the text which normally follows the #include where the file is included, and converting '.', '/' and '.' to '.' and all letters to capitals. (Atlas)

 This protects the header file from multiple inclusion and circular-references.

 For example the file normally included by:

#include "e-calorimeter/seed.h"

 would take the form:

#ifndef E_CALORIMETER_SEED_H  #define E_CALORIMETER_SEED_H  // The text of the header goes in here...  #endif // E_CALORIMETER_SEED_H

 Note the use of the same symbol as a comment on the #endif line. This is required if the text is more than five lines as is explained later.
**CXX-10**: Some member function may be self-descriptive by their names and argument types, otherwise provide a short description after the declaration of the member function. (Based on CMS)

 For example:

 class Point {  public:  Point(Number x, Number y); // Create from (x,y)  Number distance(Point point) const; // Distance to a point  Number distance(Line line) const; // Distance from a line In this example the comment adds little information, but it is much easier to scan the header to find a suitable method.
**CXX-11**: Include dummy argument names in function declarations unless the meaning is clear without them. (Atlas)

The previous example is easier to understandthan:

class Point { public:  Point(Number, Number); // Create from (x,y)  Number distance(Point) const; // Distance to a point  Number distance(Line) const; // Distance from a line };
**CXX-12**: Data members of a class should be declared private or protected. (Based on B&N p89)

This ensures that data members are only accessed from within member functions. Hiding data makes it easier to change implementation and provides a more uniform interface to the object.

For example:

class Point { public:  Number x() const; // Return the x coordinate  private:  Number m_x; // The x coordinate (safely hidden) };

The fact that the class _Point_ has a data member _m_x_ which holds the x coordinate is hidden.
**CXX-13**: Header files should not have any method bodies inside the class definitions. (Atlas)

This is to keep the interface easy to read. Note that this is not banning inline code. See the next example for how it should be done.
**CXX-14**: Use inline functions only to return values stored as private member data. (B&N p55)

For example:

class Point { public:  Number x() const; // Return the x coordinateprivate  Number m_x;  };

Number Point::x() const { return m_x; }
**CXX-15** Any bodies for inlining should go at the end of the header file after the class definition. (Atlas)

See previous example.
**CXX-16** Classes are declared with friends first then public, protected and private. Within each section nested types (e.g. enum or class) should appear at the top. (Atlas)

For example:

class Path {

friend Path & operator + (const Path &, const Path &);

public:  Path();  ^Path();

protected:  void draw();

private:  class Internal {  // Path::Internal declarations go here  };

};

As the default at the beginning of a class is private, this means that friend declarations appear within a private section. However friend declarations are unaffected by the private, protected and public keywords, so placing them at the beginning seems most natural.

The use of friend operator functions, as in the case above, is the only good use for friends.
**CXX-17** Global functions should only be used for symmetric binary operators and where a global function seems more appropriate than using an object e.g. mathematical functions. (Basedon Taligent)

### Implementation files

**CXX-18**: Name the implementation file after the class, using the same case. The file name should be abbreviated if it is longer than 16 characters. (Based on Taligent) The reason for the limit of 16 is that the object library (ar) format on Unix only stores the first 16 characters of the library member names.
**CXX-19**: C++ source files use the suffix '.cxx'. (Atlas) This provides compatibility with most compilers.
**CXX-20**: Generally a file will hold all the member function definitions for a single class. If one class is embedded within another or if two classes are tightly coupled the member function definitions would be expected to share a file. (Based on CMS)
**CXX-21**: Atlas defined header files should be included with a statement of the form #include "directory_name/file_name.h". Normally at least one level of directory should be specified. (Atlas)
**CXX-22**: Use incomplete types instead of including a header file if this is sufficient. (Atlas) For example:

class Line;

class Point { public: Number distance(Line line) const; // Distance from a line }; Here it is sufficient to say that _Line_ is a class, without giving details which are inside its header. This saves time in compilation and avoids an apparent dependency upon the _Line_ header file.
**CXX-23**: Comments should be kept short and informative, and not echo the code. A block of comments should describe the overall function of the classes in the file, and each method should also have a comment saying what it does, and if not obvious, how it does it. (Atlas) Some of the comments accompanying the code fragments in this document do echo the code and so break this rule. This is because the examples have been chosen to be rather trivial, yet we wanted to show some comments.

### Argument passing

**CXX-24**: When passing objects to a method, when they are not to be modified, pass by value if they are small, otherwise by constant reference. (Based on B &N p129)

Passing an object by value creates a new copy of the object, which is fine if the object is small. Passing by constant reference passes the address of the object however the compiler will not allow the arguments to be modified.

For example:

class Point { public:  Number distance(Point point) const; // Distance to a point  Number distance(const Line & line) const; // Distance from a line }; Here a _Line_ may be large so it is passed by constant reference.
**CXX-25**: Signal input-modification side-effects by consistent use of type  modifiers in the declaration of the formal arguments. (B &N p125)

If the previous example had been written:

class Point { public:  Number distance(Point point) const; // Distance to a point  Number distance(Line & line) const; // Distance from a line };

the member function, _Number distance(Line &)_ const, would be allowed to modify the _Line_ passed to it.
**CXX-26**: Declare as const those member functions that are not meant to  alter member data. (The mutable keyword should be used where  appropriate.) (B &N p145)

For example:

class Point { public:  Number distance(const Line & line) const; // Distance from line  void translate(const Vector & vector); // Shift a pointhere we see that whereas the first function is const, _translate_ is not, because it changes _Point_. Declaring member functions to be const where they are not meant to modify member data makes the code safer, and is useful in under-standing what a class is supposed to do.
**CXX-27**: Make only limited use of default arguments (or the equivalent overloading with different number of arguments). (Taligent) This is rather subjective, so the reviewer must decide if the use made of this feature is worth the risk. The risk is that if you miss off an argument by mistake, you will not be told by the compiler. For example with:

class Point { public:  Point(Number x, Number y = 0) ; // Create from (x,y) }; then Point p(10); would be valid and equivalent to: Point p(10, 0); This might be what you want to happen, or it might be a typing error.
**CXX-28**: Do not declare functions to have unspecified arguments (i.e. avoid using '...'). (Taligent) The compiler cannot check unspecified arguments. This facility was used by the C library function, printf. Now cout should be used instead.
**CXX-29**: Use references rather than pointers as arguments whenever possible. (Based on Taligent)

References are more convenient than pointers, however sometimes a pointer must be used for example when the function you call retains a reference (an alias) to the object you are passing in, such as when you construct a dynamic data structure.
**CXX-30**: If a function returns a value and has side effects (such as modifying its input parameters), then this should be apparent from the choice of name. (Atlas)