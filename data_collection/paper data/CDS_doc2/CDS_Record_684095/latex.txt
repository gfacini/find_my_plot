# Java in Atlas - coding standards

Steve Fisher

<s.m.fisher@rl.ac.uk> Julius Hrivnac

###### Abstract

This document addresses a number of issues relating to the use of Java in ATLAS: coding standards and programming advice, the build environment and a little on the co-existence of Java and C++. Some aspects will need to be considered by the Architecture Team, the Technical Group or the Quality Control Group.

15th August 2000

## 1 Standards

1.1 Existing standards

1.2 Naming Conventions and the Package Structure

1.3 Overriding methods of Object

1.4 Import statements and qualification of names

1.5 Clarity of code

1.6 Resources

1.7 Avoid surprises

2. Programming advice

3. Build Environment

3.1 Handling by ART

3.2 Building and testing

3.3 JAR files

3.4 Documentation

3.5 Tools

4. Guidelines for Java - C++ co-existence

4.1 Interfacing

4.2 Impact on C++

## 2 Standards

Do not be dismayed by the number of issues listed here. We suggest that you skim through the whole document and initially try to observe at least the naming conventionsdescribed in Section 1.2 and adopt the Javadoc (JS3) style of comments as changing these later is tedious. Later, when you have more experience of Java, reread the document more carefully.

### 1.1 Existing standards

It would be best if we agree on standards early to avoid problems in the future and follow existing industry standards where applicable.

JS1

All Java code is expected to follow the current standard as defined in the Java Language Specification [1].

JS2

The Code Conventions for the Java Programming Language ([http://java.sun.com/docs/codeconv/](http://java.sun.com/docs/codeconv/)) as defined by Sun will all be followed unless anything below relaxes or otherwise modifies one of these conventions.

JS3

ATLAS should follow the standard Javadoc conventions ([http://java.sun.com/products/jdk/javadoc/writingdoccomments/index.html](http://java.sun.com/products/jdk/javadoc/writingdoccomments/index.html)) for Java documentation.

This will help in maintaining and documenting the code as most tools such as the.

Javadoc tool ([http://java.sun.com/products/jdk/javadoc/](http://java.sun.com/products/jdk/javadoc/)) or Together ([http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/tools/case/Together/](http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/tools/case/Together/)) know how to automatically handle them and how to produce high quality documentation from them.

### 1.2 Naming Conventions and the Package Structure

JS4

All ATLAS packages should be below net.hep.atlas.

The convention offered by Sun is that the prefix of a unique package name is always written in all-lowercase ASCII letters and should be one of the top-level domain names. Subsequent components of the package name vary according to an organization's own internal naming conventions so we can stay with our C++ convention for that (capitalizing first letters of multi-letter names).

The application of that rule in our environment means, that top-level ATLAS package should be net.hep.atlas. This convention is being followed by many Java projects.

## Note

There is some dispute over the choice of the first element of the name which we indicated to be net in the example above.

JS5

The package structure of Java packages should be the same as the package structure of C++ packages. The package names will be simpler, as the Java namespace environment doesn't require repeating of higher level packages names in the sub-package name. Java and C++ should split on the Domain level and be organised in an independent tree under it.

For example:

C++ package

offline/InnerDetector/InDetEvent

Java package

offline/InnerDetector/java/net/hep/atlas/offline/InnerDetector/Event

JS6

Interfaces between Java and other packages should be generally placed within the Java directory structure (especially when they use standard Java solutions such as JNI).

JS7

We should name entities in Java in the same way as in C++ but using capitalisation rather than the old ATLAS underscore style.

For example, wafer_pos becomes waferPos.

## Note

This style is very common, and is recommended by SUN. Also the ATLAS C++ rule, specifying the use of underscores, has not been generally respected.

C++ conventions for data members and static functions (m_, s_) should be used.

JS9

Atlas Offline Computing/ Package naming structure conventions

([http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/packages.html](http://www.cern.ch/Atlas/GROUPS/SOFTWARE/OO/packages.html)) should be used, except that prefixes and suffixes are not applicable as they are replaced by Java package structure.

JS10

Names of collections should reflect their expected contents.

For example: "ArrayList listOfTracks; orjust: "ArrayList tracks;.

Note

A comment with the declaration of the collection can be used to clarify the intended use.

JS11

Acronyms should be converted to lower case then treated as a single word and concatenated and capitalised as required by rule JS7.

For example, the C++ name HTML_Thing in Java would be htmlThing if it was the name of an object or HtmlThing if the name of a class.

JS12

Names of classes which inherit from Exception should end with Exception.

Note

This can be checked by Together as rule NOEC

JS13

Declarations of variables should not hide other declarations of the same name.

Note

This can be checked by Together as rule HONOnly make methods and constructors public if you want them visible outside the package.

## Note

The default is package visibility. By leaving the internals of the package hidden from the outside it makes the intended use of the package clearer and gives it a clean interface to the rest of the world.

## 1.3 Overriding methods of object

JS15

All re-implementations of the Object methods should fulfil all required contracts as defined for the API of class Object ([http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html](http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Object.html)).

JS16

Clone should be implemented in a way that gives x.clone().equals(x) == true.

## Note

As the default equals() is the same as == this implies that equals() must also be overridden.

JS17

Clone should normally call super.clone() as well as doing whatever is specific to itself. It should not invoke any constructor.

The following is an example _to be avoided_:

public class BaseClass implements Cloneable { public BaseClass(...) {...} public Object clone() { returns new BaseClass(...); } public class ChildClass extends BaseClass {... } // wrong: it returns //BaseClass as its clone JS18

When implementing the method equals, remember that it should be reflexive x.equals(x) == true, symmetric x.equals(y) == true iff y.equals(x) == true and transitive x.equals(y) == true and y.equals(z) == true => x.equals(z) == true and that for non-null reference value x, x.equals(null) == false.

When implementing finalize, super.finalize() should be called.

JS20

Nothing should depend on calling finalize as it may not be called as the virtual machine exits.

### 1.4 Import statements and qualification of names

JS21

The use of * is to be avoided in import statements except for the basic libraries.
JS22

Do not import the package to which the source file belongs.

Note

This can be checked by Together as rule DIPSFBT

JS23

Do not explicitly import classes from java.lang.

Note

This can be checked by Together as rule EIOJLC

JS24

Do not import packages or individual classes or interfaces which are not used.

Note

For classes and interfaces this can be checked by Together as rule IIMBU

Note

The aim of this rule is to eliminate clutter.

JS25

There should be at most one import declaration that imports a particular class.

## Note

This can be checked by Together as rule DTD

### 1.5 Clarity of code

If code is clear in its intention it is more likely to be understood and so correctly maintained.

JS26

Methods of a class should not have the same name as the class.

This is an example _to avoid_:

class Fred { Fred() { System.out.println("Fred is constructed"); } int Fred() { // Don't do this return 1;};}

## Note

The language standard does allow method names to be the same as class names and so look like constructors.

JS27

The Javadoc @paramtag should be used to make it clear if an object passed in to a method will be modified or stored (and so be potentially modifiable later).

JS28

Methods that return values should not modify state.

## Note

This can be checked by Together as rule CQS

## Note

There will be exceptions as exemplified by the method readLine of java.io.DataInput which moves the file pointer and so will return a different line next time it is called. Writers of classes with synchronized methods may also be unable to respect this rule.

## Note

All justifiable exceptions to this rule should be clearly documented.

JS29

Except for arithmetic operations, use parentheses rather than relying upon operator precedence.

## Note

For logical operators this can be checked by Together as rule MLOWP

## Note

You may also choose to make your arithmetic easier to follow by use of parentheses to clarify the structure.

JS30

Variables which are not modified should be declared final.

## Note

This can be checked by Together as rules CPAMBF and CVMBF

## Note

This rule make clear the intentions of the code and prevents you from accidentally modifying the variable.

JS31

Do not use multiple assignments in an expression, nor make assignments within an expression.

Examples to be avoided are:

i *= j++; i = j = 10; i = j += 15; i = j++ + 20; i = (j = 25) + 30; if (i = 20) {...

## Note

This can be checked by Together as rules CA and NAICEDo not make assignments to the formal parameters or a method.

## Note

Such assignments do not do any harm, but because they appear to be modifying what they cannot modify, this can cause confusion.

## Note

This can be checked by Together as rule ATFP

* [label=JS03]
* Call static methods through class reference.
* Note
* This makes the code easier to understand.

## 1.6 Resources

* [label=JS03]
* Nullify temporary references to objects taking large amount of memory as soon as they are no longer needed.
* [label=JS03]
* If a class reserves external resources (e.g. files or windows) provide it with a finalize method to release these resources when the object is destroyed.
* [label=JS03]
* Do not create temporary Strings in loops.
* For example String pluses = ""; for (int i = 0; i < n; i++) { pluses += "+";}
* Presume that n is an integer. The statement pluses += "+"; creates a new String each time as String is immutable. Instead write:StringBuffer pluses = new StringBuffer(); for (int i = 0; i < n; i++) { pluses.append("+");}

## 1.7 Avoid surprises

JS37

Avoid using == to compare Strings, use String.compare(...) or String.equals(...) instead.

Note

Because of the way in which String literals are handled the == will often work but you may get caught out.

JS38

Provide a default constructor (i.e. one without arguments) whenever a meaningful object can be thus created and the system provided constructor is not adequate.

JS39

Do not write non-functioning implementations of a method

Note

A non-functioning implementation is any which fails to meet its contract, typically an empty method. Declare a method to be abstract to force an inheritor to provide a functioning implementation.

## 2. Programming advice

This is just a collection of bits of advice which cannot be considered to be standards.

JA1

Understand the use of getClass() which returns the class of an object (from which its name could be obtained) and the operator instanceof which is used for checking type conformance.

JA2

Don't forget to use the finally clause in a try block when it is needed to clean up resourcesDon't give overloaded methods and constructors different visibilities. Note

This can be checked by Together as rule ICAMM

JA4

Arrange methods and attributes into related groups without considering their visibility.

## Note

This is different from the C++ recommendation because for C++ the header file is the specification of the interface.

JA5

Understand the rules for overloading methods just on argument type. Though Java considers the actual type of an object at run time when choosing the method to invoke, the consideration of arguments is made at compile time. If you are accustomed to C++ you can get surprises.

For example the following program:

class Classifier { String identify(Object x) {return "Object" ;} String identify(Integer x) {return "Integer";} class Relay { String relay(Object o) { return (new Classifier()).identify(o);} public class App { public static void main(String[] args) { Relay relayer = new Relay(); Integer i = new Integer(17); System.out.println(relayer.relay(i));}} will display Object rather than Integer

JA6

The methods clone(), equals() and hashCode() are often updated together. Consider carefully in each case what you want equality to mean, and document it with the code. Also bear in mind that confusion may be caused it you change the hashCode of something which has been stored in a collection which is organised by hashCode.

## 3 Build Environment

### 3.1 Handling by ART

ART should support Java as one of its standard languages. This means, in case of SRT, that following constructions should be supported and should lead into appropriate actions (as defined elsewhere in this document):

TARGET_JAR = xxxjar xxx.jar_SRC = yyy.java

The CLASSSPATH should be set correctly for dependencies to allow compilation to be performed.

A script should be generated to run the program which sets the necessary CLASSSPATH variable and invokes the Java virtual machine with the correct starting class.

### 3.2 Building and testing

Build and test on each platform. For the platform which is considered to have the best compiler, test that build on all other platforms and install that build.

### 3.3 JAR files

As Java package structure will reflect the structure of C++ packages, Java JAR files should roughly correspond to the C++ libraries. Generally, one JAR file will contain several "Java packages". The exact way should be decided on case-by-case basic.

JAR files should be installed into the installed/share/java release directory.

### 3.4 Documentation

Javadoc documentation and Together documentation should be created automatically (without user' interventions).

User should be able to customize that documentation (using standard means defined for Javadoc and Together).

### 3.5 Tools

Tools helping in Java development should be provided. This means: Profilers, Code Checkers, Debuggers, CASE Tools and possibly IDEs.

## 4 Guidelines for Java - C++ co-existence

### 4.1 Interfacing

Packages should not mix languages if possible. Packages should use standard and strict interfaces. Direct calls across the language border should by-pass those interfaces only exceptionally. Inter-language communication (using JNI, or CORBA) should not be mixed with network communication (using RMI or CORBA). Those are different concepts, serve different purposes and should be independently replaceable.

### 4.2 Impact on C++

As our C++ coding standards evolve, they should move in a direction which simplifies interoperation with, and migration towards, Java. This means keeping the C++ simple - which is probably a good thing.

## Bibliography

[GOS96]_Java Language Specification_ ([http://java.sun.com/docs/books/jls/](http://java.sun.com/docs/books/jls/)): This is for Java 1.0. The online version is linked from this page as are the amendments for version 1.1 ([http://java.sun.com/docs/books/jls/clarify.html](http://java.sun.com/docs/books/jls/clarify.html)). James Gosling, Bill Joy, and Guy Steele. 1996. 0-20106345-1. Addison-Wesley.