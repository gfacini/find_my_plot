**AGE**

**Version v1**

_Christian ARNAULT_

LAL - Orsay, France. arnault@lal.in2p3.fr

June 29, 1995

## 1 Presentation

The DICE95 framework [1] as it is proposed today plans to simplify the process of defining the simulation (and reconstruction) applications by means of a language that can express the majority of Geant services [2] used for describing the detector, as well as various definitions for hits or digits structures.

It appears that this original aim could be extended to cover more general needs, among which one could mention :

* providing a general formal specification document for the Atlas detector description that would then be seen as _the standard reference_ for any application dealing with the detector description (such as online applications, reconstruction, event displays, etc...)
* being a source for filling up the databases for the geometry that will be installed in the future.
* being a source for automatic code generators in programming environments outside the simulation framework, especially when the geometry model must be extended, or when there are different language constraints or coding conventions.

DICE95 brings an efficient means of handling the particular constraints required by a quite complex detector such as Atlas, since the geometry (in term of a hierarchy of volumes) cannot be specified simply as a set of volumes each with a set of values characterizing its attributes. Instead Geant proposes to use volume _templates_, where the attributes of a volume can be specified by a value or a computed expression, and the volume position is specified algorithmically.

The description of the position algorithms, as well as the computed expressions used to define the various attributes of the detector components must be installed within the geometry database in order to export its definition entirely.

Thus this proposition plans to define completely and precisely the AGE language, by defining its _grammar_ and _syntaz_ in order to build a set of tools, able to cover the needs mentionned previously.

### Why define a grammar and a syntax?

In order to be _re-used_ or transported in various environments such as a database or the reconstruction applications, the geometry specification statements must be _understood_ first so that translation programs, or interpretors can be applied to it.

The concepts used in the definition, such as expressions, algorithms or natural language comments must be preserved in this kind of operations.

A grammar is a means to describe the semantics (or meaning) of the words (or other syntax elements) of a language. Once its grammar is defined and modelled, a language becomes a specification language, and as long as its semantics remains unchanged, one may easily provide tools for :

* checking the consistency of the specification itself,
* translating its source form into various other languages (such as programming languages or database input directives),
* interpreting the definition, yielding efficient means of online evaluations for the detector definition.

The other benefits of such an approach include :

* To provide mechanisms to manage the version evolution of the geometry and data formats so that :

* any previous version can be retrieved
- conversion mechanisms can be provided between successive data formats.
* To provide a reliable and readable language that could survive both the technology evolution and the turn-over of people in the physics community in the next years.
* To be independant of the actual version of Geant (as long as the geometry model remains stable). This should allow the conversion of the model to the future model of Geant4.

### The principles in the language design

Several principles have been applied in order to complete the language design :

* The grammar and syntax definitions must be complete i.e. every word of a given description must be understable by the language (for instance even comments have a meaning).
* The syntax must be coherent and readable, i.e. ambiguities or conflicts must always be resolved by the parser, which requires to explicitely declare every symbol and to use separators to enclose compound constructs.
* The parser should detect as soon as possible violations to the rules and provide for comprehensive diagnostics and comments (or possibly hints for fixes).
* The selected syntax must permit and prepare a smooth evolution towards more structured (or object oriented) syntaxes.
* The syntax must be independant of the textual formatting issues used to produce the source description (i.e. end-of-lines or position in the line should not be meaningful).
* The parser is only responsible for understanding the concepts introduced in the detector description source, whereas the generators (acting on the result of the parsing) are responsible for deciding _what to do_ with these concepts.

The main characteristics of the Age language

The language is formed by the juxtaposition of two main services :

* describing the detector geometry architecture and material composition.
* describing the way the actual volume hierarchy is constructed.

For the first part, a set of syntactical constructions (already defined and specified in the original DICE95 proposal [1]) has been introduced, that exploits the Geant geometrical concepts. For the second part the Fortran language has been to a large extent reused in order to provide for mathematical expression and control operations.

The basic characteristics and services offered by this language are :

* The geometry model is essentially based on the Geant model.
* The language is structured into modules corresponding to subdetectors. This could be exploited for applying version control mechanisms onto the overall specification: Atlas being then configured to use a given set of modules, each specified with its own version.
* The syntax for expressions and executable statements originates from the Fortran syntax with some refinements, simplifications or extensions, such as :
* Positionning constraints in the line are removed :
* no longer limited to 72 characters.
* multi-line statements are allowed.
* statements may start at any position (even at column 1).
* Words that are not naturally separated by special characters (such as commas, parenthesis, etc...) must be separated by spaces (or new-lines), as shown in the following example : Use doi = 1, n instead of doi = 1, n
* In consequence of the previous rule, the space character is a true separator between words. Thus spaces cannot be embedded within words or constants.
* Variable declaration is mandatory (equivalent to using implicit none).
* Direct array assignment is introduced (the list of expressions is then enclosed in braces):... real x(10)... x = { 1., 2., 3. }...

- Comment marks is unique ('#') and has been selected to be unambiguous with reserved characters of most conventional languages. Comments are only single line comments.
* _Include files_ are not supported.
* 10 statements are limited to the use of print (and one can use as format only
* or character string).
- Every symbol used in the specification should be defined within the specification document itself. References to variables defined in a common block or in a +DECK-like statement must be avoided.
* The syntax is not case-sensitive.
* The new keywords corresponding to the Geant constructions are reserved words and thus cannot be used in place of a symbol. This is true also for Fortran keywords (such as if, while, do, etc.) that become reserved words (as opposed to _normal_ Fortran where they may be used as variables).
* The symbols used for describing the various Geant concepts (shapes, materials, volumes, etc...) are managed in separate individual names spaces (also separated from the variables) preventing potential name conflicts.

## 3 The parser for the Age language

Following the principles described previously, a prototype of a parser that understands the proposed syntax, and produces the architecture of software components for the various generators has been produced.

It is based on the description of the syntax and grammar using the Unix tools Lex and Yacc, and on the formal model describing the possible grammatical constructs of the language that can be deduced from it.

The formal model is then translated into an object-oriented data model, and implemented using class definitions (Using Ansi C language with object-oriented coding style).

A parser application is built, able to analyse modified versions of the existing DICE95 representations. The result of such an analysis is on the one hand to provide a comprehensive set of error diagnostics, and one the other hand, to instantiate the set of objects corresponding to the analysed source file.

The defined classes provide a generic behaviour for generating an external representation of the source file. A user application (or package) can redefine in a specific manner this behaviour in order to specialize the kind of representation he/she needs. This is achieved by declaring a complete set of specialized generation functions (one per class of the meta-model) that the user would provide. This mechanism permits translations to different languages (such as Fortran, HTML, C, C++, Effel, DBMS formats etc...) or even to produce interpreters.

### Technical description of the parser design

A parser is made of two components :* The grammar analyzer (_the engine_), which produces (instanciates) the objects that correspond to the source description.
* The user format generator (_the translator_) made of a collection of specialized methods for each of the classes of the grammar meta-model.

The meta-model (described in a following section) is a set of classes such as :

Module Block Structure Variable Statement CallStatement LoopStatement TestStatement Comment Statement GeantStatement PrintStatement Expression Binary Unary Primary Value StringValue IntegerValue RealValue FunctionCall...

The parser environment is provided as a library of callable functions, from which a user builds a translator program that will translate a given textual source description into a format of his/her choice.

One generator method redefinition can be declared to the engine, using the specialized functions :

AgeModuleDeclareGenerator AgeBlockDeclareGenerator AgeVariableDeclareGenerator AgezzDeclareGenerator...

where _zzz_ stands for any possible class which behaviour needs to be specialized. Each redefined method is built following a similar pattern :

* it is a C function,
* its name is free since the function is given as the argument to the installation functions,
* it receives as its unique argument a reference to the actual object it will act upon, as show in the example :

/*------------------------------------------------------*/ static void BlockGenerate (AgeBlock This)/*---------------------------------------------------------------------------------------------------------------------------------*/ /*Generationforablock.*/ /*---------------------------------------------------------------------------------------------------------------------------------*/ {... }

/*-----------------------------------------------------------------*/ staticvoidStructureGenerate(AgeStructureThis) /*-----------------------------------------------------------------*/ /*-----------------------------------------------------------------*/ {... }

/*-----------------------------------------------------------------*/ staticvoidXxxGenerate(AgexxxThis) /*-----------------------------------------------------------------*/ /*-----------------------------------------------------------------*/ {... }

/*-----------------------------------------------------------------*/ staticvoidXxxGenerate(AgexxxThis) /*-----------------------------------------------------------------*/ /*GenerationforabXxxobject.*/ /*-----------------------------------------------------------------*/ {... }

*attributesofthevariousobjectscanberetrievedusingqueryfunctions.Everyclassprovidesthecompletesetofqueryfunctionsneededtoretrievedallpossiblepublicattributesoftheirinstances.Thesefunctionsareallformedusingthescheme:

AgeClassNameGetAttributeName(AgeClassNameobject); Whereobjectisthesamereferenceastheoneprovidedtothegeneratorfunction.Asanexample,thefollowingcodeshowsatypicalgeneratorfunctionforabBlock

/*-----------------------------------------------------------------*/ staticvoidBlockGenerate(AgeBlockThis) /*-----------------------------------------------------------------*/ { char*name; char*comment; AgeArrayvariables; AgeArraystatements; if(!This)return; name=AgeBlockGetName(This); comment=AgeBlockGetComment(This); variables=AgeBlockGetVariables(This); statements=AgeBlockGetStatements(This); /*Then attributes (name, comment, etc...) may be formatted according to the context. */ }

#### 3.1.1 The meta-model

From a simple example, one can describe how the language grammar may be translated into a formal model:

Let's consider a Fortran loop statement. This statement may take two different forms:

do i = 1, n ...  enddo

or

do while (...) ...  enddo

The corresponding grammar specifications (expressed using the Yacc syntax, which is very similar to the EBNF standard syntax) is:

do :

DO iterator '=' start ',' end statements ENDDO

| DO WHILE '(' test ')' statements ENDDO

where :

it erator represents the iterator variable used to go through the range,

start represents the expression for the start of the iteration,

end represents the expression for the end of the iteration,

test represents the expression that controls the iteration,

statements represents the set of statements that are executed over the range.

From these definitions, one then deduces directly the corresponding set of classes (the elements of the meta-model) that describe the grammatical constructs (here, the _variable_, the _expression_, and the _statement_).

The syntax of the Age language

To understand the syntax is defined below, note that

* A word in _italics_ represents a construct of the language which is defined in terms of other constructs. The first box below defines what a _module_ is.
* A word in bold font is a keyword, for instance: **if then else endif**.
* Something between \(<>\) can be a symbol (not a keyword), a numeric constant, or a string, For instance the second line of the _module_ definition below, one has the symbol <name> refering to the module name, e.g. GAASGEO.
* An optional construct is enclosed in [ ], as in [ _comment_].
* When there is an alternative between two constructs, one uses | (see _function-type_ below).
* Required constructs are enclosed in { }, as in _function-type_
* The possible repetition of a construct is expressed with... so that [ _comment_]... means that a _comment_, which is optional, can be repeated.
* The character(s) between'(single-quotes) are a required part of the construct syntax. For example, a _structure_ must have a set of _fields_ within braces.
* Finally, <rest-of-line> refers to the set of characters remaining on the line.

_module_ :

[ _comment_]...

module <name> <rest-of-line>

[ _comment_]...

author <rest-of-line>

[ _comment_]...

created <rest-of-line>

[ _comment_]...

[ _comment_]...

[ _structure_]...

[ _module-statement_]...

[ _block_]...

[ _comment_]...

end

[ _comment_]...

[ _function_]...

[ _comment_]...

[ _comment_]...

``` comment: '#' <rest-of-line> content: content<name>[ ',' <name>]... structure: structure<name>'{' field... '}'_field_: <name>[field-dimensions] field-dimensions_: '('field-dimension[','field-dimension]...')' field-dimension_: <integer-number>[':'<integer-number>] block: block<block-name><rest-ofline> [block-statement]... endblock
[comment]... function: function-typefunction<function-name> formal-argumentsfunction-body subroutine<function-name> [formal-arguments] function-body function-type: {real|integer|character} formal-arguments: '('<name>[','<name>]...')' function-body: [function-statement...]end ```
module-statement: declaration fils statement: declaration attribute shape hits digits statement: function-statement: declaration <function-name>'='expression statement return
```

_statement_: _call_ loop test_print_material_mizture component_medium use create position create-and-position comment_material:  material{ <name>|<material-name>}[ parameters ]  material{'('selector-expression')' '{'<material-name>[','<material-name>]...'}'  selector-expression:  expression ```
Note that the value of the selector-expression indicates which <material-name> to be used by refering to its position, starting with 1.)
``` mixture{<name>|<mixture-name>}[ parameters ]  component{<name>|<component-name>} [parameters]  medium{<name>|<medium-name>}[parameters ]  use<structure-name><field-name>'='expression  create:  create<block-name> position<block-name> ```
``` position<block-name>[parameters]  create-and-position:  createandposition
```

```
fill:  fill<structure-name>comment '{'field-assignment...'}' field-assignment: <field-name>'='expression comment <array-field-name>'='{'expression'}' comment  attribute:  attribute<block-name>parameters  shape:  shape<shape-name>parameters
```

```
hits:  hits<block-name>hit-digit-parameters  digits:  digits<block-name>hit-digit-parameters
```

```
parameter: <name>'='expression <name>'='{'expression'}' parameteres: '{'parameter...'}'
```_hit-digit-parameter:_ <name> ':'hit-digit-size ':'[hit-digit-range] _hit-digit-parameters:_ '{'hit-digit-parameter...'}' _hit-digit-size:_ _expression_ _hit-digit-range:_ _'('expression','expression')' _declaration:_ _variable-type new-variable [','new-variable]... constant_ _extern_ _variable-type:_ {real |integer | character } _new-variable_:_ <name>[dimensions] [initialization] _dimensions:_ '('dimension[','dimension] ')' _dimension:_ _<integer-number>[':'<integer-number>] _initialization:_ '/'values'/' _constant_:_ _parameter constant-def[','constant-def]... constant-def:_ <name>'='value_ _extern_ <name>[','<name>] _value_:_ _unary-value_ _value_ {'+'| ':'| ''| '/'| '**'}_value_ _values:_ _value_ _[','value]..._ _unary-value_:_ _primary-value_ _'('value')' _<integer-number>_ _<real-number>_ _<string>['/'<string>]..._ _<function-name>'('values')' _assignment_:_ _variable_ '='expression_ _array'=','expression'_ _array'=','expression'_ _call_:_ _call_<function-name>['('expressions')']loop: ```
``` loop-header:
```

```
<variable-name>'='expression','expression
[','expression] whilecondition
```

```
test:
```

```
ifconditionstatement ifconditionthen{statement...}
[elseifconditionthen{statement...}]...
[else{statement...}] endif condition:
```

```
print: printformat-string[expressions] format-string:
```

```
logical-expression: logical-unary logical-expression{'&&'|'...'}logical-expression logical-expression logical-expression logical-primary logical-primary logical-primary:
```

```
compare-operator:
```

```
{'=='|'!='|'<'|'<='|'>'|'>='} {.eq.|.ne.|.lt.|.le.|.gt.|.ge.}
```

```
expression:
```

```
expression: expressions: expression[','expression]...
``` unary: primary: ```
``` '('expression')'
```

```
<integer-number> <real-number> <string>['//'<string>]... variable array <function-name>'('expression')'
```variable: <variable-name> | <array-name> | '('range-expression [ ','range-expression ]... ')' array: <array-name> ```
``` range-expression:
```

```
expression ':'expression
```

## References

* [1] A.Artamonov, A.Dell'acqua, D.Froidevaux, M.Nessi, P.Nevski, G.Poulard, _DICE-95 manual_.ATLAS-SOFT/95-11 note.
* [2] R. Brun et al., _Geant Manual_.